喵~ 主人你好呀！你把所有和“层次遍历”相关的题目都整理到了一起，形成了一个专题，这种“集中火力”的学习方法真的太棒了！(ﾉ´ヮ`)ﾉ*:･ﾟ✧

这些题目都围绕着一个共同的核心，主人你已经敏锐地发现了这一点——它们都可以用一个通用的“**层次遍历模板**”来解决。你的解法思路非常清晰：先用一个通用函数得到所有分好层的节点，然后再对这个结果进行“二次加工”。这是一个非常棒的模块化思想！

现在，我来帮你把这个专题整理成一份详细的笔记，并为你展示一下如何将“两步走”合并为“一步到位”的最高效解法。

---

### **专题笔记：二叉树的层次遍历**

#### **核心引擎：队列与层次遍历模板**

所有层次遍历问题的“心脏”，都是**队列 (Queue)**。我们利用它“先进先出”的特性，来保证我们总是一层一层地处理节点。你写的 `levelOrder` 函数，就是一个可以解决所有这些问题的“万能模板”！

Go

```
// 万能模板：二叉树层次遍历
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }
    ans := [][]int{}
    queue := []*TreeNode{root} // 用切片模拟队列
    for len(queue) > 0 {
        levelSize := len(queue)
        levelAns := []int{}
        // 关键：只循环当前层的节点数
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:] // 出队
            levelAns = append(levelAns, node.Val)
            if node.Left != nil {
                queue = append(queue, node.Left) // 孩子入队
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        ans = append(ans, levelAns)
    }
    return ans
}
```

---

#### **[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)**

**你的解法思路**：这道题就是层次遍历的基础，要求按层输出，你的代码直接就解决了这个问题。

**你的优秀代码 (即最优解)**：

Go

```
func levelOrder(root *TreeNode) [][]int {
	if root == nil {
		return [][]int{}
	}
	ans := [][]int{}
	queue := []*TreeNode{root}
	for len(queue) != 0 {
		level_size := len(queue)
		level_ans := []int{}
		for i := 0; i < level_size; i++ {
			node := queue[0]
			level_ans = append(level_ans, node.Val)
			queue = queue[1:]

			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
		ans = append(ans, level_ans)
	}
	return ans
}
```

**最优解思路**：你的解法已经是本题的标准最优解啦！

---

#### **[107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)**

**你的解法思路**：先进行一次从上到下的标准层次遍历，得到结果后，再将整个结果数组翻转。

**你的优秀代码：**

Go

```
import "slices" // Go 1.21+

func levelOrderBottom(root *TreeNode) [][]int {
    ans := levelOrder(root)
    slices.Reverse(ans) // 原地翻转
    return ans
}
// ... (复用上面的 levelOrder 函数)
```

**最优解思路**：你的解法在 Go 语言中就是最高效、最地道的！因为在 Go 中，向一个切片的头部添加元素（`ans = append([][]int{levelAns}, ans...)`）效率较低，所以“先正序遍历再整体翻转”是最佳实践。

---

#### **[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)**

**你的解法思路**：先进行标准层次遍历，然后取出每一层结果数组的最后一个元素。

**你的优秀代码：**

Go

```
func rightSideView(root *TreeNode) []int {
    ans := levelOrder(root)
    right_ans := []int{}
    for _, level_ans := range ans {
        right_ans = append(right_ans, level_ans[len(level_ans)-1])
    }
    return right_ans
}
// ... (复用 levelOrder 函数)
```

最优解思路：我们可以在层次遍历的同时，就把右视图的结果记录下来。

最优解代码示例 ✨

Go

```
func rightSideView(root *TreeNode) []int {
    if root == nil { return []int{} }
    ans := []int{}
    queue := []*TreeNode{root}
    for len(queue) > 0 {
        levelSize := len(queue)
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            // ✨ 关键：只在遍历到每层的最后一个元素时，才记录
            if i == levelSize-1 {
                ans = append(ans, node.Val)
            }
            if node.Left != nil { queue = append(queue, node.Left) }
            if node.Right != nil { queue = append(queue, node.Right) }
        }
    }
    return ans
}
```

---

#### **[637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)**

**你的解法思路**：先进行标准层次遍历，然后对每一层的结果数组单独计算平均值。

**你的优秀代码：**

Go

```
func averageOfLevels(root *TreeNode) []float64 {
    ans := levelOrder(root)
    average_ans := []float64{}
    for _, level_ans := range ans {
        average_ans = append(average_ans, averageInts(level_ans))
    }
    return average_ans
}
// ... (复用 levelOrder 和 averageInts 函数)
```

最优解思路：同样，我们可以在遍历每一层的同时，计算该层的总和。

最优解代码示例 ✨

Go

```
func averageOfLevels(root *TreeNode) []float64 {
    if root == nil { return []float64{} }
    ans := []float64{}
    queue := []*TreeNode{root}
    for len(queue) > 0 {
        levelSize := len(queue)
        levelSum := 0.0 // 用浮点数来存总和
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            levelSum += float64(node.Val) // ✨ 累加
            if node.Left != nil { queue = append(queue, node.Left) }
            if node.Right != nil { queue = append(queue, node.Right) }
        }
        // ✨ 计算平均值并加入结果
        ans = append(ans, levelSum / float64(levelSize))
    }
    return ans
}
```

---

#### **[429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)**

**你的解法思路**：将二叉树层次遍历的逻辑，从处理 `Left` 和 `Right` 两个孩子，扩展到处理 `Children` 切片里的所有孩子。

**你的优秀代码 (即最优解)**：

Go

```
/**
 * Definition for a Node.
 * type Node struct {
 * Val int
 * Children []*Node
 * }
 */
func levelOrder(root *Node) [][]int {
    if root == nil {
        return [][]int{}
    }
    ans := [][]int{}
    queue := []*Node{root}
    for len(queue) != 0 {
        level_size := len(queue)
        level_ans := []int{}
        for i := 0; i < level_size; i++ {
            nowNode := queue[0]
            queue = queue[1:]
            level_ans = append(level_ans, nowNode.Val)
            // 关键：将所有孩子节点一次性入队
            queue = append(queue, nowNode.Children...)
        }
        ans = append(ans, level_ans)
    }
    return ans
}
```

**最优解思路**：你的解法就是本题的标准最优解！`...` 展开操作符用得非常漂亮！

---

#### **[515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)**

**你的解法思路**：先进行标准层次遍历，然后对每一层的结果数组单独计算最大值。

**你的优秀代码：**

Go

```
func largestValues(root *TreeNode) []int {
	ans := levelOrder(root)
	large_ans := []int{}
	for _, level_ans := range ans {
        large_ans = append(large_ans, IntsMax(level_ans))
	}
    return large_ans
}
// ... (复用 levelOrder 和 IntsMax 函数)
```

最优解思路：和求平均值类似，在遍历每一层的同时，维护一个 levelMax 变量。

最优解代码示例 ✨

Go

```
import "math"
func largestValues(root *TreeNode) []int {
    if root == nil { return []int{} }
    ans := []int{}
    queue := []*TreeNode{root}
    for len(queue) > 0 {
        levelSize := len(queue)
        levelMax := math.MinInt64 // 初始化为最小值
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            if node.Val > levelMax { // ✨ 更新最大值
                levelMax = node.Val
            }
            if node.Left != nil { queue = append(queue, node.Left) }
            if node.Right != nil { queue = append(queue, node.Right) }
        }
        ans = append(ans, levelMax)
    }
    return ans
}
```

### 总结一下喵~ 💖

主人你模块化、代码复用的思想非常好！先写一个通用的 `levelOrder`，再在它的基础上解决其他问题，这是非常棒的工程思维。

而我们讨论的“最优解”，只是把“第二步”的加工，挪到了“第一步”的遍历中**顺手做掉**，从而节省了中间存储整个树结构的空间，让代码在处理超大数据时更高效。

你能把一个“层次遍历”的模板，应用到这么多不同的场景中，说明你已经真正掌握了它的精髓啦！为你鼓掌！(ɔˆ ³(ˆ⌣ˆc)