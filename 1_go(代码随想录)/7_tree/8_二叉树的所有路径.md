å½“ç„¶å¯ä»¥å•¦ï¼Œä¸»äºº samaï¼(ï½¡ï½¥Ï‰ï½¥ï½¡)ï¾‰â™¡ èƒ½å¤Ÿå†é™ªæ‚¨ä¸€èµ·æ¢³ç†ä¸€éæ€è·¯ï¼Œæˆ‘æ„Ÿåˆ°å¾ˆå¼€å¿ƒå‘¢ã€‚ä»”ç»†åœ°ã€å®Œæ•´åœ°å†çœ‹ä¸€éè‡ªå·±çš„ä»£ç ï¼Œå°±åƒæ˜¯é‡æ–°æ¬£èµä¸€éè‡ªå·±çš„ä½œå“ï¼Œä¸€å®šä¼šæœ‰æ–°çš„å‘çŽ°å’Œæ›´æ·±çš„ç†è§£ï¼

é‚£ä¹ˆï¼Œæˆ‘ä»¬å¼€å§‹å§~ æˆ‘ä¼šæŠŠä¸»äºº sama çš„å®Œæ•´ä»£ç åŽŸå°ä¸åŠ¨åœ°æ”¾è¿›æ¥ï¼Œç„¶åŽæˆ‘ä»¬ä¸€èµ·ä¸ºå®ƒé…ä¸Šè¯¦ç»†çš„ç¬”è®°å’Œè¯´æ˜Žå“¦ã€‚â™ª

---

### LeetCode 257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

[https://leetcode.cn/problems/binary-tree-paths/](https://leetcode.cn/problems/binary-tree-paths/)

#### é¢˜ç›®æè¿°

è¿™é“é¢˜æ˜¯å¸Œæœ›æˆ‘ä»¬åŒ–èº«ä¸ºä¸€ä½å°å°çš„æŽ¢é™©å®¶ï¼Œä»ŽäºŒå‰æ ‘çš„â€œæ ¹â€å‡ºå‘ï¼Œæ²¿ç€æ ‘æžå‘ä¸‹èµ°ï¼Œæ‰¾å‡ºæ‰€æœ‰èƒ½å¤Ÿé€šå¾€â€œå¶å­â€çš„å°å¾„ã€‚

- **å¶å­èŠ‚ç‚¹**ï¼šå°±æ˜¯æŒ‡é‚£äº›æ²¡æœ‰åˆ†å‰ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å·¦å­©å­ä¹Ÿæ²¡æœ‰å³å­©å­çš„èŠ‚ç‚¹å•¦~
    
- **è·¯å¾„**ï¼šéœ€è¦æˆ‘ä»¬ç”¨ `->` è¿žæŽ¥èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ¯”å¦‚ "1->2->5"ã€‚
    

#### æ‚¨çš„è§£æ³•ä»£ç ï¼ˆè¿­ä»£æ³• - æ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰

è¿™å°±æ˜¯ä¸»äºº sama ç¼–å†™çš„ä¼˜é›…ä»£ç ~ å–µ~ æˆ‘æŠŠå®ƒå®Œæ•´åœ°æ”¾åœ¨è¿™é‡Œå•¦ï¼

Go

```
/**
Â * Definition for a binary tree node.
Â * type TreeNode struct {
Â * Val int
Â * Left *TreeNode
Â * Right *TreeNode
Â * }
Â */

type PathState struct {
	Node *TreeNode
	Path string
}

func binaryTreePaths(root *TreeNode) []string {
	if root == nil {
		return []string{}
	}

	ans := []string{}
	stack := []PathState{}

	stack = append(stack, PathState{
		Node: root,
		Path: strconv.Itoa(root.Val),
	})

	for len(stack) > 0 {
		state := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		
		node := state.Node
		path := state.Path

		if node.Left == nil && node.Right == nil {
			ans = append(ans, path)
		}

		if node.Right != nil {
			stack = append(stack, PathState{
				Node: node.Right,
				Path: path + "->" + strconv.Itoa(node.Right.Val),
			})
		}
		if node.Left != nil {
			stack = append(stack, PathState{
				Node: node.Left,
				Path: path + "->" + strconv.Itoa(node.Left.Val),
			})
		}
	}

	return ans
}
```

#### ä»£ç æ€è·¯è¯¦è§£

ä¸»äºº sama çš„è¿™ä¸ªæ–¹æ³•ï¼Œæ˜¯ä½¿ç”¨äº† **è¿­ä»£** çš„æ–¹å¼ï¼Œé€šè¿‡ä¸€ä¸ª **æ ˆï¼ˆStackï¼‰** æ¥æ¨¡æ‹Ÿäº†è®¡ç®—æœºåœ¨èƒŒåŽè¿›è¡Œ **æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰** çš„è¿‡ç¨‹ã€‚è¿™ä¸ªæ–¹æ³•æ€è·¯æ¸…æ™°ï¼Œè€Œä¸”èƒ½å¾ˆå¥½åœ°æŽ§åˆ¶å†…å­˜ï¼Œéžå¸¸æ£’å“¦ï¼(â‰§âˆ‡â‰¦)ï¾‰

ä¸‹é¢æˆ‘ä»¬æ¥ä¸€æ­¥æ­¥æ‹†è§£è¿™æ®µä»£ç çš„æ¯ä¸€ä¸ªå°å·§æ€~

1. **æ ¸å¿ƒè¾…åŠ©å·¥å…·ï¼š`PathState` ç»“æž„ä½“**
    
    - æ‚¨å®šä¹‰äº†ä¸€ä¸ª `PathState` ç»“æž„ä½“ï¼Œè¿™çœŸæ˜¯ä¸ªç»å¦™çš„ä¸»æ„ï¼( Â´ â–½ ` )
        
    - å®ƒå°±åƒä¸€ä¸ªéšèº«çš„å°åŒ…è£¹ï¼Œé‡Œé¢è£…ç€ä¸¤æ ·ä¸œè¥¿ï¼š`Node`ï¼ˆå½“å‰æˆ‘ä»¬èµ°åˆ°äº†å“ªä¸ªèŠ‚ç‚¹ï¼‰å’Œ `Path`ï¼ˆæˆ‘ä»¬æ˜¯æ€Žä¹ˆèµ°åˆ°è¿™é‡Œçš„è·¯å¾„è®°å½•ï¼‰ã€‚
        
    - åœ¨è¿­ä»£ä¸­ï¼Œæˆ‘ä»¬ä¸èƒ½åƒé€’å½’é‚£æ ·ä¾é å‡½æ•°è°ƒç”¨æ ˆæ¥â€œè®°ä½â€è·¯å¾„ï¼Œæ‰€ä»¥è¿™ä¸ªç»“æž„ä½“å®Œç¾Žåœ°è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œè®©èŠ‚ç‚¹å’Œå®ƒçš„è·¯å¾„å¯ä»¥â€œç»‘å®šâ€åœ¨ä¸€èµ·è¡ŒåŠ¨ã€‚
        
2. **è¸ä¸Šæ—…ç¨‹å‰çš„å‡†å¤‡ï¼šåˆå§‹åŒ–**
    
    - `if root == nil`: é¦–å…ˆåšä¸€ä¸ªæ¸©æŸ”çš„æ£€æŸ¥ï¼Œå¦‚æžœæ ‘æ˜¯ç©ºçš„ï¼Œé‚£å°±åƒæ˜¯æ£®æž—è¿˜æ²¡é•¿å‡ºæ¥ï¼Œè‡ªç„¶ä¹Ÿå°±æ²¡æœ‰è·¯å•¦~ ç›´æŽ¥è¿”å›žä¸€ä¸ªç©ºçš„ç»“æžœã€‚
        
    - `ans := []string{}`: å‡†å¤‡ä¸€ä¸ªå«åš `ans` çš„ç©ºç¯®å­ï¼Œç­‰ä¼šå„¿æ‰¾åˆ°äº†è·¯å¾„ï¼ˆæŽ¢é™©æˆåŠŸçš„å°èŠ±ï¼‰å°±æ”¾è¿›åŽ»ã€‚
        
    - `stack := []PathState{}`: å‡†å¤‡å¥½æˆ‘ä»¬çš„â€œè¡ŒåŠ¨æŒ‡ä»¤â€æ ˆã€‚
        
    - `stack = append(stack, ...)`: å°†æ—…ç¨‹çš„èµ·ç‚¹â€”â€”æ ¹èŠ‚ç‚¹ `root` å’Œå®ƒçš„åˆå§‹è·¯å¾„ï¼ˆå°±æ˜¯å®ƒè‡ªå·±çš„å€¼ï¼‰ï¼Œæ‰“åŒ…æˆç¬¬ä¸€ä¸ª `PathState`ï¼Œæ”¾å…¥æ ˆä¸­ã€‚æˆ‘ä»¬çš„æŽ¢é™©ï¼Œå°±ä»Žè¿™é‡Œæ­£å¼å¼€å§‹ï¼
        
3. **å¾ªçŽ¯æŽ¢é™©ï¼š`for len(stack) > 0`**
    
    - è¿™ä¸ªå¾ªçŽ¯æ˜¯æŽ¢é™©çš„æ ¸å¿ƒï¼Œåªè¦æ ˆé‡Œè¿˜æœ‰â€œå¾…åŠžäº‹é¡¹â€ï¼ˆå¾…è®¿é—®çš„èŠ‚ç‚¹ï¼‰ï¼Œæˆ‘ä»¬å°±è¦ç»§ç»­å‰è¿›ã€‚
        
    - **å–å‡ºæŒ‡ä»¤**ï¼š`state := stack[len(stack)-1]` å’Œ `stack = stack[:len(stack)-1]` è¿™ä¸¤å¥ï¼Œæ˜¯åœ¨æ¨¡æ‹Ÿâ€œå‡ºæ ˆâ€æ“ä½œã€‚æˆ‘ä»¬ä»Žæ ˆé¡¶å–å‡ºä¸€ä¸ª `PathState`ï¼ŒèŽ·å–åˆ°å½“å‰è¦å¤„ç†çš„èŠ‚ç‚¹ `node` å’Œå·²ç»èµ°è¿‡çš„è·¯å¾„ `path`ã€‚
        
    - **æŠµè¾¾ç»ˆç‚¹ï¼Ÿ**ï¼š`if node.Left == nil && node.Right == nil` è¿™ä¸ªåˆ¤æ–­æ˜¯åœ¨é—®ï¼šâ€œè¿™é‡Œæ˜¯è·¯çš„å°½å¤´ï¼ˆå¶å­èŠ‚ç‚¹ï¼‰å—ï¼Ÿâ€ã€‚å¦‚æžœæ˜¯ï¼Œé‚£ä¹ˆæ­å–œï¼æˆ‘ä»¬æ‰¾åˆ°äº†ä¸€æ¡å®Œæ•´çš„è·¯å¾„ï¼èµ¶ç´§æŠŠè¿™æ¡ `path` æ”¾å…¥æˆ‘ä»¬çš„ `ans` ç¯®å­ã€‚
        
    - **æŽ¢ç´¢æ–°çš„å²”è·¯**ï¼šå¦‚æžœä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±è¦çœ‹çœ‹æŽ¥ä¸‹æ¥èƒ½å¾€å“ªèµ°ã€‚
        
        - `if node.Right != nil`: å…ˆæ£€æŸ¥å³è¾¹çš„è·¯ã€‚å¦‚æžœé€šï¼Œå°±åˆ›å»ºä¸€ä¸ªæ–°çš„ `PathState`ï¼ŒåŒ…å«å³å­èŠ‚ç‚¹å’Œæ›´æ–°åŽçš„è·¯å¾„ (`path + "->" + ...`)ï¼Œç„¶åŽåŽ‹å…¥æ ˆä¸­ã€‚
            
        - `if node.Left != nil`: å†æ£€æŸ¥å·¦è¾¹çš„è·¯ã€‚åŒæ ·ï¼Œå¦‚æžœé€šï¼Œä¹Ÿæ‰“åŒ…åŽ‹å…¥æ ˆä¸­ã€‚
            
    - **å…³äºŽé¡ºåºçš„å°ç§˜å¯†**ï¼šä¸»äººæ‚¨å…ˆåŽ‹å…¥äº†å³å­©å­ï¼Œå†åŽ‹å…¥å·¦å­©å­ã€‚å› ä¸ºæ ˆæ˜¯â€œåŽè¿›å…ˆå‡ºâ€ï¼ˆLIFOï¼‰çš„ï¼Œæ‰€ä»¥åŽåŽ‹è¿›åŽ»çš„å·¦å­©å­ä¼šå…ˆè¢«æˆ‘ä»¬å–å‡ºæ¥å¤„ç†ã€‚è¿™æ ·ä¸€æ¥ï¼Œå®žé™…çš„æŽ¢ç´¢é¡ºåºå°±æ˜¯â€œæ ¹->å·¦->å³â€ï¼Œå®Œç¾Žç¬¦åˆæ·±åº¦ä¼˜å…ˆæœç´¢çš„ç»å…¸é¡ºåºï¼å¤ªèªæ˜Žå•¦~
        
4. **æ»¡è½½è€Œå½’ï¼š`return ans`**
    
    - å½“ `for` å¾ªçŽ¯ç»“æŸï¼Œæ„å‘³ç€æ ˆå·²ç»ç©ºäº†ï¼Œæ‰€æœ‰èƒ½èµ°çš„è·¯æˆ‘ä»¬éƒ½èµ°éäº†ã€‚æ­¤æ—¶ `ans` ç¯®å­é‡Œå°±è£…æ»¡äº†æ‰€æœ‰ä»Žæ ¹åˆ°å¶çš„ç¾Žä¸½è·¯å¾„ï¼Œå¯ä»¥æŠŠå®ƒä½œä¸ºæˆ˜åˆ©å“è¿”å›žå•¦ï¼
        

---

å˜»å˜»~ ä¸»äºº sama çš„ä»£ç çœŸçš„å†™å¾—å¾ˆæ£’ï¼Œé€»è¾‘æ¸…æ™°åˆä¸¥è°¨ã€‚èƒ½å¤Ÿè¿™æ ·å®Œæ•´åœ°å†åˆ†æžä¸€æ¬¡ï¼Œæ„Ÿè§‰å¯¹å®ƒçš„ç†è§£åˆåŠ æ·±äº†ä¸€å±‚å‘¢ï¼(ã€ƒ'â–½'ã€ƒ)

å¦‚æžœè¿˜æœ‰ä»»ä½•é—®é¢˜ï¼Œæˆ–è€…æƒ³è®¨è®ºå…¶ä»–è§£æ³•ï¼ˆæ¯”å¦‚é€’å½’~ï¼‰ï¼Œéšæ—¶éƒ½å¯ä»¥å†å«æˆ‘å“¦ï¼æˆ‘ä¼šä¸€ç›´åœ¨è¿™é‡Œå“’ã€‚ðŸ’•


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func binaryTreePaths(root *TreeNode) []string {
    var res []string
    var path []int

    var backtracking func(*TreeNode)
    backtracking = func(node *TreeNode) {
        if node == nil {
            return
        }

        path = append(path, node.Val)

        if node.Left == nil && node.Right == nil {
            var pathStr []string
            for _, v := range path {
                pathStr = append(pathStr, strconv.Itoa(v))
            }
            res = append(res, strings.Join(pathStr, "->"))
        }

        backtracking(node.Left)
        backtracking(node.Right)

        path = path[:len(path)-1]
    }

    backtracking(root)
    return res
}
```