喵~ 主人，深夜了呢，这是我们今天学习的最后一站啦！在你敏锐地修正了递归的范围之后，你已经成功地把一排士兵，排成了完美的平衡方阵！(｡˃ ᵕ ˂ )♡

能够这么快地根据提示，定位并修正自己代码里的问题，说明你对递归的理解已经非常深刻了。现在，就让我们伴着窗外的月色，为这道优雅的“分治”算法，做一份同样优雅的总结笔记吧！

---

### LeetCode 108. 将有序数组转换为二叉搜索树

**[题目链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)**

#### 题目描述

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

---

### 我们的思考之旅 ♪ (分而治之的艺术)

#### Phase 1: 核心目标 —— 如何确保“平衡”？

这道题的关键，不仅仅是构造一棵二叉搜索树，更是要保证它是**高度平衡**的。

对于一个已经排好序的数组，要怎么才能让构造出来的树最平衡呢？

答案非常直观：每次都选取数组最中间的那个元素作为根节点！

这样就能保证，分配给左子树的元素数量和分配给右子树的元素数量，尽可能是相等的。然后，对左右两个子数组，我们再用同样的方法，选取它们各自的中间元素作为子树的根……如此往复，最终形成的树，必然是平衡的。

这个“不断地对半分割，分别处理”的思想，就是大名鼎鼎的“**分而治之**”！

#### Phase 2: 递归的实现 (我们的“任命队长”策略)

我们将这个过程，想象成把一排士兵(`nums`)，组建成一个层级分明的作战方阵（BST）。

- **`getTree(nums, left, right)` 的使命**: 接收一支从下标 `left` 到 `right` 的小队，为他们任命一位队长（根节点），并将组建好的小分队**返回**。
    

**1. 终止条件 (无人可带)**

- `if left > right { return nil }`
    
- 如果分配给一位军官的士兵范围是空的（比如左边界超过了右边界），说明他手下无人，自然也组建不了队伍，直接向上级汇报“无人”（`return nil`）。
    

**2. 任命队长 (找到中点，创建根节点)**

- `mid := left + (right-left)/2`
    
- `root := &TreeNode{Val: nums[mid]}`
    
- 军官在自己的队伍里，找到最中间的那个士兵 `mid`，将他提拔为这个小分队的队长 `root`。
    

**3. 委派下属 (递归调用与我们犯的小错误)**

- **我们最初的错误**:
    
    Go
    
    ```
    // 错误的调用
    root.Left = getTree(nums, 0, mid-1) 
    root.Right = getTree(nums, mid+1, len(nums)-1)
    ```
    
    这个错误，就像是每个新上任的队长，都试图去管理**整个军队**最开始和最末尾的士兵，而不是只管理**自己手下**的那一小部分，导致了命令的混乱和无限循环。
    
- **正确的委派**: 队长只管理自己视野范围内的士兵。
    
    - `root.Left = getTree(nums, left, mid-1)`
        
        - 队长对一位副官说：“去，把我左手边的这群士兵（从我管辖范围的**起始 `left`**，到我**前面的 `mid-1`**）给我组建好！”
            
        - 然后，他接收副官返回的、已经组建好的左翼分队，连接到自己的左手边。
            
    - `root.Right = getTree(nums, mid+1, right)`
        
        - 同理，他派出另一位副官，去组建他右手边的士兵（从他**后面的 `mid+1`**，到我管辖范围的**末尾 `right`**）。
            

**4. 向上汇报 (`return root`)**

- 当队长 `root` 的左右翼分队都已组建并连接好后，他自己这个小分队就算完成了。他将整个组建好的队伍（`root`），向上级汇报。
    

---

### 最终代码实现 (你的完美方阵！)

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */

// 主函数：启动组建任务
func sortedArrayToBST(nums []int) *TreeNode {
    // 将整个士兵队列 (0 到 len(nums)-1) 交给组建函数
    return getTree(nums, 0, len(nums)-1)
}

// 递归函数：负责组建一个小分队，并返回其队长
func getTree(nums []int, left, right int) *TreeNode {
    // 1. 如果手下没有士兵了，就返回 nil
    if left > right {
        return nil
    }

    // 2. 找到中间的士兵，任命为队长（根节点）
    // 这样写 (left + (right-left)/2) 是为了防止 left+right 整数溢出，是好习惯哦！
    mid := left + (right-left)/2
    root := &TreeNode{Val: nums[mid]}

    // 3. 递归地去组建左翼和右翼分队
    // 左翼分队的范围是 [left, mid-1]
    root.Left = getTree(nums, left, mid-1)
    // 右翼分队的范围是 [mid+1, right]
    root.Right = getTree(nums, mid+1, right)
    
    // 4. 将组建好的、完整的当前分队，向上汇报
    return root
}
```

### 最终总结 (´▽`ʃ♡ƪ)

今天我们就到这里吧！你真的学了太多东西啦，从复杂的DP、精巧的回溯，到二叉树的各种遍历、查找、增删改，最后还用“分而治之”的思想完美地结束了今天的学习！你的大脑一定像一个高速运转后的CPU，需要好好休息才能把这些知识都整理归档，变成自己的宝藏哦！

晚安啦，主人，祝你做个关于代码和星辰的好梦~ ❤️