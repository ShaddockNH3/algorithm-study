当然可以喵！“翻转二叉树”是一道非常经典的题目，它能很好地帮助我们理解树的递归和迭代操作。我们这就把它整理成一份详细的笔记吧！(｡･ω･｡)ﾉ♡

---

### **专题笔记：翻转二叉树 (LeetCode 226)**

#### **## 题目描述**

[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

图示：

输入: [4, 2, 7, 1, 3, 6, 9]

```
      4
     / \
    2   7
   / \ / \
  1  3 6  9
```

**输出:** `[4, 7, 2, 9, 6, 3, 1]`

```
      4
     / \
    7   2
   / \ / \
  9  6 3  1
```

---

### ## 解法思路喵~

解决这个问题，我们有两种主流的、同样高效的方法：**递归法 (DFS)** 和 **迭代法 (BFS)**。

#### **方法一：递归法 —— 自顶向下的“镜面反射” 🪞**

这是最优雅、最直观的解法。它完美地利用了树的递归特性。

**核心思路**：

> 想要翻转整棵树，我只需要先**翻转我自己的左右孩子**，然后**命令我的左右孩子，也用同样的方法去翻转它们各自的子树**。

1. **递归终止条件**：如果当前节点是 `nil`，说明已经到了树的尽头，什么也不用做，直接返回。
    
2. **单层递归逻辑**：
    
    - **交换**：将当前节点的 `Left` 指针和 `Right` 指针进行交换。
        
    - **下探**：递归地调用函数，去处理交换后的左子树和右子树。
        

**Go 语言参考解法 ✨**

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
	// 递归的终止条件
	if root == nil {
		return nil
	}
	
	// 交换当前节点的左右孩子
	root.Left, root.Right = root.Right, root.Left
	
	// 递归地去翻转左右子树
	invertTree(root.Left)
	invertTree(root.Right)
	
	return root
}
```

---

#### **方法二：迭代法 (层次遍历) —— 一层一层的“镜面翻转”**

我们也可以用熟悉的**层次遍历**（广度优先搜索 BFS）来解决。

**核心思路**：

> 我们一层一层地遍历树，每访问到一个节点，就把它的一对“翅膀”（左右孩子）交换一下。

1. **初始化**：创建一个队列，把根节点 `root` 放进去。
    
2. **循环**：只要队列不为空，就不断地从里面取出节点。
    
3. **处理节点**：每取出一个节点，就交换它的左右孩子。
    
4. **孩子入队**：然后把这个节点的（原始的）左右孩子再放进队列里，等待下一轮的处理。
    

**Go 语言参考解法 ✨**

Go

```
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	
	// 使用切片模拟队列
	queue := []*TreeNode{root}

	for len(queue) > 0 {
		// 出队
		node := queue[0]
		queue = queue[1:]
		
		// 交换左右孩子
		node.Left, node.Right = node.Right, node.Left
		
		// 将（交换后的）新左右孩子入队
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}
	
	return root
}
```

### ## 总结一下喵~ 💖

|方法|优点|缺点|
|---|---|---|
|**递归法 (DFS)**|代码**极其简洁**，完美体现问题本质|树的深度过大时，有栈溢出的理论风险|
|**迭代法 (BFS)**|没有栈溢出风险，容易理解|代码量比递归稍多|

两种方法的时间复杂度都是 O(n)，都是非常优秀的解法！主人你可以根据自己的喜好来选择哦！(｡ゝω･)b✧