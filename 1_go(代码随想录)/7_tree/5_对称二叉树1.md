当然可以喵！“对称二叉树”是一道非常考验我们空间想象能力和递归/迭代转换能力的经典题目。主人你用“双队列”同步遍历的想法非常有创意，我们这就把它和你学到的其他方法一起，整理成一份超级详细的专题笔记！(｡･ω･｡)ﾉ♡

---

### **专题笔记：对称二叉树 (LeetCode 101)**

#### **## 题目描述**

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

图示：

输入: root = [1,2,2,3,4,4,3]

```
      1
     / \
    2   2
   / \ / \
  3  4 4  3 
```

这是一个对称二叉树，所以返回 `true`。

---

### ## 解法思路喵~

这道题的核心是判断根节点的“左子树”和“右子树”是不是**互为镜像**。我们有几种不同的方法来充当这个“魔镜”。

#### **方法一：你的思考过程：迭代法 (双队列) 🧠**

核心思路：

主人你的思路是，同时对根节点的左、右子树进行层次遍历，然后比较在同一层的节点们是否呈“镜像分布”。

**你的优秀代码 (修正后)：**

Go

```
func isSymmetric(root *TreeNode) bool {
	if root == nil {
		return true
	}

	queue_left, queue_right := []*TreeNode{root.Left}, []*TreeNode{root.Right}

	for len(queue_left) > 0 && len(queue_right) > 0 {
		// 检查当前层的节点数量是否一致
		if len(queue_left) != len(queue_right) {
			return false
		}
		
		level_len := len(queue_left)
		for i := 0; i < level_len; i++ {
			node_left := queue_left[0]
			queue_left = queue_left[1:]

			node_right := queue_right[0]
			queue_right = queue_right[1:]

			// 核心比较逻辑
			if node_left == nil && node_right == nil {
				continue
			}
			if node_left == nil || node_right == nil || node_left.Val != node_right.Val {
				return false
			}

			// 将子节点按镜像顺序入队
			queue_left = append(queue_left, node_left.Left)
			queue_left = append(queue_left, node_left.Right)
			queue_right = append(queue_right, node_right.Right)
			queue_right = append(queue_right, node_right.Left)
		}
	}
	
	// 最后确保两个队列都为空
	return len(queue_left) == len(queue_right)
}
```

**分析**：这个方法是可行的，但需要同时维护两个队列，代码相对复杂一些。不过能想到用这种方式来解题，说明你对层次遍历的理解非常灵活！

---

#### **方法二：最优解 I：递归法 (DFS) —— 最优雅的“照镜子” 🪞**

这是最符合直觉、代码也最简洁的解法。

核心思路：

我们可以把“判断一棵树是否对称”这个问题，转换成“判断两棵树是否互为镜像”。

1. 首先，一棵树 `root` 是对称的，当且仅当它的左子树 `root.Left` 和右子树 `root.Right` 互为镜像。
    
2. 那么，哪两种树 `p` 和 `q` 互为镜像呢？
    
    - 它们的根节点值相等。
        
    - 并且，`p` 的左子树 和 `q` 的**右子树** 互为镜像。
        
    - 并且，`p` 的右子树 和 `q` 的**左子树** 互为镜像。
        

你看，这个问题完美地分解成了性质相同的子问题，正是递归的拿手好戏！

**Go 语言参考解法 ✨**

Go

```
func isSymmetric(root *TreeNode) bool {
	if root == nil {
		return true
	}
	// 将问题转换为判断左右子树是否互为镜像
	return isMirror(root.Left, root.Right)
}

// 辅助函数：判断两棵树 p 和 q 是否互为镜像
func isMirror(p, q *TreeNode) bool {
	// 递归终止条件
	if p == nil && q == nil {
		return true // 两个都是空，是镜像的
	}
	if p == nil || q == nil || p.Val != q.Val {
		return false // 一个空一个不空，或者值不同，都不是镜像
	}
	
	// 递归调用：交叉比较
	return isMirror(p.Left, q.Right) && isMirror(p.Right, q.Left)
}
```

---

#### **方法三：最优解 II：迭代法 (单队列) —— 成双成对地比较**

这是更标准的迭代解法，它比双队列法更简洁。

核心思路：

我们只用一个队列，但队列里存放的是成对需要比较的节点。

1. 初始化队列，把第一对需要比较的“选手”——`root.Left` 和 `root.Right`——放进去。
    
2. 每次从队列里**同时取出两个**节点 `p` 和 `q` 进行比较。
    
3. 如果它们通过了镜像的考验，就把它们的子节点**交叉配对**后，再放入队列中。
    
    - `p.Left` 和 `q.Right` 配成一对，入队。
        
    - `p.Right` 和 `q.Left` 配成一对，入队。
        
4. 重复这个过程，直到队列为空。
    

**Go 语言参考解法 ✨**

Go

```
func isSymmetric(root *TreeNode) bool {
	if root == nil {
		return true
	}
	
	queue := []*TreeNode{root.Left, root.Right}

	for len(queue) > 0 {
		// 每次取出两个节点进行比较
		p := queue[0]
		q := queue[1]
		queue = queue[2:]

		if p == nil && q == nil {
			continue
		}
		if p == nil || q == nil || p.Val != q.Val {
			return false
		}
		
		// 交叉配对入队
		queue = append(queue, p.Left)
		queue = append(queue, q.Right)
		
		queue = append(queue, p.Right)
		queue = append(queue, q.Left)
	}

	return true
}
```

能把对称二叉树这道题想得这么明白，并且尝试用不同的方法去实现，主人你真的太厉害啦！(｡ゝω･)b✧


