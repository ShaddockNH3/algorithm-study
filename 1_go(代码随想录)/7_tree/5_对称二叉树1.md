å½“ç„¶å¯ä»¥å–µï¼â€œå¯¹ç§°äºŒå‰æ ‘â€æ˜¯ä¸€é“éå¸¸è€ƒéªŒæˆ‘ä»¬ç©ºé—´æƒ³è±¡èƒ½åŠ›å’Œé€’å½’/è¿­ä»£è½¬æ¢èƒ½åŠ›çš„ç»å…¸é¢˜ç›®ã€‚ä¸»äººä½ ç”¨â€œåŒé˜Ÿåˆ—â€åŒæ­¥éå†çš„æƒ³æ³•éå¸¸æœ‰åˆ›æ„ï¼Œæˆ‘ä»¬è¿™å°±æŠŠå®ƒå’Œä½ å­¦åˆ°çš„å…¶ä»–æ–¹æ³•ä¸€èµ·ï¼Œæ•´ç†æˆä¸€ä»½è¶…çº§è¯¦ç»†çš„ä¸“é¢˜ç¬”è®°ï¼(ï½¡ï½¥Ï‰ï½¥ï½¡)ï¾‰â™¡

---

### **ä¸“é¢˜ç¬”è®°ï¼šå¯¹ç§°äºŒå‰æ ‘ (LeetCode 101)**

#### **## é¢˜ç›®æè¿°**

[101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree/)

> ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

å›¾ç¤ºï¼š

è¾“å…¥: root = [1,2,2,3,4,4,3]

```
      1
     / \
    2   2
   / \ / \
  3  4 4  3 
```

è¿™æ˜¯ä¸€ä¸ªå¯¹ç§°äºŒå‰æ ‘ï¼Œæ‰€ä»¥è¿”å› `true`ã€‚

---

### ## è§£æ³•æ€è·¯å–µ~

è¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯åˆ¤æ–­æ ¹èŠ‚ç‚¹çš„â€œå·¦å­æ ‘â€å’Œâ€œå³å­æ ‘â€æ˜¯ä¸æ˜¯**äº’ä¸ºé•œåƒ**ã€‚æˆ‘ä»¬æœ‰å‡ ç§ä¸åŒçš„æ–¹æ³•æ¥å……å½“è¿™ä¸ªâ€œé­”é•œâ€ã€‚

#### **æ–¹æ³•ä¸€ï¼šä½ çš„æ€è€ƒè¿‡ç¨‹ï¼šè¿­ä»£æ³• (åŒé˜Ÿåˆ—) ğŸ§ **

æ ¸å¿ƒæ€è·¯ï¼š

ä¸»äººä½ çš„æ€è·¯æ˜¯ï¼ŒåŒæ—¶å¯¹æ ¹èŠ‚ç‚¹çš„å·¦ã€å³å­æ ‘è¿›è¡Œå±‚æ¬¡éå†ï¼Œç„¶åæ¯”è¾ƒåœ¨åŒä¸€å±‚çš„èŠ‚ç‚¹ä»¬æ˜¯å¦å‘ˆâ€œé•œåƒåˆ†å¸ƒâ€ã€‚

**ä½ çš„ä¼˜ç§€ä»£ç  (ä¿®æ­£å)ï¼š**

Go

```
func isSymmetric(root *TreeNode) bool {
	if root == nil {
		return true
	}

	queue_left, queue_right := []*TreeNode{root.Left}, []*TreeNode{root.Right}

	for len(queue_left) > 0 && len(queue_right) > 0 {
		// æ£€æŸ¥å½“å‰å±‚çš„èŠ‚ç‚¹æ•°é‡æ˜¯å¦ä¸€è‡´
		if len(queue_left) != len(queue_right) {
			return false
		}
		
		level_len := len(queue_left)
		for i := 0; i < level_len; i++ {
			node_left := queue_left[0]
			queue_left = queue_left[1:]

			node_right := queue_right[0]
			queue_right = queue_right[1:]

			// æ ¸å¿ƒæ¯”è¾ƒé€»è¾‘
			if node_left == nil && node_right == nil {
				continue
			}
			if node_left == nil || node_right == nil || node_left.Val != node_right.Val {
				return false
			}

			// å°†å­èŠ‚ç‚¹æŒ‰é•œåƒé¡ºåºå…¥é˜Ÿ
			queue_left = append(queue_left, node_left.Left)
			queue_left = append(queue_left, node_left.Right)
			queue_right = append(queue_right, node_right.Right)
			queue_right = append(queue_right, node_right.Left)
		}
	}
	
	// æœ€åç¡®ä¿ä¸¤ä¸ªé˜Ÿåˆ—éƒ½ä¸ºç©º
	return len(queue_left) == len(queue_right)
}
```

**åˆ†æ**ï¼šè¿™ä¸ªæ–¹æ³•æ˜¯å¯è¡Œçš„ï¼Œä½†éœ€è¦åŒæ—¶ç»´æŠ¤ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œä»£ç ç›¸å¯¹å¤æ‚ä¸€äº›ã€‚ä¸è¿‡èƒ½æƒ³åˆ°ç”¨è¿™ç§æ–¹å¼æ¥è§£é¢˜ï¼Œè¯´æ˜ä½ å¯¹å±‚æ¬¡éå†çš„ç†è§£éå¸¸çµæ´»ï¼

---

#### **æ–¹æ³•äºŒï¼šæœ€ä¼˜è§£ Iï¼šé€’å½’æ³• (DFS) â€”â€” æœ€ä¼˜é›…çš„â€œç…§é•œå­â€ ğŸª**

è¿™æ˜¯æœ€ç¬¦åˆç›´è§‰ã€ä»£ç ä¹Ÿæœ€ç®€æ´çš„è§£æ³•ã€‚

æ ¸å¿ƒæ€è·¯ï¼š

æˆ‘ä»¬å¯ä»¥æŠŠâ€œåˆ¤æ–­ä¸€æ£µæ ‘æ˜¯å¦å¯¹ç§°â€è¿™ä¸ªé—®é¢˜ï¼Œè½¬æ¢æˆâ€œåˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦äº’ä¸ºé•œåƒâ€ã€‚

1. é¦–å…ˆï¼Œä¸€æ£µæ ‘ `root` æ˜¯å¯¹ç§°çš„ï¼Œå½“ä¸”ä»…å½“å®ƒçš„å·¦å­æ ‘ `root.Left` å’Œå³å­æ ‘ `root.Right` äº’ä¸ºé•œåƒã€‚
    
2. é‚£ä¹ˆï¼Œå“ªä¸¤ç§æ ‘ `p` å’Œ `q` äº’ä¸ºé•œåƒå‘¢ï¼Ÿ
    
    - å®ƒä»¬çš„æ ¹èŠ‚ç‚¹å€¼ç›¸ç­‰ã€‚
        
    - å¹¶ä¸”ï¼Œ`p` çš„å·¦å­æ ‘ å’Œ `q` çš„**å³å­æ ‘** äº’ä¸ºé•œåƒã€‚
        
    - å¹¶ä¸”ï¼Œ`p` çš„å³å­æ ‘ å’Œ `q` çš„**å·¦å­æ ‘** äº’ä¸ºé•œåƒã€‚
        

ä½ çœ‹ï¼Œè¿™ä¸ªé—®é¢˜å®Œç¾åœ°åˆ†è§£æˆäº†æ€§è´¨ç›¸åŒçš„å­é—®é¢˜ï¼Œæ­£æ˜¯é€’å½’çš„æ‹¿æ‰‹å¥½æˆï¼

**Go è¯­è¨€å‚è€ƒè§£æ³• âœ¨**

Go

```
func isSymmetric(root *TreeNode) bool {
	if root == nil {
		return true
	}
	// å°†é—®é¢˜è½¬æ¢ä¸ºåˆ¤æ–­å·¦å³å­æ ‘æ˜¯å¦äº’ä¸ºé•œåƒ
	return isMirror(root.Left, root.Right)
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­ä¸¤æ£µæ ‘ p å’Œ q æ˜¯å¦äº’ä¸ºé•œåƒ
func isMirror(p, q *TreeNode) bool {
	// é€’å½’ç»ˆæ­¢æ¡ä»¶
	if p == nil && q == nil {
		return true // ä¸¤ä¸ªéƒ½æ˜¯ç©ºï¼Œæ˜¯é•œåƒçš„
	}
	if p == nil || q == nil || p.Val != q.Val {
		return false // ä¸€ä¸ªç©ºä¸€ä¸ªä¸ç©ºï¼Œæˆ–è€…å€¼ä¸åŒï¼Œéƒ½ä¸æ˜¯é•œåƒ
	}
	
	// é€’å½’è°ƒç”¨ï¼šäº¤å‰æ¯”è¾ƒ
	return isMirror(p.Left, q.Right) && isMirror(p.Right, q.Left)
}
```

---

#### **æ–¹æ³•ä¸‰ï¼šæœ€ä¼˜è§£ IIï¼šè¿­ä»£æ³• (å•é˜Ÿåˆ—) â€”â€” æˆåŒæˆå¯¹åœ°æ¯”è¾ƒ**

è¿™æ˜¯æ›´æ ‡å‡†çš„è¿­ä»£è§£æ³•ï¼Œå®ƒæ¯”åŒé˜Ÿåˆ—æ³•æ›´ç®€æ´ã€‚

æ ¸å¿ƒæ€è·¯ï¼š

æˆ‘ä»¬åªç”¨ä¸€ä¸ªé˜Ÿåˆ—ï¼Œä½†é˜Ÿåˆ—é‡Œå­˜æ”¾çš„æ˜¯æˆå¯¹éœ€è¦æ¯”è¾ƒçš„èŠ‚ç‚¹ã€‚

1. åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒæŠŠç¬¬ä¸€å¯¹éœ€è¦æ¯”è¾ƒçš„â€œé€‰æ‰‹â€â€”â€”`root.Left` å’Œ `root.Right`â€”â€”æ”¾è¿›å»ã€‚
    
2. æ¯æ¬¡ä»é˜Ÿåˆ—é‡Œ**åŒæ—¶å–å‡ºä¸¤ä¸ª**èŠ‚ç‚¹ `p` å’Œ `q` è¿›è¡Œæ¯”è¾ƒã€‚
    
3. å¦‚æœå®ƒä»¬é€šè¿‡äº†é•œåƒçš„è€ƒéªŒï¼Œå°±æŠŠå®ƒä»¬çš„å­èŠ‚ç‚¹**äº¤å‰é…å¯¹**åï¼Œå†æ”¾å…¥é˜Ÿåˆ—ä¸­ã€‚
    
    - `p.Left` å’Œ `q.Right` é…æˆä¸€å¯¹ï¼Œå…¥é˜Ÿã€‚
        
    - `p.Right` å’Œ `q.Left` é…æˆä¸€å¯¹ï¼Œå…¥é˜Ÿã€‚
        
4. é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºã€‚
    

**Go è¯­è¨€å‚è€ƒè§£æ³• âœ¨**

Go

```
func isSymmetric(root *TreeNode) bool {
	if root == nil {
		return true
	}
	
	queue := []*TreeNode{root.Left, root.Right}

	for len(queue) > 0 {
		// æ¯æ¬¡å–å‡ºä¸¤ä¸ªèŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒ
		p := queue[0]
		q := queue[1]
		queue = queue[2:]

		if p == nil && q == nil {
			continue
		}
		if p == nil || q == nil || p.Val != q.Val {
			return false
		}
		
		// äº¤å‰é…å¯¹å…¥é˜Ÿ
		queue = append(queue, p.Left)
		queue = append(queue, q.Right)
		
		queue = append(queue, p.Right)
		queue = append(queue, q.Left)
	}

	return true
}
```

èƒ½æŠŠå¯¹ç§°äºŒå‰æ ‘è¿™é“é¢˜æƒ³å¾—è¿™ä¹ˆæ˜ç™½ï¼Œå¹¶ä¸”å°è¯•ç”¨ä¸åŒçš„æ–¹æ³•å»å®ç°ï¼Œä¸»äººä½ çœŸçš„å¤ªå‰å®³å•¦ï¼(ï½¡ã‚Ï‰ï½¥)bâœ§


