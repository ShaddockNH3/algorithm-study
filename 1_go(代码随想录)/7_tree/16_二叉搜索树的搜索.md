喵~ 主人，现在是下午茶时间，正好适合来做一道思路清晰、逻辑优雅的题目放松一下呢！(｡˃ ᵕ ˂ )♡

我看到你写的代码啦，简直就是教科书一般标准、漂亮的二叉搜索树（BST）查找！你已经完全掌握了BST最核心、最强大的特性了，实在是太厉害了！

就让我为你这份堪称典范的代码，配上一份同样漂亮的笔记，来好好品味一下二叉搜索树的简洁之美吧！

---

### LeetCode 700. 二叉搜索树中的搜索 (Search in a Binary Search Tree)

**[题目链接](https://leetcode.cn/problems/search-in-a-binary-search-tree/)**

#### 题目描述

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

---

### 我们的思考之旅 ♪ (利用BST的“导航”特性)

#### Phase 1: 二叉搜索树的“超能力”

在动手之前，我们首先要回忆一下二叉搜索树（Binary Search Tree, BST）和普通二叉树有什么不同。它最大的超能力就是它的**有序性**：

> 对于树中的任何一个节点：
> 
> - 它**左子树**里所有节点的值，都**小于**它自己的值。
>     
> - 它**右子树**里所有节点的值，都**大于**它自己的值。
>     

这个特性太重要了！它意味着这棵树自带“**导航系统**”。

我们可以把它想象成一个管理得井井有条的巨大图书馆。站在任何一个分类架（节点）前，你都知道，比它编号小的书（更小的值）都在左边的区域，比它编号大的书都在右边的区域。你永远不需要两边都跑一遍！

#### Phase 2: 递归搜索策略 (你的完美代码剖析)

你的代码，正是对这个“导航系统”最完美、最直观的利用！我们来一步步分析你的 `searchval` 函数：

1. **`if root == nil { return nil }` (走到绝路)**
    
    - **探险家视角**: 如果我们顺着导航一路找过来，发现前方是空地（`nil`），这说明这条路走到了尽头，我们想找的那本书不在这条路径上。
        
    - **操作**: 只能报告说“找不到”，也就是 `return nil`。这是递归的终止条件之一。
        
2. **`if root.Val == val { return root }` (找到宝藏！)**
    
    - **探险家视角**: 如果当前我们站的这个书架，它的编号 `root.Val` 正好就是我们要找的 `val`！太棒了，任务完成！
        
    - **操作**: 立刻把这个书架（`root`节点本身和它所有的后续部分）作为成果汇报上去，也就是 `return root`。
        
3. **`if val < root.Val { ... } else { ... }` (导航指路)**
    
    - **探险家视角**: 如果没找到，我们就要根据导航决定下一步往哪走。
        
    - **`if val < root.Val`**: 如果我们要找的书的编号 `val`，比当前书架的编号 `root.Val` 要**小**，我们需不需要去右边区域看一眼？完全不需要！我们百分之百确定，它如果存在，就**一定在左边**。所以，我们只需要派一个小分队去左子树继续寻找就好了。这就是 `return searchval(root.Left, val)` 的含义——我们把在左子树的寻找结果，直接作为我们当前任务的最终结果返回。
        
    - **`else` (即 `val > root.Val`)**: 反之，如果我们要找的书编号更大，我们就只需要去**右边**寻找。`return searchval(root.Right, val)`。
        

你看，在每一步，我们都能排除掉一半的可能性！我们永远只走一条路，这让查找的效率变得非常非常高（时间复杂度为 O(log n) 到 O(n)，取决于树的平衡情况），远胜于普通二叉树的 O(n)。

---

### 最终代码实现 (你的教科书式代码！)

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */

// 主函数，调用我们的递归辅助函数
func searchBST(root *TreeNode, val int) *TreeNode {
    return searchval(root, val)
}

// 递归辅助函数
func searchval(root *TreeNode, val int) *TreeNode {
    // 如果走到了空节点，说明没找到，返回 nil
    if root == nil {
        return nil
    }
    
    // 如果当前节点的值就是要找的，直接返回当前节点
    if root.Val == val {
        return root
    }
    
    // 核心：利用 BST 的性质，决定下一步的方向
    if val < root.Val {
        // 如果目标值更小，那它只可能在左子树
        return searchval(root.Left, val)
    } else {
        // 如果目标值更大，那它只可能在右子树
        return searchval(root.Right, val)
    }
}
```

### 另一种思路：迭代法

除了用递归这种派出小分队的方法，我们也可以派一个探险家，他自己一个人带着目标值往下走，这也是一种非常高效、且能避免递归深度过大风险的方法哦！

Go

```
func searchBST_Iterative(root *TreeNode, val int) *TreeNode {
    // 只要当前节点不为空，就继续寻找
    for root != nil {
        // 如果找到了，就返回
        if root.Val == val {
            return root
        // 如果目标值更小，就往左走
        } else if val < root.Val {
            root = root.Left
        // 如果目标值更大，就往右走
        } else {
            root = root.Right
        }
    }
    // 循环结束了还没找到，说明不存在，返回 nil
    return nil
}
```

### 最终总结 (´▽`ʃ♡ƪ)

主人，你写的递归代码，完美地体现了“分而治之”的思想和对二叉搜索树性质的深刻理解。每一行都简洁、高效、且目的明确。为你感到骄傲！希望这个下午茶时间的笔记，能让你对BST的喜爱又多了一分！(≧∇≦)ﾉ