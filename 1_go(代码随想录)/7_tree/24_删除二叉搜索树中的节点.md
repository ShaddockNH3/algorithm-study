喵~ 主人，没关系的！这道题被誉为二叉树操作的“毕业设计”，它把我们之前学到的所有递归技巧都融合在了一起，第一次接触感觉有点迷是很正常的。这正说明我们正在挑战真正有价值的知识！(｡˃ ᵕ ˂ )♡

你最终在我的提示下，一步步拼凑出的代码，**正是这道题最经典、最优雅的递归解法**！你已经成功了！

现在，就让我为你把这台精密的“外科手术”的全过程，用最清晰、最耐心的方式，一步步拆解开来，让你彻底看懂我们究竟是施展了怎样神奇的魔法，好不好呀？

---

### LeetCode 450. 删除二叉搜索树中的节点

**[题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/)**

#### 题目描述

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

---

### 我们的思考之旅 ♪ (一场精密的“外科手术”)

#### Phase 1: 递归的“黄金约定” (手术的核心原则)

首先，我们必须再次明确我们递归函数 `deleteNode(node, key)` 的“黄金约定”，也就是它的**真实使命**：

> 我被派去以 `node` 为根的区域里，执行删除 `key` 的任务。任务完成后，我必须**返回**一个 `*TreeNode`，这个返回值代表了**该区域经过手术后，新的根节点是谁**。

正是因为有了这个约定，上级节点才能用 `root.Left = deleteNode(...)` 这样的方式，来接收和连接下级节点返回的、可能已经改变了的新子树。

#### Phase 2: 寻找手术台 (向下探索)

手术的第一步，是找到病人。你的代码的前半部分，就是利用BST的“导航”特性在做这件事：

- **`if key < root.Val`**: 如果病人的ID (`key`) 比当前房间号 (`root.Val`) 小，我们就知道他一定在左边病区。我们对手术室说：“去左边病区做手术，然后把**新的左边病区**交还给我”。这就是 `root.Left = deleteNode(root.Left, key)`。
    
- **`else if key > root.Val`**: 同理，去右边病区做手术。
    
- **`else`**: 找到了！当前 `root` 就是我们要进行手术的那个节点！
    

#### Phase 3: 执行手术 (处理删除的各种情况)

这是整个手术最复杂的部分，一旦 `key == root.Val`，我们就需要根据病人的“家属”情况（孩子数量）来决定手术方案：

**情况一 & 二：病人只有一个孩子或没有孩子 (最简单)**

Go

```
if root.Left == nil {
    return root.Right
}
if root.Right == nil {
    return root.Left
}
```

- **`if root.Left == nil`**: 如果病人没有左孩子，那么在他“消失”后，能顶替他位置的，就只有他的右孩子 `root.Right`。所以我们直接把 `root.Right` 作为这个区域的新主人（新的根节点）返回给上级。
    
- **`if root.Right == nil`**: 同理，如果病人没有右孩子，就让他的左孩子 `root.Left` 来接替位置。
    
- (一个隐藏的优雅之处：如果病人是叶子节点，即左右孩子都为空，那么第一个 `if root.Left == nil` 就会被满足，然后 `return root.Right`，而此时 `root.Right` 正好是 `nil`，完美地删除了这个叶子节点！)
    

**情况三：病人儿女双全 (最复杂)**

Go

```
// 1. 寻找继承人
tmp := root.Right
for tmp.Left != nil {
    tmp = tmp.Left
}
// 2. “灵魂互换”，完成王位交接
root.Val = tmp.Val
// 3. 清理继承人的“旧身体”
root.Right = deleteNode(root.Right, tmp.Val)
```

- **手术方案**: 直接切除这个节点是不行的，他的两个孩子会成为“孤儿”，树会断裂。我们需要一个“继承者”来接替他的位置。
    
- **1. 寻找继承人**: 为了维持BST的有序性，最好的继承人就是他**右子树里最左边的那个节点**（也就是比他大的那群人里，值最接近他的那一个）。你的 `for` 循环完美地找到了这个节点（在你的代码里它最终是 `tmp`）。
    
- **2. “灵魂互换”**: 我们不移动节点，而是进行“灵魂互换”。`root.Val = tmp.Val` 这行代码，把“继承人”的值，复制到了要删除的节点 `root` 身上。现在，`root` 节点看起来就像是那个“继承人”了，它原来的值被覆盖，相当于被删除了。
    
- **3. 清理“旧身体”**: 但是，现在树里有两个值一样的节点了！一个是我们“变身”后的`root`，另一个是那个还待在原来位置的“继承人”。所以，我们最后一步，就是把问题转化为一个更简单的任务：**去右子树里，把那个值为 `tmp.Val` 的“继承人”节点给删掉**。我们再次调用 `deleteNode`，它会轻松地完成这个任务（因为我们知道那个“继承人”节点肯定没有左孩子）。
    

#### Phase 4: 汇报手术结果 (`return root`)

在函数的最后，`return root` 负责处理两种情况：

1. 在“寻找手术台”的阶段，如果 `key` 不等于当前 `root.Val`，那么在更新完左/右子树后，当前 `root` 节点本身没有变化，需要把它返回给上级。
    
2. 在处理“双孩子”的手术时，我们是在 `root` 节点上做的“灵魂互换”，`root` 节点本身依然是这个区域的根，所以手术完成后，也要把这个修改过的 `root` 返回。
    

---

### 你的最终完美代码

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func deleteNode(root *TreeNode, key int) *TreeNode {
    // 递归出口：如果树为空，直接返回
    if root == nil {
        return nil
    }

    // --- 寻找阶段 ---
    if key < root.Val {
        // 去左子树执行删除，并用返回的新左子树替换旧的
        root.Left = deleteNode(root.Left, key)
    } else if key > root.Val {
        // 去右子树执行删除，并用返回的新右子树替换旧的
        root.Right = deleteNode(root.Right, key)
    } else { // --- 找到节点，执行手术 ---
        // 情况1: 右子树为空（包含叶子节点情况）
        if root.Right == nil {
            return root.Left
        }
        // 情况2: 左子树为空
        if root.Left == nil {
            return root.Right
        }
        // 情况3: 左右子树都存在
        // 1. 找到右子树的最左节点（继承者）
        successor := root.Right
        for successor.Left != nil {
            successor = successor.Left
        }
        // 2. “灵魂互换”，用继承者的值覆盖当前节点
        root.Val = successor.Val
        // 3. 转化为去右子树删除那个继承者
        root.Right = deleteNode(root.Right, successor.Val)
    }
    
    // 返回（可能被修改过的）当前子树的根节点
    return root
}
```

### 最终总结 (´▽`ʃ♡ƪ)

今天，我们从最简单的遍历，一路走到了最复杂的删除操作，你已经把二叉树（特别是BST）最重要的几个“手术”都亲手完成了！这绝对是值得骄傲的巨大成就！

你现在已经是一位非常出色的“树语者”啦！真的辛苦了，快去好好休息吧！晚安喵~ ❤️