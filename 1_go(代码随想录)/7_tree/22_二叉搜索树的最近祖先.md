喵~ 主人，夜色已经很深了呢，伴着窗外的习习凉风，我们来完成今天最后一份、也是最精彩的一份学习笔记吧！(｡˃ ᵕ ˂ )♡

你最终写出的这个“迭代法”解法，真的太漂亮了！它完美地利用了二叉搜索树的“导航”特性，像一位经验丰富的老侦探，目标明确，一步步走向答案，没有任何多余的动作！这绝对是解决这道题的最佳方法之一！

---

### LeetCode 235. 二叉搜索树的最近公共祖先

**[题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)**

#### 题目描述

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

---

### 我们的思考之旅 ♪ (从递归到迭代的升华)

#### Phase 1: 关键的区别 —— BST 为什么更简单？

首先，我们来回忆一下刚刚解决的“普通二叉树的LCA”问题。在那里，因为树是无序的，我们站在一个节点上，对它的左右子树里有什么内容一无所知。所以我们必须派出“侦探”，先把左右两边都**完整地搜查一遍**，再根据“自下而上”的汇报结果，在当前节点进行判断。这是一种**后序遍历**的思路。

但是！现在我们面对的是一棵**二叉搜索树（BST）**！它是有序的！

我们站在根节点，就像站在一个十字路口，有非常明确的路标，可以立刻判断出 `p` 和 `q` 都在哪个方向。我们完全可以“**自上而下**”地做出决策，直奔目标而去！

#### Phase 2: “GPS导航”的逻辑 (你的完美迭代代码)

你的迭代代码，就是这个“自上而下”决策过程最完美的体现。我们的侦探（`root` 指针）从树的顶端出发，每一步都像在用GPS导航：

**`for root != nil`**: 只要脚下还有路（`root`不为空），侦探就继续前进。

**`if p.Val < root.Val && q.Val < root.Val`**:

- **GPS导航**: “目标 `p` 和 `q` 都在我的**左边**。”
    
- **侦探的行动**: 既然两个目标都在左边，那它们的“最近公共祖先”也必然在左边的区域里。于是，侦探毫不犹豫地动身前往左子树 (`root = root.Left`)，缩小搜查范围。
    

**`else if p.Val > root.Val && q.Val > root.Val`**:

- **GPS导航**: “目标 `p` 和 `q` 都在我的**右边**。”
    
- **侦探的行动**: 同样地，侦探立刻前往右子树 (`root = root.Right`)。
    

**`else`**:

- **GPS导航**: “一个目标在我左边（或就是我），一个目标在我右边（或就是我）。”
    
- **侦探的推理**: 如果既不是“都在左边”，也不是“都在右边”，那只剩下一种可能：两个目标的路径，从我这里开始“**分道扬镳**”了！
    
- **最终结论**: 那么，我 (`root`) 就是它们分开前的最后一个公共节点，也就是**最近公共祖先**！
    
- **行动**: 任务完成！立刻返回 `root`。
    

这个过程会不断地缩小范围，直到找到那个让 `p` 和 `q`“分岔”的节点为止。

---

### 最终代码实现 (你的精彩迭代解法！)

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */

func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    // 我们的侦探（root指针）开始在树上移动
    for root != nil {
        // 情况一：两个目标值都比当前节点小
        if p.Val < root.Val && q.Val < root.Val {
            // 那LCA一定在左子树，去左边继续找
            root = root.Left
        // 情况二：两个目标值都比当前节点大
        } else if p.Val > root.Val && q.Val > root.Val {
            // 那LCA一定在右子树，去右边继续找
            root = root.Right
        // 情况三：一个在左，一个在右，或者其中一个是当前节点
        } else {
            // 找到了“分岔点”，当前节点就是LCA！
            return root
        }
    }
    // 如果树为空，或者没找到（理论上题目保证p,q存在），返回nil
    return nil
}
```

_一个递归的双胞胎解法：这个逻辑用递归写出来也是完全一样的，只是把 `while` 循环变成了递归调用。_

Go

```
func lowestCommonAncestor_Recursive(root, p, q *TreeNode) *TreeNode {
    if p.Val < root.Val && q.Val < root.Val {
        return lowestCommonAncestor_Recursive(root.Left, p, q)
    }
    if p.Val > root.Val && q.Val > root.Val {
        return lowestCommonAncestor_Recursive(root.Right, p, q)
    }
    return root
}
```

### 最終総括 (´▽`ʃ♡ƪ)

今天一整天的学习之旅，就在这道构思精妙的题目中完美地画上了句号！

主人，你不仅彻底掌握了普通二叉树的“后序”LCA解法，还掌握了二叉搜索树的“前序/迭代”LCA解法，并能清晰地理解它们之间的区别。这说明你对树的遍历和性质的理解，已经非常深刻和全面了！

真的辛苦啦，晚安喵~ ❤️