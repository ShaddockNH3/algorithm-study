喵~ 主人，周五的午后，阳光正好，我们来给今天的学习画上一个完美的句号吧！你已经把这道题解出来了，这超级厉害！(｡˃ ᵕ ˂ )♡

感觉“懵逼”是很正常的，因为你写的这段代码里，藏着递归最优雅、也最需要“信仰”的魔法！它把很多复杂的步骤都用一种非常简洁的方式表达了出来，以至于我们第一眼看会觉得“咦？这样就行了吗？”。

就让我来为你彻底揭秘这背后的神奇之处，让你真正地理解它，而不仅仅是会写它！

---

### LeetCode 669. 修剪二叉搜索树

**[题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/)**

#### 题目描述

给定一个二叉搜索树，同时给定最小边界 `low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在 `[low, high]` 中。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

---

### 我们的思考之旅 ♪ (递归的“信任”魔法)

#### Phase 1: 递归的“黄金约定” (我们不变的核心原则)

要理解这段代码，我们首先要再次明确我们递归函数 `trimBST(node, low, high)` 的“黄金约定”，也就是它的**真实使命**：

> **我被派去以 `node` 为根的这片区域，我的任务是把它修剪成所有节点值都在 `[low, high]` 范围内的样子。任务完成后，我必须【返回】一个 `*TreeNode`，这个返回值是【修剪后，这片区域新的根节点】。**

只要我们牢牢记住这个约定，代码里的每一行就都有了清晰的意义。

#### Phase 2: 代码的“审判”流程 (一步步看懂你的代码)

我们的函数就像一个“园丁”，在每个节点上，他都要做一个决定：

**1. `if root == nil { return nil }` (基础检查)**

- **园丁的逻辑**: 如果派我去修剪一片空地，那自然什么都不用做，修剪完后，它还是一片空地。
    
- **行动**: 返回 `nil`。
    

**2. `if root.Val < low { ... }` (当前节点太小了！)**

- **园丁的逻辑**: 当前这个节点 `root` 的值比下限 `low` 还小，所以它**自己必须被剪掉**。又因为这是二叉搜索树，它的**整个左子树**的所有节点只会比它更小，所以**整个左子树也必须全部剪掉**！
    
- **怎么办？**: 那么修剪完之后，这片区域新的根节点会是谁呢？唯一的希望，就只剩下**原来的右子树**了！
    
- **魔法时刻**: `return trimBST(root.Right, low, high)`
    
    - 这一句就是最神奇的地方！我们不需要自己动手去右子树里寻找新的根。我们完全**信任**我们的递归函数，我们对它下达指令：“嘿，`trimBST`，我知道答案肯定不在我 (`root`) 和我的左边了。**请你去把我的右子树彻底修剪好，然后把修剪完之后那个区域的【新根节点】直接返回给我就行了！**”
        
    - 我们把“寻找新根”这个艰巨的任务，完全委托给了对右子树的递归调用。
        

**3. `if root.Val > high { ... }` (当前节点太大了！)**

- **园丁的逻辑**: 和上面完全对称。当前节点 `root` 和它的**整个右子树**都太大了，必须全部剪掉。
    
- **怎么办？**: 唯一的希望，只剩下**原来的左子树**。
    
- **魔法时刻**: `return trimBST(root.Left, low, high)`
    
    - 同样，我们完全**信任**对左子树的递归调用，让它去完成修剪并返回一个合格的新根。
        

**4. `else { ... }` (当前节点不大不小，刚刚好！)**

- **园丁的逻辑**: `root.Val` 在 `[low, high]` 范围内，太棒了！这个节点**自己是合格的**，它在修剪后可以继续当这片区域的根节点。
    
- **怎么办？**: 但是，它的左右孩子不一定合格呀！所以，我们还需要对它的左右子树进行修剪。
    
- **魔法时刻**:
    
    - `root.Left = trimBST(root.Left, low, high)`: 我们派人去修剪左子树，并把返回的**新左子树**（可能和原来一样，也可能变了）重新连接到自己的左边。
        
    - `root.Right = trimBST(root.Right, low, high)`: 同理，修剪并连接右子树。
        
    - `return root`: 当左右两边都修剪完毕并连接好后，园丁很自信地报告：“我这里已经修剪完毕，我 (`root`) 就是这片区域合格的根节点！”
        

---

### 你的最终完美代码

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func trimBST(root *TreeNode, low int, high int) *TreeNode {
    // 递归出口：如果当前是空节点，修剪后还是空节点
    if root == nil {
        return nil
    }

    // --- 在当前节点做决定 ---

    // 如果当前节点值太小
    if root.Val < low {
        // 那么整个左子树也一定都太小，必须全部舍弃。
        // 我们只需要去右子树里继续寻找和修剪，
        // 并完全信任递归调用的返回值就是这片区域修剪后的新根。
        return trimBST(root.Right, low, high)
    }
    
    // 如果当前节点值太大
    if root.Val > high {
        // 那么整个右子树也一定都太大，必须全部舍弃。
        // 完全信任对左子树的递归调用。
        return trimBST(root.Left, low, high)
    }

    // --- 如果当前节点值不大不小，刚刚好 ---
    // 那么当前节点在修剪后依然是根节点。
    // 但它的左右孩子还需要继续修剪。
    root.Left = trimBST(root.Left, low, high)
    root.Right = trimBST(root.Right, low, high)
    
    // 将修剪好的当前节点返回给上级
    return root
}
```

### 最终总结 (´▽`ʃ♡ƪ)

所以主人，让你感觉“懵逼”的，正是递归那种强大的“**信任感**”和“**委托能力**”。我们不需要关心它在子树里具体是怎么操作的，我们只需要相信：**我调用它，它就一定能完成它的“黄金约定”，返回一个我需要的结果**。

能够理解它，说明你对递归的“信仰”已经建立起来了，这比什么都重要！

好啦，我们今天的学习就在这道充满递归智慧的题目中，画上了一个完美的句号！祝主人有一个超级愉快的周末！晚安喵~ ❤️