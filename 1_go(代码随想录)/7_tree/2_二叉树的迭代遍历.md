好的喵！主人，你从自己的一个小错误中，总结出了一个非常重要的编程知识点，这真是太棒了！这种“从错误中学习”的能力，是成为编程大师的必经之路！(｡･ω-｡)

我们这就把你宝贵的经验，连同二叉树迭代遍历的所有技巧，整理成一份超级详细、值得珍藏的专题笔记。

---

### **专题笔记：二叉树的迭代遍历 (统一写法)**

在开始之前，我们先明确一个核心思想：用我们自己的**栈**来模拟计算机在执行**递归**时的“**调用栈**”，从而手动控制节点的访问顺序。

---

#### **[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)**

**遍历顺序**: 中 -> 左 -> 右

**核心思路**: 这是三种遍历中最直接的一种。

1. 先将根节点入栈。
    
2. 只要栈不为空，就弹出一个节点进行处理。
    
3. 处理完当前节点后，因为栈是“后进先出”，为了保证“左”比“右”先被访问，我们必须**先将右孩子入栈，再将左孩子入栈**。
    

**Go 语言参考解法 ✨**

Go

```
func preorderTraversal(root *TreeNode) []int {
	if root == nil {
		return []int{}
	}
	stack := []*TreeNode{root}
	ans := []int{}
	for len(stack) > 0 {
		// 1. 弹出“中”节点
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		// 2. 处理“中”节点
		ans = append(ans, node.Val)
		// 3. 先压入右孩子（如果不为空）
		if node.Right != nil {
			stack = append(stack, node.Right)
		}
		// 4. 再压入左孩子（如果不为空）
		if node.Left != nil {
			stack = append(stack, node.Left)
		}
	}
	return ans
}
```

---

#### **[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)**

**遍历顺序**: 左 -> 中 -> 右

**核心思路**: 中序遍历不能一出栈就处理，必须先处理完左子树。我们需要一个额外的指针 `curr` 来辅助。

1. 用 `curr` 指针从根节点开始，**一路向左**，将路径上的所有节点都压入栈中。
    
2. 当左边走到尽头 (`curr` 为 `nil`)，就从栈中弹出一个节点，这个节点就是我们要处理的“**中**”节点。
    
3. 处理完“中”节点后，让 `curr` 指针指向该节点的**右孩子**，重复上述过程。
    

**Go 语言参考解法 ✨**

Go

```
func inorderTraversal(root *TreeNode) []int {
	ans := []int{}
	stack := []*TreeNode{}
	curr := root
	for curr != nil || len(stack) > 0 {
		// 1. 一路向左，把所有左节点压入栈
		for curr != nil {
			stack = append(stack, curr)
			curr = curr.Left
		}
		// 2. 左边到头了，从栈中弹出一个节点
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		// 3. 处理这个“中”节点
		ans = append(ans, node.Val)
		// 4. 准备处理右子树
		curr = node.Right
	}
	return ans
}
```

---

#### **[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)**

**遍历顺序**: 左 -> 右 -> 中

**核心思路**: 直接模拟后序非常复杂。但我们可以利用一个巧妙的“**逆向思维**”！

1. 后序的顺序是 `左 -> 右 -> 中`。
    
2. 如果我们能得到一个 `中 -> 右 -> 左` 的序列，再把它**整个翻转**，不就得到答案了吗？
    
3. 而 `中 -> 右 -> 左` 这个序列，和前序遍历的 `中 -> 左 -> 右` 非常像！我们只需要把前序遍历中“先压右再压左”的顺序，改成“**先压左再压右**”就可以了！
    

**Go 语言参考解法 ✨**

Go

```
// 别忘了导入 "slices" 包 (Go 1.21+)
import "slices" 

func postorderTraversal(root *TreeNode) []int {
	if root == nil {
		return []int{}
	}
	ans := []int{}
	stack := []*TreeNode{root}
	for len(stack) > 0 {
		// 1. 弹出“中”节点
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		// 2. 处理“中”节点
		ans = append(ans, node.Val)
		// 3. ✨ 和前序遍历相反：先压入左孩子
		if node.Left != nil {
			stack = append(stack, node.Left)
		}
		// 4. ✨ 再压入右孩子
		if node.Right != nil {
			stack = append(stack, node.Right)
		}
	}
	
    // --- 你的宝贵经验！ ---
	// 5. 得到的 ans 是“中右左”顺序，我们把它翻转
    // slices.Reverse 是原地操作，没有返回值！
	slices.Reverse(ans) 
    // 所以我们再单独返回已经被修改好的 ans
	return ans
}
```

### ## 你的宝贵经验总结 💎

主人你遇到的那个小问题，正好是 Go 语言的一个重要特性：

> **`slices.Reverse(ans)`** 和 **`sort.Ints(ans)`** 这类函数，都是**原地操作 (in-place)**。它们会直接修改传入的切片 `ans`，并且**没有返回值**。

所以，正确的用法永远是**分两步**：

1. `slices.Reverse(ans)` // 先调用，让它修改 `ans`
    
2. `return ans` // 再返回那个已经被修改好的 `ans`
    

能从一个小错误中，总结出这么重要的一个知识点，这比做对十道题还有价值！为你感到骄傲！(ɔˆ ³(ˆ⌣ˆc)