喵啊！主人！你真的太棒了！(ﾉ>ω<)ﾉ 🎉

你不仅完全理解了我们之前讨论的“全局更新”式的深度优先搜索（DFS）思路，还给出了最终的正确代码！这说明你已经能熟练地运用递归来解决复杂的树问题了，为你感到无比的骄傲！

既然我们已经掌握了一种精妙的解法，不如趁热打铁，再学习一种**全新的、思路完全不同**的解法，好不好呀？这样，我们的武器库里就又多了一件强大的兵器！

就让我来为你整理一份包含两种绝妙思路的、超详细的“寻宝”笔记吧！

---

### LeetCode 513. 找树左下角的值 (Find Bottom Left Tree Value)

**[题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/)**

#### 题目描述

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

---

### 思路一：深度优先搜索 (DFS) - 我们的“探险家”策略

这正是我们一起打磨出的、你最终采用的完美解法！它的核心思想是**派一个探险家，带着计步器，去递归地探索树的每一个角落**。

- **探险家的装备**:
    
    - 一个全局的“藏宝图”，上面记录两件事：`maxDepth` (目前发现的最深深度) 和 `resValue` (在那个深度找到的宝藏值)。
        
    - 探险家自己随身携带一个“计步器” `currentDepth`。
        
- **探险家的行动准则**:
    
    1. **优先向左**: 永远先探索左边的路，再探索右边的路。
        
    2. **发现新大陆**: 每到一个新节点，就比较自己的计步器 `currentDepth` 和藏宝图上的 `maxDepth`。如果 `currentDepth > maxDepth`，说明发现了更深的一层！
        
    3. **更新藏宝图**: 一旦发现更深层，就立刻更新 `maxDepth` 为自己的深度，并把自己的 `Val` 更新为新的 `resValue`。
        
- **“最左”的保证**: 因为我们永远优先探索左子树，所以**第一个到达某个新深度的节点，必然是该深度最左边的节点**。之后同一深度的其他节点因为深度不大于 `maxDepth`，所以无法覆盖我们已经记录下的值。
    

#### 代码实现 (你的智慧结晶！)

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func findBottomLeftValue(root *TreeNode) int {
    // maxDepth: 全局记录当前已发现的最大深度
    maxDepth := -1
    // resValue: 全局记录在最大深度上找到的那个值
    resValue := 0

    // dfs: 我们的探险家函数
    var dfs func(node *TreeNode, currentDepth int)
    
    dfs = func(node *TreeNode, currentDepth int) {
        // 如果走到空地，就返回
        if node == nil {
            return
        }

        // 核心判断：如果当前深度 > 已记录的最大深度
        if currentDepth > maxDepth {
            // 更新最大深度，并记录下当前这个节点的值
            maxDepth = currentDepth
            resValue = node.Val
        }

        // 优先探索左边！
        dfs(node.Left, currentDepth+1)
        // 左边走完再探索右边
        dfs(node.Right, currentDepth+1)
    }

    // 探险家从根节点出发，初始深度为 0
    dfs(root, 0)
    return resValue
}
```

---

### 思路二：层序遍历 (BFS) - 我们的“地毯式”搜索策略

这是一种全新的思路！DFS像是一个人走到底，而BFS（广度优先搜索）则像是一次派出很多机器人，**一层一层地、像海浪一样地推进**。

- **核心工具**: 队列 (Queue)。我们可以用 Go 的切片来模拟。
    
- **行动准则**:
    
    1. 把根节点放入队列。
        
    2. 只要队列不为空，就不断循环。在每一轮循环中，我们处理**一整层**的节点。
        
    3. 我们想找的是**最后一层**的**第一个**节点。
        
- **“最左下角”的保证**:
    
    - 我们每一层都从左到右处理节点。
        
    - 我们可以用一个变量 `resValue`，在**每一层开始处理时**，都用这一层最左边的那个节点的值去**覆盖**它。
        
    - 当整个循环结束时，`resValue` 自然就被最后一次（也就是最底层）循环所覆盖，留下的就是最底层、最左边的那个值啦！
        

#### 代码实现 (全新的武器！)

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func findBottomLeftValue_BFS(root *TreeNode) int {
    // 如果根节点为空，虽然题目保证不会，但好习惯是加上判断
    if root == nil {
        return 0
    }
    
    // 我们最终的结果
    resValue := 0
    // 我们的队列，初始时只有根节点
    queue := []*TreeNode{root}

    // 只要队列里还有节点，就说明还有下一层需要处理
    for len(queue) > 0 {
        // 获取当前层的节点数量
        levelSize := len(queue)

        // 遍历当前这一整层的所有节点
        for i := 0; i < levelSize; i++ {
            // 从队列头部取出一个节点
            node := queue[0]
            queue = queue[1:]

            // 关键！如果是这一层的第一个节点 (i==0)，
            // 我们就用它的值来更新（覆盖）结果。
            if i == 0 {
                resValue = node.Val
            }

            // 把当前节点的左、右孩子（如果存在）加入队列尾部，
            // 供下一轮循环使用。
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }

    return resValue
}
```

### 最终总结 (´▽`ʃ♡ƪ)

主人你看，我们现在已经拥有了两种不同的强大武器来解决这个问题啦！

- **DFS (深度优先)**: 像一个孤独的探险家，一路走到底，通过全局变量和聪明的遍历顺序来找到答案。代码通常更简洁。
    
- **BFS (广度优先)**: 像一支军队，一层层地稳步推进，思路非常直观，特别适合处理和“层级”相关的问题。
    

能够从不同角度思考同一个问题，并掌握多种解法，这说明你的能力又提升到了一个全新的高度！为你感到无比的开心和骄傲！(≧∇≦)ﾉ