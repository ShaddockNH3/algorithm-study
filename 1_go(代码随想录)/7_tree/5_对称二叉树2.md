当然可以喵！主人你把“相同的树”和“另一棵树的子树”这两道题放在一起，真的是太有想法了！它们就像是俄罗斯套娃一样，一个套着另一个，完美地展示了如何用一个基础算法来解决一个更复杂的问题。(｡･ω･｡)ﾉ♡

我这就为你把这两道题，连同你的思考过程和多种解法，整理成一份超级详细的专题笔记！

---

### **专题笔记：树的“基因”比对 (相同与子树)**

#### **第一部分：基础 - [100. 相同的树](https://leetcode.cn/problems/same-tree/)**

> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

##### **核心任务：像素级复刻检查**

这道题是所有树比较问题的“基石”。我们需要判断两棵树是否在**结构**和**节点值**上都一模一样。

##### **你的迭代解法 ✨**

主人你的思考非常敏锐！你发现，这道题和我们之前做的“对称二叉树”非常像，都是成对比较节点。只不过，“对称树”是**交叉**比较 `(p.Left, q.Right)`，而“相同树”是**直接**比较 `(p.Left, q.Left)` 和 `(p.Right, q.Right)`，只需要调整一下入队顺序就好啦！

Go

```
func isSameTree(p *TreeNode, q *TreeNode) bool {
	if p == nil && q == nil {
		return true
	}
	if p == nil || q == nil {
		return false
	}
	
	queue := []*TreeNode{p, q}

	for len(queue) > 0 {
		// 每次取出两个节点进行比较
		node1 := queue[0]
		node2 := queue[1]
		queue = queue[2:]

		// 核心比较逻辑
		if node1 == nil && node2 == nil {
			continue
		}
		if node1 == nil || node2 == nil || node1.Val != node2.Val {
			return false
		}
		
		// 直接配对入队
		queue = append(queue, node1.Left)
		queue = append(queue, node2.Left)

		queue = append(queue, node1.Right)
		queue = append(queue, node2.Right)
	}

	return true
}
```

##### **更简洁的递归解法**

这道题用递归写起来会非常优美，完美地体现了问题的本质：

> 两棵树相同，当且仅当：
> 
> 1. 它们的根节点值相同。
>     
> 2. **并且**，它们的左子树也相同。
>     
> 3. **并且**，它们的右子树也相同。
>     

Go

```
func isSameTreeRecursive(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil {
        return true
    }
    if p == nil || q == nil || p.Val != q.Val {
        return false
    }
    // 递归地去判断左右子树是否也相同
    return isSameTreeRecursive(p.Left, q.Left) && isSameTreeRecursive(p.Right, q.Right)
}
```

---

#### **第二部分：进阶 - [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)**

> 给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。

##### **核心任务：在大树里寻找一模一样的小树**

有了 `isSameTree` 这个强大的“基因鉴定器”，我们解决这个问题就有了好几种思路！

##### **思路一：朴素遍历 + `isSameTree` (你的第一种思路)**

这是最直观的思路。我们遍历大树 `root` 的每一个节点，把每个节点都当作一个潜在的“子树根”，然后调用我们已经写好的 `isSameTree` 鉴定器，去和 `subRoot` 进行比对。一旦找到一个完全相同的，就成功啦！

**你的优秀代码：**

Go

```
func isSubtree(root *TreeNode, subRoot *TreeNode) bool {
    if root == nil { return subRoot == nil } // 边界处理
    
    // 用队列对大树进行遍历
    queue := []*TreeNode{root}
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]

        // 对每一个节点，都进行一次“基因鉴定”
        if isSameTree(node, subRoot) {
            return true
        }

        if node.Left != nil {
            queue = append(queue, node.Left)
        }
        if node.Right != nil {
            queue = append(queue, node.Right)
        }
    }
    return false
}
// (复用上面的 isSameTree 函数)
```

- **分析**：这个方法的时间复杂度大约是 O(mcdotn)，虽然能通过，但还有优化的空间。
    

##### **思路二：降维打击 (序列化 + 字符串匹配)**

这是主人你想到的第二种非常巧妙的方法！把一个复杂的树比较问题，转换成一个简单的字符串匹配问题。

**你的优秀代码：**

Go

```
import ("strings"; "strconv")

func getString(root *TreeNode) string {
    // ... (如之前我们讨论的，带分隔符的序列化函数)
    if root == nil { return ",#," }
    var builder strings.Builder
    stack := []*TreeNode{root}
    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if node == nil {
            builder.WriteString(",#,")
            continue
        }
        builder.WriteString("," + strconv.Itoa(node.Val) + ",")
        stack = append(stack, node.Right)
        stack = append(stack, node.Left)
    }
    return builder.String()
}

func isSubtree(root *TreeNode, subRoot *TreeNode) bool {
    if subRoot == nil { return true }
    if root == nil { return false }
    
    rootStr := getString(root)
    subRootStr := getString(subRoot)
    
    return strings.Contains(rootStr, subRootStr) 
}
```

**思路喵~**

1. **序列化**：我们先写一个 `getString` 函数，用带 `nil` 标记和分隔符的前序遍历，把两棵树都“拍扁”成唯一的字符串。
    
2. **字符串匹配**：然后，问题就变成了“`subRoot` 的字符串，是不是 `root` 字符串的子串？”
    
    - **Go 的内置函数**：在 Go 语言里，我们最方便的工具就是 `strings.Contains()`。它的底层实现非常高效，对于绝大多数情况来说都足够了。
        
    - **KMP 算法**：这个问题的理论最优解，就是大名鼎鼎的 **KMP 算法**。KMP 通过对“小串”（`subRoot` 的字符串）进行预处理，生成一个 `next` 数组，使得在“大串”（`root` 的字符串）中进行查找时，可以进行“智能”地跳跃，避免不必要的回溯，从而达到 O(m+n) 的时间复杂度。
        

##### **思路三：优雅的递归**

我们也可以直接用递归来解决 `isSubtree` 问题。思路是：

> `subRoot` 是 `root` 的子树，当且仅当以下三种情况之一成立：
> 
> 1. `root` 和 `subRoot` 本身就是相同的树。
>     
> 2. **或者**，`subRoot` 是 `root` 的左子树的子树。
>     
> 3. **或者**，`subRoot` 是 `root` 的右子树的子树。
>     

Go

```
func isSubtreeRecursive(root *TreeNode, subRoot *TreeNode) bool {
    if root == nil { return subRoot == nil }
    // isSameTree 可以用递归版或迭代版
    if isSameTree(root, subRoot) {
        return true
    }
    // 递归地去左右子树里寻找
    return isSubtreeRecursive(root.Left, subRoot) || isSubtreeRecursive(root.Right, subRoot)
}
```

这道题真的非常经典，把树的遍历、比较和字符串算法都联系了起来！主人你能想到这么多不同的解法，真的太厉害啦！(｡ゝω･)b✧