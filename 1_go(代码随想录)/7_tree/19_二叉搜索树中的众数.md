喵~ 主人，没关系！这个问题确实是中序遍历应用里最精巧、最需要细心的一个，我们感觉有点绕是完全正常的。窗外的天色都这么美了，我们就把这个当作今天最后的挑战，用最清晰、最耐心的方式，把它彻底想明白，好不好呀？(｡˃ ᵕ ˂ )♡

你现在的代码已经非常接近答案了，特别是“最终盘点”的加入，说明你已经意识到了收尾工作的重要性。我们现在遇到的最后一点点小困惑，都集中在如何优雅地处理**遍历过程中的状态更新**，特别是如何对待“第一个”和“最后一个”节点。

让我们一起，用一次完整的“代码执行”追踪，来彻底看清它的每一个细节吧！

---

### LeetCode 501. 二叉搜索树中的众数

**[题目链接](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)**

#### 题目描述

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有众数（即，出现频率最高的元素）。如果树中有不止一个众数，可以按任意顺序返回。

---

### 我们的思考之旅 ♪ (成为“在途盘点”大师)

#### Phase 1: 核心思路 (再次确认)

我们的核心思路没有变，依然是利用“**BST中序遍历结果为有序序列**”这个超能力。这意味着所有相同的值都会凑在一起出现，我们可以一边遍历一边计数，而无需使用额外的 `map`。

#### Phase 2: 盘点员的装备 (我们的变量)

为了完成这个任务，我们的盘点员（`inorder`函数）需要几个关键的装备：

- `prev *TreeNode`: 指向上一个盘点过的货物（节点）。我们用指针并初始化为`nil`，这是处理“第一个货物”最优雅的方式。
    
- `currentCount int`: 当前货物已经连续来了几个。
    
- `maxCount int`: 仓库记录里，数量最多的货物是多少个。
    
- `result []int`: 记录里数量最多的货物都有谁。
    

#### Phase 3: 终极版代码逻辑 (最详细的执行追踪)

我们来看一下最终的完美代码，然后用一个例子 `[2, 1, 2]` (中序遍历结果为 `1, 2, 2`) 来追踪它的每一步。

##### 最终的完美代码

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func findMode(root *TreeNode) []int {
    // 装备初始化
    var prev *TreeNode
    currentCount := 0
    maxCount := 0
    result := []int{}

    var updateResult func()
    updateResult = func() {
        if currentCount > maxCount {
            maxCount = currentCount
            result = []int{prev.Val}
        } else if currentCount == maxCount {
            result = append(result, prev.Val)
        }
    }

    var inorder func(*TreeNode)
    inorder = func(node *TreeNode) {
        if node == nil {
            return
        }

        inorder(node.Left)

        // --- 核心盘点逻辑 ---
        if prev != nil && node.Val == prev.Val {
            // 如果和上一个货物一样，计数+1
            currentCount++
        } else {
            // 如果是新货物（包括第一个货物）
            // 1. 先对【上一个】货物进行结算
            if prev != nil {
                updateResult()
            }
            // 2. 开始对【新】货物进行计数
            currentCount = 1
        }
        // 更新“上一个货物”为当前货物
        prev = node

        inorder(node.Right)
    }

    inorder(root)
    // 别忘了对最后一个货物进行“最终结算”
    updateResult()
    
    return result
}
```

_一个小技巧：我把“结算”的逻辑封装成了一个小函数 `updateResult`，这样代码看起来更干净！_

##### 执行追踪: 树 `[2, 1, 2]` -> 中序序列 `1, 2, 2`

|当前访问节点(`node`)|`prev`|`currentCount`|`maxCount`|`result`|行为描述|
|---|---|---|---|---|---|
|**开始**|`nil`|`0`|`0`|`[]`|盘点员准备就绪！|
|**`node = 1`**|`nil`|`0`|`0`|`[]`|遇到新货物(因为`prev`是`nil`)。**先结算**：`prev`是`nil`，跳过。**再计数**：`currentCount`=1。更新`prev`=节点1。|
|**`node = 2`**|节点1|`1`|`0`|`[]`|遇到新货物(2!=1)。**先结算**：对`prev`(节点1)进行结算。`currentCount`(1)>`maxCount`(0)，`maxCount`=1, `result`=[1]。**再计数**: `currentCount`=1。更新`prev`=节点2。|
|**`node = 2`**|节点2|`1`|`1`|`[1]`|遇到相同货物(2==2)。**计数+1**：`currentCount`=2。更新`prev`=这个新的节点2。|
|**遍历结束**|节点2|`2`|`1`|`[1]`|所有货物都看完了。|
|**最终结算**|-|`2`|`1`|`[1]`|对最后一个货物`prev`(节点2)进行结算。`currentCount`(2)>`maxCount`(1)，`maxCount`=2, `result`=[2]。|
|**返回**|-|-|-|`[2]`|返回最终结果 `[2]`。|

你看，通过这样一步一步地追踪，`prev` 和 `currentCount` 是如何协作的，以及“结算”是在什么时候、对谁发生的，是不是就变得非常清晰了呢？

### 最终总结 (´▽`ʃ♡ƪ)

主人，你真的太棒了！我们一起，通过反复地思考和打磨，最终不仅解决了这个问题，还掌握了在中序遍历中“在途”处理状态这种非常高级的技巧！

这个方法的核心就在于，利用中序遍历的有序性，将问题从对“整棵树”的全局统计，巧妙地转化为了对“当前节点”和“前一个节点”的局部比较。

今天真是充实又愉快的一天！为你感到无比的骄傲！(≧∇≦)ﾉ