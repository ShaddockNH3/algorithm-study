喵啊！主人！我们成功啦！(ﾉ>ω<)ﾉ 🎉

经过我们一次又一次的提示和修正，你最终把“路径总和”这道题的逻辑完全理顺了！从最开始有点迷路的探险家，到现在能清晰、准确地规划路线并找到宝藏，你付出的每一次思考都闪耀着光芒！

这绝对是一次含金量超高的学习过程！现在，就让我为你把这次胜利的果实，以及我们一路上学到的所有宝贵经验，都浓缩在这份超详细的最终笔记里吧！

---

### LeetCode 112. 路径总和 (Path Sum)

**[题目链接](https://leetcode.cn/problems/path-sum/)**

#### 题目描述

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

---

### 我们的思考之旅 ♪ (最终的完美路线！)

#### Phase 1: 探险策略 —— 回溯的力量

这道题非常适合使用“回溯”算法来解决。我们可以把它想象成一个探险家在二叉树迷宫里寻宝：

- **前进**: 每走到一个新的节点，就把这个节点的数值放进背包。
    
- **记录状态**: 背包里随时记录着当前路径的总和。
    
- **判断**: 到达一个路径的终点（叶子节点）时，检查背包里的总和是否等于目标值。
    
- **回溯**: 当一个方向走到头（或者其所有子路径都探索完毕）后，要退回到上一个节点，并把当初放进背包的东西拿出来，以保证状态正确，好去探索别的路径。
    

#### Phase 2: 探险家的装备 —— 变量与函数定义

根据我们的策略，我们需要一些装备：

1. `res bool`: 一个全局的旗帜，一旦找到宝藏，就把它立起来，通知所有人可以收工了。
    
2. `current_sum int`: 我们探险家的背包，用来累计当前路径的和。
    
3. `backtracking func(*TreeNode)`: 我们的探险家本人！它是一个递归函数，负责探索迷宫的每一个角落。
    

为了让探险家（递归函数）能够调用自己，我们使用了Go语言里一个非常重要的技巧：**先声明，再定义**。

Go

```
// 1. 先用 var 声明，相当于在探险家名册上登记
var backtracking func(*TreeNode, int)
// 2. 再用 = 赋值，详细描述探险家的能力和任务
backtracking = func(node *TreeNode, targetSum int) { ... }
```

这个技巧帮助我们解决了 `undefined: backtracking` 的语言问题，是重要的知识点哦！

#### Phase 3: 探险的详细步骤 (代码逻辑全解析)

这是我们最终打磨出的、最完美的探险流程！

1. 出发与终止 (递归的入口与出口)
    
    探险家每到达一个新地点 node，首先要判断：
    
    - 这个地方是不是空的 (`node == nil`)？或者别的探险家是不是已经找到了宝藏 (`res == true`)？
        
    - 只要满足任意一个条件，就没必要再探索了，直接返回。这是最高效的剪枝！
        
2. 前进与记录 (处理当前节点)
    
    如果可以继续探索，探险家就执行两个动作：
    
    - `current_sum += node.Val`: 把当前节点的宝物放进背包。
        
    - `path = append(path, node.Val)`: 在地图上画下这一步。（这一步对于最终结果不是必需的，但有助于我们理解路径）
        
3. 在终点检查宝藏 (判断叶子节点)
    
    这是最关键的“检查时刻”！
    
    - `if node.Left == nil && node.Right == nil && current_sum == targetSum`: **只有当**我们站的地方是一个**叶子节点**时，我们才检查背包里的总和。如果总和达标，立刻把 `res` 旗帜立起来！
        
4. 继续深入探索 (递归调用)
    
    无论当前是不是叶子节点，只要还没找到宝藏，探险家就要继续派小分队向下探索：
    
    - `backtracking(node.Left, targetSum)`
        
    - `backtracking(node.Right, targetSum)`
        
5. 安全退回 (回溯！)
    
    这是回溯算法的灵魂！ 当一个节点的所有子路径（左和右）都探索完毕后，探险家必须“安全地”从这个节点退回到上一层。为了保证退回后状态的正确性，必须执行：
    
    - `current_sum -= node.Val`: 把当前节点的宝物从背包里拿出去。
        
    - path = path[:len(path)-1]: 从地图上擦掉这一步。
        
        这个操作必须无条件执行，这样才能保证无论是探索兄弟路径，还是返回父节点，状态都是干净、正确的。
        

---

### 最终代码实现 (我们的胜利结晶！)

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func hasPathSum(root *TreeNode, targetSum int) bool {
    // res 旗帜，一旦为 true，所有探索都会尽快停止
    res := false
    // current_sum 背包，记录当前路径和
    current_sum := 0

    // 1. 先用 var 声明递归函数变量
    var backtracking func(*TreeNode)

    // 2. 再给变量赋值，定义函数体
    // (小优化：targetSum 作为外部变量，在闭包内可见，无需作为参数传递)
    backtracking = func(node *TreeNode) {
        // 高效的剪枝：如果节点为空或已找到答案，则无需继续
        if node == nil || res {
            return
        }

        // --- 前进 ---
        current_sum += node.Val

        // --- 在叶子节点处判断 ---
        if node.Left == nil && node.Right == nil && current_sum == targetSum {
            res = true
            // 注意：这里设置完 res=true 后，不能立刻 return，
            // 因为还需要执行函数末尾的回溯操作，以保证程序的优雅退出。
        }

        // --- 递归探索 ---
        backtracking(node.Left)
        backtracking(node.Right)

        // --- 回溯！---
        // 探索完一个节点的所有子路径后，必须“撤销”当前节点的影响
        current_sum -= node.Val
    }

    backtracking(root)
    return res
}
```

_一个小小的说明：在最终的代码里，`path` 变量被我拿掉了，因为题目只要求返回 `true/false`，记录具体的路径是不必要的，这样能让代码更聚焦于核心逻辑。_

### 最终总结 (´▽`ʃ♡ƪ)

太为你骄傲了，主人！我们一起经历了从思路混乱到逻辑清晰，从代码报错到完美运行的全过程。这不仅仅是解决了一道题，更是对**回溯算法**、**递归**以及**Go语言闭包**这些重要知识点的一次全面胜利！

你现在已经是一位合格的“二叉树探险家”啦！为你鼓掌！(≧∇≦)ﾉ