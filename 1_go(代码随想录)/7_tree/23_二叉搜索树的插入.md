喵~ 主人，夜深了呢，伴着窗外安静的街道，我们来为今天这场漫长而收获满满的二叉树学习之旅，画上一个最完美的句号吧！(｡˃ ᵕ ˂ )♡

你最终完成的这个“迭代”解法，思路清晰，逻辑严谨，就像一位熟练的园丁，准确地找到了挂上新果实的位置！在我们的共同努力下，你不仅克服了逻辑上的难点，还把Go语言的语法也用得非常熟练了！

我为你感到无比的骄傲！现在，就让我们把这份胜利的果实，连同另一种同样精妙的解法，一起记录在这份最终的笔记里吧！

---

### LeetCode 701. 二叉搜索树中的插入操作

**[题目链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)**

#### 题目描述

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

---

### 我们的思考之旅 ♪ (为BST添砖加瓦)

#### 方法一：迭代法 (你的“园丁”解法)

这个方法的思路非常直观，就像一位园丁，想在花园里的一棵大树上挂上一颗新果实。

- **核心思想**: 从树根出发，利用二叉搜索树的“有序”特性，一步步向下走，直到找到一个空的枝丫，然后把新果实挂上去。
    

**园丁的工作流程:**

1. **处理空树**: 如果花园一开始就是空的（`root == nil`），那新来的果实自己就成了花园里的第一棵树，直接返回这个新节点。
    
2. **寻找枝丫**:
    
    - 园丁（`tmp`指针）从树根开始往下走。
        
    - 他还需要一个“记忆工具”（`pre`指针），用来记住他刚刚走过的那一个分岔口（父节点）。这是因为当他最终找到空位时，需要回到上一个分岔口去挂果实。
        
    - 在每个分岔口，他都会比较新果实的值 `val` 和当前节点的值 `tmp.Val`：
        
        - 如果 `val` 更大，就往右走。
            
        - 如果 `val` 更小，就往左走。
            
3. **挂上果实**: 循环结束后，`tmp` 已经走到了空地（`nil`），而 `pre` 正好停留在那个需要挂果实的、最后的枝丫上。此时，再比较一次 `val` 和 `pre.Val` 的大小，就能确定是挂在左边还是右边了。
    

##### 你的完美迭代代码

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    // 1. 如果花园是空的，新果实自己就是树根
    if root == nil {
        return &TreeNode{Val: val}
    }

    // pre 是“记忆工具”，记住父节点；tmp 是“园丁”，负责探路
    var pre *TreeNode
    tmp := root

    // 2. 循环探路，直到找到一个空位（tmp == nil）
    for tmp != nil {
        // 记住来时的路
        pre = tmp
        // 根据BST的性质决定前进方向
        if tmp.Val < val {
            tmp = tmp.Right
        } else { // 题目保证 val 不重复
            tmp = tmp.Left
        }
    }

    // 3. 创造新果实
    newNode := &TreeNode{Val: val}

    // 4. 把新果实挂在正确的枝丫上
    if pre.Val < val {
        pre.Right = newNode
    } else {
        pre.Left = newNode
    }
    
    // 返回花园的入口（原树的根节点）
    return root
}
```

---

#### 方法二：递归法 (优雅的“委托”解法)

这是另一种非常常见、代码也更简洁的思路。它不像园丁那样亲自跑腿，而是像一位优雅的庄园主，通过“委托”的方式来完成任务。

- **核心思想**: 递归函数 `insertIntoBST(node, val)` 的“使命”是：将 `val` 插入到以 `node` 为根的树中，并**返回**插入后这棵树**新的根节点**。
    

**庄园主的工作流程:**

1. **处理空地 (递归的出口)**: 如果庄园主被告知要去一片空地（`node == nil`）上种树，他就凭空变出一棵只包含新果实的小树（`&TreeNode{Val: val}`），并把这棵小树作为成果**返回**。这里就是真正发生插入的地方。
    
2. **下达指令 (递归的深入)**: 如果当前土地不为空，庄园主会比较 `val` 和 `node.Val`：
    
    - 如果 `val` 更大，他知道新果实属于右边的花园。他便对他的“右管家”（`insertIntoBST(node.Right, val)`）下达指令：“去，把这个果实种到右花园里。种好之后，把**新的右花园**（可能是原来的，也可能是修改过的）交还给我。”
        
    - 他接收右管家返回的新右花园，并连接到自己的庄园上：`node.Right = ...`。
        
    - 如果 `val` 更小，则同理，委托给“左管家”。
        
3. **返回成果**: 指令下达并连接好之后，当前庄园的结构没有变化，庄园主把自己 (`node`) 返回给上级。
    

##### 优雅的递归代码

Go

```
func insertIntoBST_Recursive(root *TreeNode, val int) *TreeNode {
    // 1. 找到了空位，创建新节点并返回，这就是插入操作
    if root == nil {
        return &TreeNode{Val: val}
    }

    // 2. 根据 val 的大小，决定去哪个子庄园继续委托任务
    if val > root.Val {
        // 委托右管家，并接收他返回的新右花园
        root.Right = insertIntoBST_Recursive(root.Right, val)
    } else {
        // 委托左管家，并接收他返回的新左花园
        root.Left = insertIntoBST_Recursive(root.Left, val)
    }
    
    // 3. 将当前庄园的入口返回给上级
    return root
}
```

### 最终总结 (´▽`ʃ♡ƪ)

今天我们从白天到深夜，一起征服了DP、回溯和各种二叉树操作，你的进步是飞跃性的！

这最后一道题，你不仅独立思考出了清晰的迭代解法，还掌握了同样重要的递归解法。这两种方法，一个思路直观，一个代码优雅，都是我们武器库里不可或缺的宝剑！

真的辛苦啦，主人！快去好好休息吧！晚安喵~ ❤️