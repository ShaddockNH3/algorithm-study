喵~ 主人，新的一天，新的挑战！今天我们来学习一个非常有趣的魔法，可以把一棵普通的BST，变成一棵蕴含着“累加”力量的神奇大树！(｡˃ ᵕ ˂ )♡

你最终完成的这段代码，非常非常的漂亮！它正是解决这道题最经典、最高效、也是最符合Go语言习惯的写法。你不仅正确地运用了树的遍历，还巧妙地使用了“闭包”来解决状态共享的问题，太了不起了！

那么，就让我为你把这道题的完整思路，以及我们是如何从最初的小困惑，一步步走到这个完美解法的全过程，都详细地记录下来吧！

---

### LeetCode 538. 把二叉搜索树转换为累加树

**[题目链接](https://leetcode.cn/problems/convert-bst-to-greater-tree/)**

#### 题目描述

给出二叉 **搜索** 树的根节点，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

---

### 我们的思考之旅 ♪ (逆转的魔法)

#### Phase 1: 核心思路 —— “反过来”思考

这道题的题眼在于“**大于或等于**”这几个字。对于任意一个节点 `node`，它的新值是 `node.Val` 加上所有比 `node.Val` 更大的节点的值。

我们立刻就能想到BST的一个超能力：**中序遍历（左->根->右）可以得到一个升序序列**。

那我们反过来想，如果想要从大到小地访问节点，应该用什么顺序呢？

答案很简单：反向的中序遍历（右 -> 根 -> 左）！

一旦我们能按照从大到小的顺序访问节点，问题就迎刃而解了。我们可以维护一个“累加器” `sum`，在遍历的路上，不断地把当前节点的值累加进去，并用这个新的 `sum` 去更新当前节点的值。

#### Phase 2: 我们遇到的困惑 (值传递 vs 闭包)

在我们把这个绝妙的思路转化为代码时，遇到了一个关于 `sum` 变量如何传递的小问题。

##### 我们最初的错误尝试

我们一开始可能会尝试把 `sum` 作为一个参数传递给递归函数，就像这样：

Go

```
// 这是一个错误的例子哦！
func NInorder(root *TreeNode, sum int) {
    if root == nil { return }
    NInorder(root.Right, sum) // 传递的是 sum 的“复印件”
    sum += root.Val           // 修改的是“复印件”，外面的 sum 不会变
    root.Val = sum
    NInorder(root.Left, sum)  // 传递的还是那张旧的“复印件”
}
```

为什么这样不行？

我们遇到的困惑，是关于“魔法背包” sum 的传递方式。在Go的世界里，int 是值类型，每次把它作为参数传递，都像是在发复印件。右子树的探险家在复印件上写写画画，并不会影响到根节点手上那张原始的图纸。所以 sum 的累加效果无法在递归调用之间正确地传递。

#### Phase 3: 最终的完美解法 (为什么要写在函数里？)

为了解决“复印件”的问题，我们使用了Go语言里一个非常强大的魔法——**闭包 (Closure)**。这正是‘**为什么要写在函数里**’的答案！

> 通过把 `sum` 变量和 `NInorder` 辅助函数都定义在 `convertBST` 这个“大魔法阵”里，`NInorder` 就变成了一个“内部函数”。它天生就拥有了**直接访问和修改**外部 `sum` 变量的权力。

现在，所有递归调用 `NInorder` 的探险家，共享的都是**同一个、唯一的**“魔法背包” `sum`。一个探险家往里面放了东西，另一个探险家立刻就能看到。这样，累加的效果就能完美地贯穿整个遍历过程了！

---

### 你的最终完美代码

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func convertBST(root *TreeNode) *TreeNode {
    // 1. 在外部函数定义我们的“魔法背包”sum
    sum := 0
    
    // 2. 声明并定义一个“闭包”辅助函数
    var NInorder func(*TreeNode)
    NInorder = func(node *TreeNode) {
        // 递归的出口
        if node == nil {
            return
        }

        // --- 核心逻辑：反向中序遍历 ---
        
        // a. 先去右子树，把所有比当前节点大的值都处理完
        NInorder(node.Right)

        // b. 处理当前节点
        // 把当前节点的值，加入到共享的 sum 中
        sum += node.Val
        // 用累加后的 sum，更新当前节点的值
        node.Val = sum

        // c. 最后去左子树，处理比当前节点小的值
        NInorder(node.Left)
    }

    // 3. 启动递归
    NInorder(root)
    // 4. 返回被原地修改好的树
    return root
}
```

### 最终总结 (´▽`ʃ♡ƪ)

主人，你真的太棒了！这道题不仅让我们再次巩固了“中序遍历”这一神技，还让我们通过解决实际问题，深刻地理解了Go语言中“闭包”这一强大特性在递归场景下的妙用。

能够把算法思想和语言特性完美地结合起来，这说明你的内功又精进了一大步！为你感到无比的骄傲！(≧∇≦)ﾉ