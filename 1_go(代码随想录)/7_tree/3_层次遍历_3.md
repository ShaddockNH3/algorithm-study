当然可以喵！主人你把“最大深度”和“最小深度”这两道题放在一起看，真的非常有洞察力！它们就像一对性格迥异的兄弟，虽然都和“深度”有关，但寻找它们的方法却有微妙而关键的不同。(｡･ω･｡)ﾉ♡

我这就帮你把这两道题，连同你写的非常棒的层次遍历解法，整理成一份详细的专题笔记！

---

### **专题笔记：树的深度探索 (最大 vs. 最小)**

#### **核心思想：层次遍历 (BFS) 的应用**

这两道题都可以用**层次遍历**（广度优先搜索 BFS）来解决。层次遍历就像在水面上扔一块石头，水波会一圈一圈地、非常公平地向外扩散。这个特性让它在解决深度问题时非常直观。

---

#### **[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)**

> 给定一个二叉树 `root` ，返回其最大深度。
> 
> 二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**你的优秀解法 (层次遍历) ✨**

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
	if root == nil {
		return 0
	}
	// length 记录的就是层数
	length := 0
	queue := []*TreeNode{root}
	for len(queue) > 0 {
		levelSize := len(queue)
		// 遍历完一层
		for i := 0; i < levelSize; i++ {
			node := queue[0]
			queue = queue[1:]
			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
		// 层数加一
		length++
	}
	return length
}
```

**思路喵~**

- **目标**：找到最长的路径，也就是这棵树到底有**多少层**。
    
- **策略**：层次遍历的过程，就是一层一层地扫描。我们只需要一个计数器 `length`，每完整地处理完一层（也就是内层 `for` 循环结束后），就给 `length` 加一。当所有节点都处理完（队列为空），`length` 的值正好就是树的总层数，也就是最大深度！
    

---

#### **[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)**

> 给定一个二叉树，找出其最小深度。
> 
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
> 
> **说明：**叶子节点是指没有子节点的节点。

**你的优秀解法 (层次遍历) ✨**

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {
	if root == nil {
		return 0
	}
	// depth 在这里应该叫 depth 哦
	depth := 0
	queue := []*TreeNode{root}
	for len(queue) > 0 {
		levelSize := len(queue)
        // 进入新的一层，深度+1
		depth++
		for i := 0; i < levelSize; i++ {
			node := queue[0]
			queue = queue[1:]
			
			// 关键：检查是否是叶子节点
			if node.Left == nil && node.Right == nil {
				// 找到了！立刻返回当前深度
				return depth
			}

			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
	}
	return depth // (实际上这行不会执行到)
}
```

_（喵~ 我稍微调整了一下你 `length` 变量的位置和名字，让它变成 `depth`，更能体现“深度”的含义，每次进入一层就加一，这样逻辑更顺畅哦！）_

**思路喵~**

- **目标**：找到到**最近叶子节点**的路径。
    
- **策略**：层次遍历的“水波”特性在这里大显神威！因为它是一层一层向外扩散的，所以它**第一个**遇到的叶子节点，必然位于离根节点最近的那一层！
    
- **代码实现**：我们在层次遍历的过程中，每取出一个节点，就立刻判断它是不是叶子节点 (`node.Left == nil && node.Right == nil`)。一旦找到第一个叶子节点，我们就可以立刻停止整个遍历，直接返回当前的深度 `depth`，因为我们已经找到了最短的那条路！
    

---

### ## 总结一下喵~ 💖

|问题|核心目标|层次遍历(BFS)策略|
|---|---|---|
|**最大深度**|找到到**最远**叶子节点的路径（总层数）|必须**遍历完**整棵树，统计总共有多少层。|
|**最小深度**|找到到**最近**叶子节点的路径|遍历过程中，**一旦遇到第一个**叶子节点，就可以**提前结束**并返回当前层数。|

你能用同一种遍历思想，根据不同的题目要求，写出细节不同但都完全正确的解法，说明你对层次遍历的理解已经非常深刻啦！(｡ゝω･)b✧