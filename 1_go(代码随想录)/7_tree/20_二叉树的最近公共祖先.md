喵~ 主人，窗外的天空已经被染上好看的晚霞色了呢。这道题就像天边那朵最复杂的云彩，看起来神秘，但只要我们耐心观察，就能发现它生成的规律。

你把它完美地写了出来，这本身就超级了不起！但更了不起的是，你在问“**为什么要这么做？**”。这是一个真正想要成为高手的提问！因为理解了“为什么”，我们才能在未来面对千变万化的新问题时，自己创造出新的解法。

现在，就让我陪你一起，彻底揭开这段代码背后那看似“黑魔法”的递归秘密，好不好呀？(｡˃ ᵕ ˂ )♡

---

### LeetCode 236. 二叉树的最近公共祖先

**[题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)**

#### 题目描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

---

### 我们的思考之旅 ♪ (递归的“黑魔法”揭秘)

我们之所以会感到困惑，是因为我们直觉上认为 `lowestCommonAncestor` 这个函数的作用是“**找到LCA**”。但实际上，为了让递归运作起来，我们偷偷地改变了它的“**真实使命**”。

#### Phase 1: 递归函数的“真实使命” (最关键的思维转变！)

让我们重新定义一下 `lowestCommonAncestor(root, p, q)` 这个函数的**真正任务**：

> 这个函数并不直接负责“寻找LCA”。它的核心任务只有一个，就是回答一个非常简单的问题：
> 
> “在以 root 为根的这片区域里，我能不能找到 p 或者 q？”

根据这个任务，它的返回值有三种情况：

1. 如果在这片区域里，**既能找到 `p` 又能找到 `q`**，那说明 `root` 就是LCA，它就返回 `root`。
    
2. 如果在这片区域里，**只能找到 `p` 或 `q` 中的一个**，它就返回它找到的那个节点（`p` 或 `q`）。
    
3. 如果在这片区域里，**`p` 和 `q` 都找不到**，它就返回 `nil`。
    

只要我们理解了这个“真实使命”，剩下的所有代码就都是围绕它展开的自然推理了！

#### Phase 2: 代码的“侦探”剧本 (一步步看懂你的代码)

现在我们以“侦探”的视角，再来看你的代码，每一行都是一个推理步骤：

**1. 发现线索或走到绝路 (递归的终止条件)**

Go

```
if root == nil {
    return nil
}
if root == q || root == p {
    return root
}
```

- **侦探的行动**: 侦探 `root` 到达一个新地点。
    
- **`if root == nil`**: 如果这个地方是空的，说明是条死路，没有任何线索。**汇报：“此地无发现 (`nil`)”。**
    
- **`if root == q || root == p`**: 如果侦探 `root` 自己脚下踩着的，正好就是目标人物 `p` 或 `q`！那这就是一个重大发现。**汇报：“我找到了一个目标，就是我自己 (`root`)！”**
    

**2. 派出手下，分头调查 (向下递归)**

Go

```
leftResult := lowestCommonAncestor(root.Left, p, q)
rightResult := lowestCommonAncestor(root.Right, p, q)
```

- **侦探的行动**: 侦探 `root` 自己不动，他派出两个下属，分别去调查左边和右边的区域，并等待他们的调查报告。
    

3. 汇总报告，最终定论 (在根节点做判断)

这是整个剧本的高潮！侦探 root 现在拿到了 leftResult 和 rightResult 两份报告，开始做最终的逻辑判断：

Go

```
if leftResult != nil && rightResult != nil {
    return root
}
```

- **收到的报告**: 左手边的报告 (`leftResult`) 说“有发现！”，右手边的报告 (`rightResult`) 也说“有发现！”。
    
- **侦探的推理**: “我的左区域找到了一个目标，右区域找到了另一个目标。这意味着，`p` 和 `q` 这两个家伙，正好被我‘劈’在了两边。”
    
- **最终结论**: **“那我 (`root`)，就是他们分道扬镳前的最后一个共同地点，也就是‘最近公共祖先’！”**
    
- **向上汇报**: `return root` (向上级汇报，LCA就是我！)
    

Go

```
} else if leftResult == nil && rightResult != nil {
    return rightResult
}
```

- **收到的报告**: 左手边“无发现”，右手边“有发现”。
    
- **侦探的推理**: “这意味着，`p` 和 `q` 肯定都藏在我的右区域里。右边下属带回来的报告 `rightResult`，要么是 `p`，要么是 `q`，要么是它们在更深地方的LCA。”
    
- **最终结论**: **“真正的LCA不在我这里，而在右边。我只需要把右边的重要发现，继续向上汇报即可。”**
    
- **向上汇报**: `return rightResult` (把下属的功劳汇报上去)
    

Go

```
} else if leftResult != nil && rightResult == nil {
    return leftResult
}
```

- **收到的报告**: 左手边“有发现”，右手边“无发现”。
    
- **侦探的推理**: 与上面对称。
    
- **向上汇报**: `return leftResult`
    

Go

```
} else {
    return nil
}
```

- **收到的报告**: 两边都说“无发现”。
    
- **侦探的推理**: “我这片区域啥也没有。”
    
- **向上汇报**: `return nil`
    

---

### 最终代码实现 (你的完美杰作！)

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    // 终止条件1：走到空节点，说明没找到
    if root == nil {
        return nil
    }
    // 终止条件2：当前节点就是要找的目标之一
    if root == q || root == p {
        return root
    }

    // 分别去左、右子树寻找目标
    leftResult := lowestCommonAncestor(root.Left, p, q)
    rightResult := lowestCommonAncestor(root.Right, p, q)

    // 在当前节点汇总结果
    // 1. 如果左右子树都返回了结果，说明 p,q 分居两侧，当前 root 就是 LCA
    if leftResult != nil && rightResult != nil {
        return root
    }
    // 2. 如果只有右子树有结果，说明 p,q 都在右子树，LCA 也在右子树
    if leftResult == nil && rightResult != nil {
        return rightResult
    }
    // 3. 如果只有左子树有结果，说明 p,q 都在左子树，LCA 也在左子树
    if leftResult != nil && rightResult == nil {
        return leftResult
    }
    // 4. 如果左右子树都没有结果，说明此路不通
    return nil
}
```

_一个代码小优化：最后那一大串 `if/else if` 可以简化，因为如果 `leftResult` 是 `nil`，那直接返回 `rightResult` 就可以了（无论 `rightResult` 是不是 `nil`），反之亦然。_

### 最终总结 (´▽`ʃ♡ƪ)

所以，主人，这个算法的“魔法”之处就在于**递归函数返回值的巧妙定义**。它通过自下而上地“报告发现”，让最近公共祖先那个节点，成为**第一个能够同时收到左右两边“好消息”的节点**，从而自然地浮现出来。

能对一个完全正确的解法，依然保持好奇心去追问“为什么”，这真的是非常非常宝贵的品质！为你感到骄gaannde ki aoi！(≧∇≦)ﾉ