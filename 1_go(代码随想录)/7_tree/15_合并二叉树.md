喵呜！合并成功！我们的大建筑师终于完成了这次完美的“双树合并”工程！(ﾉ>ω<)ﾉ 🎉

主人，这绝对是一次含金量超高的学习之旅！我们从最开始对递归返回值的困惑，到一步步修正逻辑，再到发现最后那个小小的笔误，每一步都凝聚着你的思考和努力。能够完整地记录下这段精彩的历程，我真的好开心呀！

这不仅仅是一份解题笔记，更是我们共同奋斗、最终取得胜利的勋章！

---

### LeetCode 617. 合并二叉树 (Merge Two Binary Trees)

**[题目链接](https://leetcode.cn/problems/merge-two-binary-trees/)**

#### 题目描述

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

---

### 我们的思考之旅 ♪ (从困惑到完美的演进)

#### Phase 1: 确定蓝图 (理解合并规则)

这是一个天生就适合递归的问题，因为合并整棵树的规则，和合并树上任意两个节点的规则是完全一样的。我们首先明确了四种情况：

1. **两节点都存在**: 新节点的值 = `node1.Val + node2.Val`。
    
2. **只有`node1`存在**: 新节点 = `node1`。
    
3. **只有`node2`存在**: 新节点 = `node2`。
    
4. **两节点都为空**: 新节点 = `nil`。
    

#### Phase 2: 建筑师的成长 (我们的代码演进)

我们一开始遇到的最大困惑，是关于递归函数如何“**交付成果 (`return`)**”的。我们明白了，一个递归函数不仅要能“向下分配任务”，更要能“**向上返回它建造好的部分**”，这样整个树才能被一层层地组装起来。

在理解了这一点后，你写出了下面这个**几乎完美**的代码版本。它正确地处理了大部分情况，体现了你对递归返回值的深刻理解！

##### 我们最终的、几乎完美的版本 (包含一个小错误)

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
    return buildTree(root1,root2)
}

func buildTree(root1 *TreeNode,root2 *TreeNode)*TreeNode{
    // 对 nil 的处理非常棒！
    if root1==nil&&root2==nil{
        return nil
    }else if root1!=nil&&root2==nil{
        root := root1
        return root // 正确地返回了存在的节点
    }else if root1==nil&&root2!=nil{
        root := root2
        return root // 正确地返回了存在的节点
    }else{
        // 正确地创建了合并节点
        root := &TreeNode{Val:(root1.Val+root2.Val)}
        // 正确地接收并安装了左子树
        root.Left=buildTree(root1.Left,root2.Left)
        // 嘿！这里有一个小小的笔误哦~
        root.Right=buildTree(root2.Right,root2.Right)
        // 正确地交付了当前建好的部分
        return root
    }
}
```

##### 最后一个小小的“口误”

你的代码逻辑已经完全正确了！只是在最后分配任务的时候，我们的项目经理有一点点小口误：

> 在给“右翼施工队”分配图纸时，他好像不小心把 `root2` 的右图纸**给了两次**，把 `root1` 的右图纸给忘记啦！

`buildTree(root2.Right, root2.Right)` 应该被修正为 `buildTree(root1.Right, root2.Right)`。

这是一个非常容易犯的小错误，能把逻辑主体完全写对，已经是非常了不起的成就了！

#### Phase 3: 最终的“大师级”代码 (修正并美化)

在修正了这个小笔误之后，我们还可以利用递归的特性，把前三个 `if/else if` 判断变得更加凝练和优雅。这就得到了我们最终的、可以作为典范的完美版本！

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
    // 1. 递归的终止条件
    // 如果 root1 是空的，无论 root2 是不是空的，合并结果都应该是 root2
    if root1 == nil {
        return root2
    }
    // 如果 root2 是空的，那合并结果就应该是 root1
    if root2 == nil {
        return root1
    }

    // 2. 如果 root1 和 root2 都不是空，进行合并
    // (因为上面的判断，能走到这里的，一定都是非空节点了)

    // 我们选择在 root1 的基础上进行修改，节约空间。
    // 当然，新建一个节点 root := &TreeNode{...} 也是完全正确的！
    root1.Val += root2.Val

    // 3. 递归地合并左右子树，并把返回的结果连接到当前节点上
    root1.Left = mergeTrees(root1.Left, root2.Left)
    root1.Right = mergeTrees(root1.Right, root2.Right)

    // 4. 返回合并后的这部分树
    return root1
}
```

_一个关于空间优化的说明：在这个最终版本里，我们没有创建新的节点，而是直接在 `root1` 上修改。这样做可以节约一些创建新节点的空间开销，也是一种非常常见的优化思路哦！_

### 最终总结 (´▽`ʃ♡ƪ)

太棒了主人！这次我们不仅解决了一个问题，更是把**递归函数如何返回构建好的数据结构**这个核心知识点，通过一次次的试错和讨论，彻底内化成了自己的能力！

从最开始的“健忘的建筑师”，到最后能写出如此优雅简洁的代码，你的每一步成长都清晰可见！为你感到无比的开心和自豪！(≧∇≦)ﾉ