喵~ 主人，你拿出的这份“递归三要素”笔记，简直就是攻克递归算法的“武功秘籍”呀！(ﾉ´ヮ`)ﾉ*:･ﾟ✧

你说的太对了，很多时候我们写递归，感觉就像是在“凭感觉画符”，不知道能不能成功。但有了“三要素”这个清晰的方法论，我们就能像专业的工程师一样，一步步搭建出逻辑严密、绝对正确的递归代码！

我们这就用这本“秘籍”，把二叉树的前、中、后序遍历这三道经典题目彻底拿下，让你以后再写递归时，心中有尺，下笔有神！

---

### **递归三部曲：用“三要素”法征服二叉树遍历 🎶**

在开始之前，我们先复习一下我们的“武功秘籍”——**递归三要素**：

1. **确定递归函数的参数和返回值**
    
2. **确定终止条件 (Base Case)**
    
3. **确定单层递归的逻辑**
    

好，秘籍在手，我们出发！

---

#### **[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)**

##### **递归三要素分析 🧐**

1. **确定递归函数的参数和返回值**
    
    - **参数**：我们要遍历整棵树，所以必须传入当前的节点 `node *TreeNode`。为了收集遍历的结果，我们还需要传入一个容器来存放答案。在 Go 中，为了高效地修改这个容器，我们传入它的指针 `result *[]int`。
        
    - **返回值**：因为我们是直接修改传入的 `result` 切片，所以递归函数本身不需要返回任何东西，返回类型是 `void` (在 Go 中就是不写返回值)。
        
2. **确定终止条件**
    
    - 当我们的“探索”走到了树叶的尽头，也就是遇到了一个空节点 `node == nil` 时，说明这条路已经到头了，递归就应该停止并返回。
        
3. **确定单层递归的逻辑**
    
    - 前序遍历的顺序是 **中 -> 左 -> 右**。
        
    - 所以，对于当前这一层，我们的任务就是严格按照这个顺序执行：
        
        - **中**：先把当前 `node` 的值加入结果集。
            
        - **左**：然后，调用自己，去处理左子树。
            
        - **右**：最后，再调用自己，去处理右子树。
            

##### **Go 完整参考解法 ✨**

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func preorderTraversal(root *TreeNode) []int {
    // 初始化结果集
    result := []int{}
    // 调用递归辅助函数，注意传入 result 的地址
    traversal(root, &result)
    return result
}

// 递归辅助函数
func traversal(node *TreeNode, result *[]int) {
    // 2. 终止条件
    if node == nil {
        return
    }
    
    // 3. 单层递归逻辑 (中 -> 左 -> 右)
    *result = append(*result, node.Val) // 中
    traversal(node.Left, result)      // 左
    traversal(node.Right, result)     // 右
}
```

---

#### **[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)**

##### **递归三要素分析 🧐**

1. **确定递归函数的参数和返回值**
    
    - (和前序遍历完全一样) 参数是 `node *TreeNode` 和 `result *[]int`，无返回值。
        
2. **确定终止条件**
    
    - (和前序遍历完全一样) `if node == nil { return }`。
        
3. **确定单层递归的逻辑**
    
    - 中序遍历的顺序是 **左 -> 中 -> 右**。
        
    - 我们只需要调整单层逻辑的执行顺序即可！
        
        - **左**：先调用自己，处理左子树。
            
        - **中**：再把当前 `node` 的值加入结果集。
            
        - **右**：最后调用自己，处理右子树。
            

##### **Go 完整参考解法 ✨**

Go

```
func inorderTraversal(root *TreeNode) []int {
    result := []int{}
    traversal(root, &result)
    return result
}

func traversal(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    
    // 单层递归逻辑 (左 -> 中 -> 右)
    traversal(node.Left, result)       // 左
    *result = append(*result, node.Val) // 中
    traversal(node.Right, result)      // 右
}
```

---

#### **[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)**

##### **递归三要素分析 🧐**

1. **确定递归函数的参数和返回值**
    
    - (和前序遍历完全一样) 参数是 `node *TreeNode` 和 `result *[]int`，无返回值。
        
2. **确定终止条件**
    
    - (和前序遍历完全一样) `if node == nil { return }`。
        
3. **确定单层递归的逻辑**
    
    - 后序遍历的顺序是 **左 -> 右 -> 中**。
        
    - 我们再次调整单层逻辑的执行顺序：
        
        - **左**：先调用自己，处理左子树。
            
        - **右**：再调用自己，处理右子树。
            
        - **中**：最后才把当前 `node` 的值加入结果集。
            

##### **Go 完整参考解法 ✨**

Go

```
func postorderTraversal(root *TreeNode) []int {
    result := []int{}
    traversal(root, &result)
    return result
}

func traversal(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    
    // 单层递归逻辑 (左 -> 右 -> 中)
    traversal(node.Left, result)      // 左
    traversal(node.Right, result)     // 右
    *result = append(*result, node.Val) // 中
}
```

你看，一旦我们掌握了“递归三要素”这个方法论，这三道题就变成了“排列组合”一样简单！我们只需要定义好一次函数，想清楚一次终止条件，然后根据不同的遍历要求，调整那三行核心代码的顺序就好啦！

这就是方法论的力量！(｡ゝω･)b✧