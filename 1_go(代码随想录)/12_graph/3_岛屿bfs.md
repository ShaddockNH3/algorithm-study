# 小猫咪的算法探险大宝典 🗺️

> “从深度到广度，我们已经征服了整片算法的海洋喵~”

### 我们用BFS取得的胜利 ✨

首先，让我们为你这份逻辑清晰、完美无瑕的 BFS 代码献上掌声！它就像一个训练有素的探险队，稳扎稳打地完成了任务。

**你的完整代码：**

```
package main

import (
	"fmt"
)

var dir = [][]int{
	{0, 1}, {1, 0}, {-1, 0}, {0, -1},
}

func solve() {
	var n, m int
	fmt.Scanln(&n, &m)

	graph := make([][]int, n)
	visit := make([][]bool, n)

	for i := 0; i < n; i++ {
		graph[i] = make([]int, m)
		visit[i] = make([]bool, m)
	}

	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			fmt.Scan(&graph[i][j])
		}
	}

	result := 0

	// 定义稳重的“广搜探险队”
	var bfs func(x, y int)
	bfs = func(x, y int) {
		// 准备一个“排队区”
		queue := [][]int{}

		// 初始点进入排队区
		queue = append(queue, []int{x, y})

		// 只要排队区还有人，就继续探索
		for len(queue) > 0 {
			// 请队头的人出来
			cur := queue[0]
			queue = queue[1:]

			// 获取队头坐标
			currx := cur[0]
			curry := cur[1]

			// 探索它的四周
			for i := 0; i < 4; i++ {
				nextx := currx + dir[i][0]
				nexty := curry + dir[i][1]
				
				// 判断是否可以走
				if nextx < 0 || nextx >= n || nexty < 0 || nexty >= m {
					continue
				}
				if !visit[nextx][nexty] && graph[nextx][nexty] == 1 {
					// 如果可以，就让新发现的坐标去队尾排队，并打卡
					queue = append(queue, []int{nextx, nexty})
					visit[nextx][nexty] = true
				}
			}
		}
	}

	// 总指挥开始巡视地图
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			// 发现一个全新的、未被标记的岛屿部分
			if !visit[i][j] && graph[i][j] == 1 {
				// 必须先打卡，再派出探险队！
				// (如果先派出探险队再打卡，初始点会被重复加入队列)
		        visit[i][j] = true
				result++
				bfs(i, j)
			}
		}
	}

	fmt.Println(result)
}

func main() {
	solve()
}
```

### 探险策略大比拼：深搜、广搜、回溯与层次遍历

主人问得特别好：这些听起来很像的概念，在代码里到底有什么区别呢？我们来一次终极对比！

我们可以把它们分成两大阵营：**“一条路走到黑”的深搜家族** 和 **“稳扎稳打”的广搜家族**。

#### 👨‍👩‍👧‍👦 **深搜家族：DFS & 回溯法**

- **关系**：**回溯法**是一种解决问题的**思想框架**，而**深度优先搜索(DFS)是实现这个框架的核心动作**。回溯 = DFS前进 + 状态重置后退。
    
- **核心工具**：**递归** (背后是隐形的**函数调用栈**)。
    
- **代码特征**：通常代码更**简洁**，因为最复杂的“记忆”工作由系统帮我们做了。
    

**“岛屿数量”的DFS版本代码对比：**

```
var dfs func(x,y int)
dfs = func(x,y int){
    // ...边界和条件判断...
    if !visit[nextx][nexty] && graph[nextx][nexty] == 1 {
        visit[nextx][nexty] = true
        // 【区别点！】直接让函数调用自己，像探险家一头扎进去
        dfs(nextx, nexty) 
    }
}
```

**关键区别**：`dfs` 直接调用 `dfs`，这是典型的递归。它把“下一步该去哪”这个问题，直接又抛给了下一个自己，形成了一个调用链，自然而然地实现了“深度”探索。

#### 👨‍👩‍👧‍👦 **广搜家族：BFS & 层次遍历**

- **关系**：**层次遍历**是广度优先搜索(BFS)在**树结构**上的一种特殊应用。它们的核心思想和实现方式**完全一样**。
    
- **核心工具**：**队列 (Queue)**。
    
- **代码特征**：代码通常**步骤更清晰**，但需要我们**手动**创建和管理一个队列来“记忆”待办事项。
    

**“岛屿数量”的BFS版本代码对比：**

```
var bfs func(x, y int)
bfs = func(x, y int) {
    // 【区别点！】自己手动创建一个“排队区”
    queue := [][]int{}
    queue = append(queue, []int{x, y})

    for len(queue) > 0 {
        // 【区别点！】手动管理出队
        cur := queue[0]
        queue = queue[1:]
        
        // ...
        if !visit[nextx][nexty] && graph[nextx][nexty] == 1 {
            // 【区别点！】手动管理入队，把新任务放到队尾
            queue = append(queue, []int{nextx, nexty})
            visit[nextx][nexty] = true
        }
    }
}
```

**关键区别**：我们没有用递归，而是用一个 `for` 循环和一个我们自己维护的 `queue`。所有新发现的节点都被“公平地”安排到队尾，等待轮到自己时才会被探索，这就实现了“广度”或“层次”的探索。

### 终极总结表 喵~ (ฅ'ω'ฅ)

|特性|深搜家族 (DFS / 回溯)|广搜家族 (BFS / 层次遍历)|
|---|---|---|
|**核心思想**|一条路走到黑，不撞南墙不回头|稳扎稳打，一层一层向外探索|
|**核心数据结构**|**栈 (Stack)** (由递归隐式实现)|**队列 (Queue)** (需手动创建和维护)|
|**代码风格**|简洁、优雅，但有时难以调试|步骤明确，但代码量相对较多|
|**性格比喻**|执着勇敢、一头扎到底的**探险家**|公平稳重、地毯式搜索的**指挥官**|
|**擅长解决**|找出**所有解**、排列组合、迷宫路径|**最短路径**（无权图）、层序问题|

主人现在是不是感觉豁然开朗啦？从“岛屿数量”到“所有路径”，我们一起用这两种核心的探险策略解决了很多问题。能够理解它们的内在区别和不同应用场景，是算法探险之路上一个非常非常重要的里程碑！

为你感到无比的骄傲和开心！我们已经是经验丰富的探险家啦！♪(^∇^*)