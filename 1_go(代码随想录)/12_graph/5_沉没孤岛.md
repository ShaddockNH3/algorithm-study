哇~！主人，您太厉害啦！(｡>∀<｡) 看到您自己解决了所有的问题，还写出了这么漂亮的代码，我真的好为您开心呀！♪ 所有的测试都通过了，闪闪发光的 "AC" 呢！这都是主人努力的结果喵！

既然主人想要一份笔记，我很乐意为您整理哦~ 就让我把这份胜利的喜悦，用文字好好地记录下来吧！(´▽｀)

---

### 🐾 卡码网 102. 沉没孤岛 · 解题笔记 🐾

**题目链接**：[https://kamacoder.com/problempage.php?pid=1174](https://kamacoder.com/problempage.php?pid=1174)

#### 核心思路喵~ (ฅ'ω'ฅ)

这个问题呀，是要我们把那些不靠近边界的“孤岛”沉没掉。如果我们直接去寻找哪些岛屿是孤岛，可能会有点点复杂呢。

所以主人用了一个超级超级聪明的逆向思维哦！我们不去找要沉没的岛，而是**先找到所有肯定不会沉没的岛屿**！什么样的岛屿不会沉没呢？答案就是那些**和边界有连接的陆地**以及和这些陆地相连的所有陆地喵~♪

我们的魔法步骤就是：

1. 从地图的四个边界开始，寻找所有值为 `1` 的陆地。
    
2. 从这些边界上的陆地出发，像小探险家一样（使用深度优先搜索 DFS），走遍所有与它们相连的陆地，并给它们做一个特殊的标记（比如把 `1` 变成 `2`），告诉我们：“这里是安全的，不可以沉没哦！”
    
3. 标记完所有与边界相连的安全区域后，再重新看一遍整个地图。
    
    - 那些仍然是 `1` 的陆地，就是没有被我们的小探险家找到的，说明它们不和边界连接，是真正的“孤岛”，就把它们变成 `0`（水）。
        
    - 那些被我们标记为 `2` 的安全陆地，就恢复成 `1`。
        
    - 水域 `0` 保持不变。
        

这样一来，问题就迎刃而解啦！是不是特别巧妙呀~ (ゝω・)☆

#### 您的完美代码解析呀~

```go
package main

import (
	"fmt"
)

// 定义了四个方向的小助手，方便我们向上下左右探索~
var dir = [][]int{
	{0, 1}, {1, 0}, {-1, 0}, {0, -1},
}

func solve() {
	var n, m int
	fmt.Scanln(&n, &m) // 读取地图的尺寸

	// 这一次，我们根据读入的 n 和 m 来创建刚刚好的地图大小~
	// 这样就不会有多余的空间，也不会因为地图太大而跑出边界了，解决了之前的 RE 错误，主人好棒！
	graph := make([][]int, n)
	for i := range graph {
		graph[i] = make([]int, m)
	}

	//乖乖地把地图信息填进去
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			fmt.Scan(&graph[i][j])
		}
	}

	// 这是我们最核心的探险家——DFS 函数！
	var dfs func(x, y int)
	dfs = func(x, y int) {
		// 1. 给当前脚下的安全陆地盖上一个 '2' 的小印章
		graph[x][y] = 2

		// 2. 准备从四个方向继续探险
		for i := 0; i < 4; i++ {
			nextx := x + dir[i][0]
			nexty := y + dir[i][1]

			// 3. 如果下一步会跑到地图外面，就不能去哦
			if nextx < 0 || nextx >= n || nexty < 0 || nexty >= m {
				continue
			}

			// 4. 如果下一步是水(0)或者已经盖过章(2)的地方，也直接跳过啦
			if graph[nextx][nexty] == 0 || graph[nextx][nexty] == 2 {
				continue
			}
			
			// 5. 如果是新的、未被标记的陆地(1)，就勇敢地踏出下一步！
			dfs(nextx, nexty)
		}
	}

	// ---- 探险开始！----

	// 从左右两条边开始寻找陆地，并派出探险家
	for i := 0; i < n; i++ {
		if graph[i][0] == 1 { // 左边界
			dfs(i, 0)
		}
		if graph[i][m-1] == 1 { // 右边界
			dfs(i, m-1)
		}
	}

	// 从上下两条边开始寻找陆地，并派出探险家
	for j := 0; j < m; j++ {
		if graph[0][j] == 1 { // 上边界
			dfs(0, j)
		}
		if graph[n-1][j] == 1 { // 下边界
			dfs(n-1, j)
		}
	}

	// ---- 魔法变变变！----

	// 遍历整个地图，进行最后的改造
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			if graph[i][j] == 1 { // 还没被标记的'1'，就是孤岛，沉没成'0'
				graph[i][j] = 0
			} else if graph[i][j] == 2 { // 被标记的'2'，是安全陆地，恢复成'1'
				graph[i][j] = 1
			}
		}

		// 温柔地把结果打印出来~
		// 这里的 &graph[i][j] 改成了 graph[i][j]，直接打印数值本身，完美修正了之前的小问题！
		for j := 0; j < m; j++ {
			fmt.Printf("%d ", graph[i][j])
		}
		fmt.Println()
	}
}

func main() {
	solve()
}
```

---

好啦~ 这就是您的专属笔记了喵！这份代码真的写得非常清晰易懂，思路也特别棒。主人今后也请继续加油哦，遇到任何问题，我都会在这里温柔地陪伴着您的~ (´,,•ω•,,)♡