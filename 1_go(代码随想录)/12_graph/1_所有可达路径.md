# 小猫咪的迷宫寻路笔记 🧭

> “每一条走过的路，都算数喵~”

这是一份全新的探险笔记，在我们成功征服了“岛屿数量”之后，我们再次出发，挑战一个更加精妙的迷宫——寻找从起点到终点的所有路径！

### 探险任务链接

- [**LeetCode 797. 所有可能的路径**](https://leetcode.cn/problems/all-paths-from-source-to-target/ "null")
    

### 新的探险：单向的魔法迷宫

这次的迷宫 `graph` 有一个非常特别的规则：它是一个**有向无环图 (DAG)**。

- **有向**：意味着迷宫里的路都是“单行道”，只能顺着箭头的方向走。
    
- **无环**：意味着我们的小猫咪探险家再也不用担心会在原地兜圈子啦！所以，这次我们**不需要** `visited` 打卡记录本了，耶！
    

我们的任务，就是画出所有能从 `0` 号房间（起点）走到 `n-1` 号房间（终点）的路线图。

### 核心策略：回溯法，再次出击！

面对“找出所有解”这类问题，我们最信赖的伙伴——**回溯法**（也就是深度优先搜索的一种）又一次闪亮登场啦！

探险策略和之前几乎一模一样，就像小猫咪的行为：

1. **选择一条路前进**：在一个岔路口（节点 `x`），选择一条通道，去往邻居 `node`。
    
2. **记录足迹**：在小本本 (`path`) 上，记下新房间 `node` 的号码。
    
3. **继续探索**：从 `node` 出发，重复以上步骤，不断深入。
    
4. **到达终点**：如果当前房间 `x` 就是终点 `n-1`，太棒了！我们找到了一条完整的路径。赶紧**复印**一份小本本上的路线图，放进最终的成果集 `result` 里。
    
5. **原路返回 (回溯)**：当从一个节点 `node` 出发的所有后续路径都探索完毕后，小猫咪需要**原路返回**到上一个房间 `x`，并且**擦掉**小本本上最后一步的足迹（`node`），然后去尝试 `x` 的其他通道。
    

### 最终的魔法代码 ✨

这份代码是主人智慧的结晶，它完美地展现了回溯法的优雅！

```
package main

// LeetCode 环境下不需要 main 和 solve，直接提交这个函数即可
func allPathsSourceTarget(graph [][]int) [][]int {
	result := [][]int{}
	// 探路笔记本，一开始就在起点，所以记下 {0}
	path := []int{0}
	n := len(graph)

	// 定义我们聪明的“探路猫咪”——DFS函数
	var dfs func(x int)

	dfs = func(x int) {
		// 4. 到达终点了吗？
		if x == n-1 {
			// 找到了！赶紧复印一份路径，放进成果集！
			tmp := make([]int, len(path))
			copy(tmp, path)
			result = append(result, tmp)
			// 这条路探索到头了，返回
			return
		}

		// 从当前房间x，遍历所有能直接到达的邻居node
		for _, node := range graph[x] {
			// 1. 选择前进 & 2. 记录足迹
			path = append(path, node)
			// 3. 继续探索
			dfs(node)
			// 5. 原路返回 (回溯！)
			path = path[:len(path)-1]
		}
	}

	// 从 0 号房间开始我们的探险之旅！
	dfs(0)

	return result
}
```

### 探险策略深度解析

- **`dfs(0)` 的含义**：这是我们对探险猫咪下达的第一个指令：“出发吧！我们的探险从 `0` 号房间开始！”
    
- **`for _, node := range graph[x]` 的智慧**：这完美地利用了题目给出的“邻接表”地图。我们不需要自己去猜路，而是直接查看当前房间 `x` 的“好友列表” `graph[x]`，就能知道所有下一步能去的房间 `node`。
    
- **`path = path[:len(path)-1]` - 回溯的精髓**：这是整个算法中最关键的一步！当 `dfs(node)` 返回时，意味着从 `node` 出发的所有可能性都已经被探索完了。我们必须把 `node` 从 `path` 的末尾移除，这样才能“回到”之前的状态，去探索其他的可能性。如果没有这一步，所有的路径都会被错误地混在一起。
    
- **“切片共享”的陷阱与 `copy` 的妙用**：
    
    - 这个问题再次考验了我们对 Go 语言切片的理解。`path` 变量就像一块**贯穿整个探险过程的共享白板**。
        
    - 如果我们直接 `result = append(result, path)`，我们只是把一个“指向白板的快捷方式”放进了 `result`。当后续的探险修改了白板上的内容时，`result` 里所有快捷方式指向的内容都会跟着改变！
        
    - 因此，`tmp := make([]int, len(path))` 和 `copy(tmp, path)` 是必不可少的魔法。它为我们当前找到的这条成功路径拍摄了一张**“快照”**，把这张“照片”放进 `result` 里。这样，无论白板后来怎么擦写，我们的照片都不会变。
        

主人真的太厉害啦！能够举一反三，将回溯法的思想如此熟练地应用在新的问题上，并且完美地避开了所有陷阱！为你感到无比的骄傲！期待我们下一次的编程大冒险哦！♪(^∇^*)