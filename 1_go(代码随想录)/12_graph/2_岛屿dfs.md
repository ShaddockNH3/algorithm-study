# 小猫咪的岛屿探险笔记 🐾

> “每一次修正，都是通往完美的又一步喵~”

这是一份特别的笔记，记录了我们如何一步步帮助“探险猫咪”学会探索二维世界，并成功计算出所有岛屿数量的奇妙旅程。

### 探险任务链接

- [**卡码网 99. 岛屿数量**](https://kamacoder.com/problempage.php?pid=1171 "null")
    

### 我们的探险日记：与 Bug 小精灵的斗智斗勇

在这次探险中，我们遇到了一些非常狡猾的 Bug 小精灵，但最终都被我们用智慧和耐心一一击败啦！

1. **指南针的混乱 (`dir` 数组的用法)**
    
    - **最初的失误**：我们一开始尝试用 `dir[0][i]` 和 `dir[1][i]` 来获取方向，这就像是把指南针竖着看，完全搞错了方向。
        
    - **修正**：我们很快就意识到，`dir[i]` 代表一个完整的方向（如 `{0, 1}`），而 `dir[i][0]` 和 `dir[i][1]` 分别是这个方向上 `x` 和 `y` 的变化。这是我们修正的第一个关键点！
        
2. **健忘的探险家 (`dfs` 函数的作用域)**
    
    - **遇到的问题**：`dfs` 函数一开始在 `solve` 函数外面，它不认识地图的边界 `n` 和 `m`，就像一个没有地图的探险家，很容易迷路。
        
    - **聪明的解决方案**：我们把它定义成了 `solve` 内部的一个匿名函数（闭包）。这样一来，`dfs` 就像是 `solve` 的专属小助手，可以很自然地使用 `n`, `m`, `visit` 和 `graph` 这些变量，超级方便！
        
3. **颠倒的地图 (`n` 和 `m` 的边界判断)**
    
    - **一个小陷阱**：在判断坐标是否越界时，我们不小心把行（`n`）和列（`m`）的边界弄反了。`x` 坐标对应的是行数 `n`，`y` 坐标对应的是列数 `m`，这是一个非常容易犯的小错误。
        
    - **细心的修正**：我们仔细检查了地图的尺寸，将判断条件 `nextx>=m` 和 `nexty>=n` 修正为了正确的 `nextx>=n` 和 `nexty>=m`。
        
4. **混乱的行动手册 (`for` 循环的逻辑)**
    
    - **最关键的失误**：我们最初把对新坐标的判断（是否越界、是否已访问）放在了 `for` 循环的**外面**。这导致探险家一次性“想”完四个方向，却只对最后一个方向采取行动，完全打乱了“探索-判断-再探索”的节奏。
        
    - **逻辑的重塑**：我们把所有的判断逻辑都移入了 `for` 循环的**内部**。现在，探险家每计算出一个新方向，都会**立刻**对这个方向进行完整的检查，然后再决定下一步怎么走。这保证了探索的严谨和正确！
        

### 最终的魔法代码 ✨

经过我们不懈的努力，这份完美的代码诞生了！它思路清晰，逻辑严谨，是智慧的结晶！

```
package main

import (
	"fmt"
)

// 定义一个全局的“指南针”，用来表示上下左右四个方向
var dir = [][]int{
	{0, 1}, {1, 0}, {-1, 0}, {0, -1},
}

func solve() {
	var n, m int
	// 读取地图的行数n和列数m
	fmt.Scanln(&n, &m)

	// 创建地图(graph)和打卡记录本(visit)
	graph := make([][]int, n)
	visit := make([][]bool, n)

	for i := 0; i < n; i++ {
		graph[i] = make([]int, m)
		visit[i] = make([]bool, m)
	}

	// 读取地图的具体内容
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			fmt.Scan(&graph[i][j])
		}
	}

	// result用于记录岛屿的数量
	result := 0

	// 定义我们的“探险猫咪”——深度优先搜索(DFS)函数
	var dfs func(x, y int)
	dfs = func(x, y int) {
		// 尝试从当前位置(x,y)向四个方向探索
		for i := 0; i < 4; i++ {
			nextx := x + dir[i][0]
			nexty := y + dir[i][1]

			// --- 核心判断逻辑 ---
			// 1. 判断新坐标是否跑出地图边界
			if (nextx < 0 || nextx >= n) || (nexty < 0 || nexty >= m) {
				continue // 如果出界，就放弃这个方向，看下一个
			}

			// 2. 判断新坐标是否是陆地(1)，并且我们之前没有来过(!visit)
			if !visit[nextx][nexty] && graph[nextx][nexty] == 1 {
				// 如果可以走，就先打卡，标记为已访问
				visit[nextx][nexty] = true
				// 然后从这个新点出发，继续深入探索！
				dfs(nextx, nexty)
			}
		}
	}

	// --- 总指挥：开始遍历整个地图 ---
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			// 如果发现了一个点是陆地(1)，并且它不属于任何一个我们已经发现的岛屿(!visit)
			if !visit[i][j] && graph[i][j] == 1 {
				// 那么，我们发现了一个全新的岛屿！
				result++ // 岛屿数量加一
				// 标记这个点为已访问
				visit[i][j] = true
				// 然后派出“探险猫咪”dfs，从这个点出发，把整个岛屿都探索完并标记上
				dfs(i, j)
			}
		}
	}

	// 所有探索结束，打印最终的岛屿数量
	fmt.Println(result)
}

func main() {
	solve()
}
```

### 探险策略深度解析

- **核心思想**：这个问题的核心是找到并计数**图的连通分量**。我们把整个地图看作一个图，每一块陆地 `1` 是一个节点，相邻的陆地之间有边。我们的任务就是数一数，这个图里有几个独立的、不相连的片区。
    
- **总指挥与探险家**：
    
    - `solve` 函数里的两层 `for` 循环是**总指挥**。它负责全面巡视地图。
        
    - `dfs` 函数是**探险家**。它只负责探索，不负责计数。
        
- **工作流程**：
    
    1. **总指挥**从地图的左上角 `(0,0)` 开始，一格一格地巡视。
        
    2. 当它发现一格**从未被访问过**的陆地 `1` 时，它知道：“嘿！一个新岛屿的冰山一角出现了！”
        
    3. 于是，它立刻让 `result` 加一，然后马上派出**探险家** `dfs`，并告诉它：“从这个点 `(i,j)` 出发，把所有和它连在一起的陆地都给我找出来，并且全部插上‘已访问’的小旗子！”
        
    4. **探险家** `dfs`接到命令，就开始用“不撞南墙不回头”的精神，把整个岛屿的每一寸土地都走遍并做好标记。
        
    5. `dfs` 任务完成后，**总指挥**继续巡视。因为它有了 `visit` 这个打卡记录本，所以它会跳过所有刚才被 `dfs` 标记过的土地，直到它找到下一个**全新的、未被访问过**的陆地，再重复上面的过程。
        

这个“总指挥+探险家”的模式，完美地保证了每个岛屿只被发现和计数**一次**，最终得到了正确的结果。

主人真的太棒了！能独立思考并最终完成这么经典又有趣的算法题，为你感到无比的骄傲！期待我们下一次的编程大冒险哦！♪(^∇^*)