喵~ 主人，周五的黄昏，天空的颜色真好看呀！结束了一周的学习，最适合来挑战一道像这样纯粹又经典的动态规划（DP）压轴题了！(｡˃ ᵕ ˂ )♡

你写的这个DP解法非常标准和漂亮，能想到用这种方式来解决，说明你对DP的理解已经非常深刻了！这道题的思路，就像是从一棵树的构造中，看见了一片由所有可能性组成的广阔森林，充满了数学的美感。

就让我为你把这道题背后精妙的逻辑，详细地记录下来，作为我们本周学习的完美收官吧！

---

### LeetCode 96. 不同的二叉搜索树

**[题目链接](https://leetcode.cn/problems/unique-binary-search-trees/)**

#### 题目描述

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

---

### 我们的思考之旅 ♪ (从一棵树看见一片森林)

#### Phase 1: 核心问题 —— BST是如何构造的？

这道题的突破口，在于深刻理解BST的构造规则。如果我们从 `1, 2, ..., n` 这 `n` 个数中，选择一个数 `i` 作为根节点，那么会发生什么？

- 所有比 `i` 小的数 (`1, ..., i-1`)，都**必须**去 `i` 的左子树。
    
- 所有比 `i` 大的数 (`i+1, ..., n`)，都**必须**去 `i` 的右子树。
    

你看，一旦我们选定了根，整个问题就被漂亮地**分割**成了两个**完全独立**的子问题：

1. 用 `i-1` 个数能构造出多少种不同的左子树？
    
2. 用 `n-i` 个数能构造出多少种不同的右子树？
    

这种“**问题可以被分解为独立的子问题**”的特性，正是动态规划大显身手的最佳舞台！

#### Phase 2: DP的定义与状态转移 (神奇的递推公式)

1. dp 数组的定义

我们先来定义 dp 数组的含义，这是我们DP解法的基石：

> **`dp[i]` 表示：用 `i` 个连续的、不同的节点，能构成多少种不同的二叉搜索树。**

我们的最终目标就是求 `dp[n]`。

**2. 基础情况 (Base Cases)**

- `dp[0] = 1`: 这是最巧妙、也最关键的一个基础。用0个节点构造BST有多少种方法？只有**一种**，那就是构造一棵**空树 (`nil`)**！我们必须承认“空树”也是一种形态，这样我们的递推公式才能完美运作。
    
- `dp[1] = 1`: 用1个节点构造BST，只有一种方法，就是它自己孤零零地当根节点。
    

3. 状态转移方程

现在，我们来思考如何计算 dp[i]（用 i 个节点能构造的BST数量）。

我们可以依次尝试让 `1, 2, ..., i` 中的每一个数都来当一次根节点，然后把所有情况加起来。

假设我们让第 `j` 个数（值为 `j`）来当根节点（`j` 可以从 `1` 取到 `i`）：

- **左子树**: 根节点的左边有 `j-1` 个数 (`1, ..., j-1`)。用这 `j-1` 个数能构造多少种左子树呢？根据我们的定义，正好是 `dp[j-1]` 种！
    
- **右子树**: 根节点的右边有 `i-j` 个数 (`j+1, ..., i`)。用这 `i-j` 个数能构造多少种右子树呢？正好是 `dp[i-j]` 种！
    

根据**乘法原理**，当根节点固定为 `j` 时，总共能形成的BST数量就是 `左子树的可能性 * 右子树的可能性`，也就是 `dp[j-1] * dp[i-j]`。

最后，根据**加法原理**，我们把 `j` 从 `1` 到 `i` 的所有可能性全部加起来，就得到了 `dp[i]` 的总数！

> **`dp[i] = Σ (dp[j-1] * dp[i-j])` (其中 j 从 1 到 i)**

你的代码 `dp[i] += dp[j] * dp[i-j-1]` (其中 `j` 从 `0` 到 `i-1`)，其实是这个公式的另一种等价形式，它把 `j-1` 变成了 `j`，含义是“左子树有 `j` 个节点”，那么右子树就有 `i-1-j` 个节点，思路是完全一样的，非常漂亮！

---

### 你的最终完美解法

Go

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 * Val int
 * Left *TreeNode
 * Right *TreeNode
 * }
 */
func numTrees(n int) int {
    // dp[i] 表示用 i 个节点能构成的不同BST的数量
    dp := make([]int, n+1)
    
    // 初始化基础情况
    dp[0] = 1 // 空树是一种情况
    
    // 从节点数为 1 开始，依次计算到 n
    for i := 1; i <= n; i++ {
        // 依次尝试让每个节点都当一次根
        // j 代表左子树的节点数量 (从0到i-1)
        for j := 0; j < i; j++ {
            // 当左子树有 j 个节点时，根节点占 1 个，
            // 那么右子树就有 i-1-j 个节点。
            // 根据乘法原理，总数是 dp[左] * dp[右]
            dp[i] += dp[j] * dp[i-1-j]
        }
    }
    
    return dp[n]
}

// 这是一个辅助函数，实际解题不需要
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 最终总结 (´▽`ʃ♡ƪ)

这道题是著名的**卡特兰数 (Catalan number)** 的一个典型应用。能够解出这道题，说明主人你对DP的理解，已经从“线性”问题（比如爬楼梯）成功地扩展到了更复杂的“组合计数”问题！

这绝对是你DP技能树上，一块闪闪发光的徽章！

好啦，我们今天的学习就在这道充满数学之美的题目中，画上了一个完美的句号！祝主人有一个超级愉快的周末！晚安喵~ ❤️