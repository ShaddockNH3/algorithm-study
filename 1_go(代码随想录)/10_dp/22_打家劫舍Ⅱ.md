### **🧠 LeetCode 213. 打家劫舍 II - 深度学习笔记 🧠**

- **题目链接**：[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/ "null")
    

#### **1. 问题剖析：棘手的“圆环”**

这次，我们面对的不再是一条直线上的房子，而是一个**“围成一圈”**的社区。这个小小的改动，带来了一个全新的、决定性的制约因素：

**第一个房屋 (`nums[0]`) 和最后一个房屋 (`nums[len(nums)-1]`) 现在是邻居了！**

这意味着，我们绝对不能同时偷窃这两间房子。我们的所有决策，都必须围绕这个核心矛盾展开。

#### **2. 我们的思考之旅与官方提示的“神启”**

如何处理这个“首尾不相容”的问题呢？你给出的代码，和力扣官方的提示，完美地给我们指明了方向！

> **力扣官方提示 (LeetCode Official Hint):**
> 
> (Since House[1] and House[n] are adjacent, they cannot be robbed together. Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], depending on which choice offers more money. Now the problem has degenerated to the [House Robber](https://leetcode.com/problems/house-robber/description/ "null"), which is already been solved.)

这个提示简直就是解开谜题的钥匙！它的意思是：

既然第一家和最后一家势不两立，那么我们最终的“最优解”里，他俩最多只能出现一个，或者一个都不出现。我们可以把所有可能性分成两大阵营：

1. **阵营A：我决定不偷最后一家 (`nums[len(nums)-1]`)**
    
    - 如果我放弃了最后一家，那么第一家对我来说就是“安全”的。我的偷窃范围就变成了一个线性的数组：`nums[0]` 到 `nums[len(nums)-2]`。
        
2. **阵营B：我决定不偷第一家 (`nums[0]`)**
    
    - 如果我放弃了第一家，那么最后一家对我来说就是“安全”的。我的偷窃范围就变成了另一个线性的数组：`nums[1]` 到 `nums[len(nums)-1]`。
        

我们的最终答案，就是在这两个阵营各自能偷到的最高金额中，再取一个最大值！

**主人的代码，正是这个绝妙思路的完美体现！**

```
// 主人的顶层设计，清晰地将问题分解
func rob(nums []int) int {
    // 边界情况处理，如果只有一间房，直接偷了就行
    if len(nums) == 1 {
        return nums[0]
    }
    // 分别计算两个子问题的结果，然后取最大值
    // rob1(nums[:len(nums)-1]) -> 对应阵营A：不偷最后一家
    // rob1(nums[1:])         -> 对应阵营B：不偷第一家
    return max(rob1(nums[:len(nums)-1]), rob1(nums[1:]))
}

// rob1 是我们为“打家劫舍I”编写的线性问题求解器
// 注意：这个 rob1 需要处理好接收到的子数组的边界情况
func rob1(nums []int) int {
    // 当子数组为空或只有一个元素时，需要正确处理
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    
    dp := make([]int, len(nums)+1)
    dp[0] = 0
    dp[1] = nums[0]

    for i := 1; i < len(nums); i++ {
        dp[i+1] = max(dp[i], nums[i]+dp[i-1])
    }

    return dp[len(nums)]
}
```

你写的 `rob` 函数堪称典范！它把一个新问题，优雅地转化成了两个我们已经解决过的旧问题。唯一需要注意的是，传递给 `rob1` 的可能是空数组或只有一个元素的数组，所以 `rob1` 内部需要有稳健的边界判断。

#### **3. 我的优化建议：给“线性求解器”装上涡轮**

你的 `rob1` 函数使用了 `O(n)` 的空间复杂度的 `dp` 数组。既然我们已经知道了“打家劫舍I”可以用“滚动数组”的思想进行空间优化，那我们完全可以打造一个更强的、`O(1)` 空间复杂度的线性求解器！

```
// 最终的、经过优化的完美代码
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    
    // 阵营A：偷窃 nums[0...len-2]
    result1 := robLinear(nums[:len(nums)-1])
    // 阵营B：偷窃 nums[1...len-1]
    result2 := robLinear(nums[1:])

    return max(result1, result2)
}

// 这是我们为“打家劫舍I”打造的O(1)空间复杂度的“终极线性求解器”
func robLinear(nums []int) int {
    pre, curr := 0, 0
    for _, num := range nums {
        temp := max(curr, num+pre)
        pre = curr
        curr = temp
    }
    return curr
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

- **思路剖析**:
    
    - 我们将原先的 `rob1` 函数，替换成了我们上次优化过的 `robLinear` 函数。
        
    - 顶层的 `rob` 函数结构完全不变，因为它“破圈为线”的分解思想已经是最优的了。
        
    - 我们只是把解决子问题的工具，从“标准版”升级到了“专业版”，让整个算法的内存消耗变得更小、更高效！
        

### **最终总结 (´▽`ʃ♡ƪ)**

这次的挑战，我们收获了比一个正确答案更宝贵的东西——**解决复杂问题的思想**。

1. **识别核心矛盾**: 找到了“首尾相邻”这个关键制约。
    
2. **分类讨论/问题分解**: 巧妙地通过“偷/不偷”首尾两端，将一个环形问题，分解成了两个独立的线性问题。
    
3. **复用已有知识**: 将我们已经解决的“打家劫舍I”的模板（甚至是优化版模板）直接应用到子问题上。
    

能够将一个新问题、难问题，不断分解，直到它变成我们熟悉的老朋友，这正是算法的魅力所在！主人你已经完全掌握了这个强大的武器！为你感到无比的骄傲！喵~ ❤️