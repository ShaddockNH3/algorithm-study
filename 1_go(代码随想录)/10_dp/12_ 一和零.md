### LeetCode 笔记：[474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/ "null")

这是一道非常巧妙的动态规划问题，它将经典的0-1背包问题扩展到了二维，是理解“多维背包”概念的绝佳练习。

#### 最终解答 (多维0-1背包)

这是主人经过思考和探索，最终完成的漂亮代码！它完美地实现了二维费用背包问题的空间优化解法。

```
// 主人最终完成的完美解法
func findMaxForm(strs []string, m int, n int) int {
    // dp[i][j] 表示用 i 个 '0' 和 j 个 '1' 的容量，
    // 最多能装下多少个字符串（即子集的最大长度）
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    
    // 遍历每一个物品 (字符串)
    for _, str := range strs {
        // 获取当前这个物品的“消耗”
        num0, num1 := getNum(str)

        // 遍历背包容量 (0的数量)，必须从后往前！
        for i := m; i >= num0; i-- {
            // 遍历背包容量 (1的数量)，也必须从后往前！
            for j := n; j >= num1; j-- {
                // 核心状态转移方程：
                // 决策：是不放这个str，还是放这个str
                dp[i][j] = max(dp[i][j], dp[i-num0][j-num1] + 1)
            }
        }
    }

    // 循环结束后，dp[m][n] 就是我们的答案
    return dp[m][n]
}

// 辅助函数：计算字符串中0和1的数量
func getNum(str string) (int, int) {
    num0, num1 := 0, 0
    for _, s := range str {
        if s == '0' {
            num0++
        } else if s == '1' {
            num1++
        }
    }
    return num0, num1
}

// 辅助函数：求最大值
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 我们的思考：解开“双口袋背包”的秘密 🐾

#### 第一步：转化问题，看清本质

我们最开始的直觉是正确的：字符串本身不重要，重要的是它里面 `0` 和 `1` 的数量。 `"10"` -> `(1个0, 1个1)` `"0001"` -> `(3个0, 1个1)` `"1"` -> `(0个0, 1个1)`

这样，问题就变成了：

> 我们有一堆物品，每个物品都有两种“重量” (`num0` 和 `num1`)。 我们有一个特殊的背包，它也有两种“容量” (`m` 和 `n`)。 每个物品的“价值”都是 `1`（因为我们想让子集长度最大，每装一个物品，长度就+1）。 目标：求能装下的最大“价值”。

#### 第二步：识别模型，多维背包

我们当时聊到，一个限制（容量），对应DP数组的一个维度。那么两个限制（`m` 和 `n`），自然就对应了DP数组的**两个维度**。

这就是**多维费用背包问题**，也叫二维背包。它和我们熟悉的0-1背包问题，除了限制多了一维，其他核心思想完全一致。

- **DP状态定义**：`dp[i][j]` 的含义至关重要。它代表：**用 `i` 个 `0` 和 `j` 个 `1` 的容量，能得到的最大子集长度**。
    
- **状态转移方程**：对于每个字符串（物品），我们面临一个决策：
    
    - **不放**：那么 `dp[i][j]` 的值不变。
        
    - **放**：前提是容量足够 (`i >= num0` 且 `j >= num1`)。如果放了，子集长度就变成了 `dp[i-num0][j-num1] + 1`。
        
    - **决策结果**：我们取两者中的最大值，`dp[i][j] = max(dp[i][j], dp[i-num0][j-num1] + 1)`。
        

#### 第三步：空间优化与倒序遍历

这个解法其实已经进行了空间优化。一个未经优化的版本应该是三维的 `dp[k][i][j]`（用前 `k` 个物品...）。但我们可以像优化普通0-1背包一样，去掉物品那一维。

实现这个优化的关键，就在于**倒序遍历容量**！

- **为什么必须倒序？** `for i := m; i >= num0; i--` `for j := n; j >= num1; j--` 这是为了保证，在计算 `dp[i][j]` 时，我们用来更新它的 `dp[i-num0][j-num1]` 还是**上一轮**（处理上一个字符串时）的状态。如果正序遍历，我们就会用到本轮已经更新过的值，这就相当于一个物品被重复使用了多次，变成了“完全背包”问题，那就错啦！
    

### 总结

这道题是对0-1背包问题理解深度的一次绝佳考验。通过它，我们彻底明白了：

- 背包问题的“容量”可以是多维的。
    
- 多维背包的DP数组维度与容量维度相对应。
    
- 空间优化的核心——“倒序遍历”，在多维背包中同样适用，且每个维度的容量都需要倒序遍历。
    

主人能够独立思考并最终攻克这个问题，真的非常了不起！这说明你对动态规划的理解又上了一个新台阶。夜深了，带着满满的成就感，好好休息吧！晚安安~ (つω-`｡)