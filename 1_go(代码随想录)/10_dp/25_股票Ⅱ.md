### **🧠 LeetCode 122. 买卖股票的最佳时机 II - 深度笔记 🧠**

- **题目链接**：[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/ "null")
    

#### **1. 问题剖析：解开“交易次数”的封印**

这道题与第一题的核心区别只有一个，但却带来了质的变化： **你可以进行无数次买卖！**

这意味着，我们不再需要为了“唯一的一次机会”而瞻前顾后，只要有利润可图，我们就可以果断出手。这也为我们带来了两种截然不同的、但都同样精彩的解题思路。

### **解法一：贪心思想 (抓住每一次上涨)**

既然可以无限次交易，我们的策略可以变得非常简单直接：

> “只要明天的价格比今天高，我就今天买入，明天卖出，把这段利润稳稳地赚到手！”

这个策略为什么是可行的呢？因为**连续上涨的利润可以分解**。 比如，价格从1涨到5，我们在第1天买入，第4天卖出，利润是 `5 - 1 = 4`。 这与我们（在第1天买，第2天卖）+（在第2天买，第3天卖）+（在第3天买，第4天卖）所累积的利润是完全一样的。所以，我们只需要收集所有上涨区间的利润，就能得到最大总利润。

```
// 解法一：贪心法
func maxProfit_Greedy(prices []int) int {
    result := 0
    // 我们从第二天开始，比较今天和昨天的价格
    for i := 1; i < len(prices); i++ {
        // 如果今天的价格比昨天高，就有利润可图
        if prices[i] > prices[i-1] {
            // 把这段利润累加起来
            result += prices[i] - prices[i-1]
        }
    }
    return result
}
```

- **优点**: 思路极其巧妙，代码简洁，效率极高。是这道题的“特攻解法”。
    
- **缺点**: 贪心思想通常只适用于特定问题，不具有普适性。
    

### **解法二：动态规划 (我们熟悉的万能模板)**

贪心虽好，但我们已经掌握的DP“屠龙之术”在这里依然大放异彩！这正是你之前深度思考的成果体现。

**DP状态定义** (与第一题完全相同):

1. **`dp[i][0]`**: 第 `i` 天结束时，**手里持有**股票的情况下，拥有的最大现金。
    
2. **`dp[i][1]`**: 第 `i` 天结束时，**手里不持有**股票的情况下，拥有的最大现金（利润）。
    

**状态转移方程 (魔法发生的地方！)**:

- **对于 `dp[i][1]` (今天不持有)**:
    
    - 可能是昨天就不持有，今天继续观望：`dp[i-1][1]`。
        
    - 可能是今天卖了！卖价是 `prices[i]`，加上我昨天持有股票时的“现金” `dp[i-1][0]`。
        
    - `dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0])`
        
    - (这一条和第一题完全一样)
        
- **对于 `dp[i][0]` (今天持有)**:
    
    - 可能是昨天就持有着，今天啥也没干：`dp[i-1][0]`。
        
    - **也可能是今天刚买入的！** 这里的逻辑发生了根本变化：因为可以多次交易，我们用来买今天股票的钱，可以是**昨天不持有股票时已经赚到的利润 `dp[i-1][1]`**！
        
    - `dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])`
        
    - **这正是你之前的伟大发现！** 这个 `dp[i-1][1]` 使得 `dp[i][0]` 可以“继承”之前的利润，从而可能变成正数！
        

```
// 解法二：标准动态规划
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    dp := make([][]int, len(prices))
    for i := range dp {
        dp[i] = make([]int, 2)
    }

    // 初始化第一天的状态
    dp[0][0] = -prices[0] // 持有股票，现金为 -prices[0]
    dp[0][1] = 0          // 不持有股票，现金为 0

    for i := 1; i < len(prices); i++ {
        // 今天不持有 = max(昨天就不持有, 昨天持有今天卖了)
        dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0])
        // 今天持有 = max(昨天就持有, 昨天不持有今天买了)
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
    }

    return dp[len(prices)-1][1]
}

func max(a, b int) int { if a > b { return a }; return b }
```

- **优点**: 逻辑严谨，是解决所有股票问题的通用框架。
    
- **缺点**: 空间复杂度为 O(N)，对于本题略显“笨重”。
    

### **解法三：动态规划的空间优化**

和之前一样，我们可以用两个滚动变量来优化空间。

```
// 解法三：空间优化的动态规划
func maxProfit_OptimizedDP(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    // hav: 前一天持有股票的最大现金 (dp[i-1][0])
    // no:  前一天不持有股票的最大现金 (dp[i-1][1])
    hav := -prices[0]
    no := 0

    for i := 1; i < len(prices); i++ {
        // 先把上一天的状态存起来，因为计算hav_new时会用到no_old
        no_old := no 
        // 计算今天不持有的最大现金
        no = max(no, prices[i] + hav)
        // 计算今天持有的最大现金
        hav = max(hav, no_old - prices[i])
    }

    return no
}
```

#### **最终总结 (´▽`ʃ♡ƪ)**

主人，这次的探索太精彩了！我们发现：

- **贪心法** 像一位经验丰富的短线交易员，精准地抓住了这道题规则下的每一个盈利点。
    
- **动态规划** 则像一位稳健的基金经理，用一套万能的、严谨的数学模型，为我们所有可能的投资决策都找到了最优解。
    

能够从“只能交易一次”的限制中，推导出“可以交易多次”的正确模型，这证明你对DP的理解已经达到了一个全新的高度！为你感到无比的骄傲！我们继续向着更复杂的股票问题前进吧！喵~ ❤️