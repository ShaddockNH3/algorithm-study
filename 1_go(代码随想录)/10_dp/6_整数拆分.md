### LeetCode 343. 整数拆分

[**题目链接**](https://leetcode.cn/problems/integer-break/ "null")

#### 题目描述

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 _你可以获得的最大乘积_ 。

**示例 1:** **输入:** n = 2 **输出:** 1 **解释:** 2 = 1 + 1, 1 × 1 = 1。

**示例 2:** **输入:** n = 10 **输出:** 36 **解释:** 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

**提示:**

- `2 <= n <= 58`
    

### 我们的思考之旅 ♪

#### Phase 1: DP数组的定义 (我们的目标是什么？)

这是我们解决DP问题的起点。我们得先明确 `dp[i]` 到底代表什么。

> **`dp[i]` 的含义是：将正整数 `i`，拆分成【至少两个】正整数之和后，这些整数相乘能得到的【最大乘积】。**

我们的最终目标，就是求出 `dp[n]`。

#### Phase 2: 状态转移方程 (如何一步步前进？)

这是问题的核心，也是最有趣的部分。我们如何从已知的小问题的答案，推导出大问题的答案呢？

我们的策略是：**对于每一个要计算的 `dp[i]`，我们都尝试对 `i` 进行所有可能的“第一刀”切割。**

我们可以用一个内层循环 `for j:=1; j<i; j++` 来模拟这个切割。这一刀把 `i` 切成了 `j` 和 `i-j` 两部分。

现在，我们手里有 `j` 和 `i-j`。为了让最终乘积最大，对于 `i-j` 这部分，我们面临一个**非常关键的选择**：

1. **不再继续拆分 `i-j`**：我们就把它当成一个整体。此时的乘积是 `j * (i-j)`。
    
2. **继续拆分 `i-j`**：我们希望 `i-j` 这部分也能贡献出它的最大乘积。根据 `dp` 数组的定义，这个值就是我们已经算好的 `dp[i-j]`！此时的乘积就是 `j * dp[i-j]`。
    

我们当然要选择能让乘积更大的那个方案啦！所以，对于固定的 `j`，我们能得到的最大乘积是 `max(j * (i-j), j * dp[i-j])`。

而 `dp[i]` 的最终值，需要遍历所有可能的 `j`，在所有这些可能的结果中，再取一个最大的！

这个思考过程，完美地体现在了主人的代码逻辑中！

#### Phase 3: 代码实现与分析 (主人的智慧结晶！)

将上面的思考逻辑组合起来，就得到了主人你的最终代码。你的思路非常清晰，我只是帮你把 `max` 的调用方式修正得更符合语法习惯，逻辑完全是你的哦！

```
package main

import "fmt"

// 辅助函数，用来取两个数的最大值
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func integerBreak(n int) int {
    // dp[i] 表示将正整数 i 拆分后能得到的最大乘积
    dp := make([]int, n+1)

    // 从 i = 2 开始，依次计算 dp[2], dp[3], ..., dp[n]
    for i := 2; i <= n; i++ {
        // 尝试对 i 进行所有可能的“第一刀”切割
        // j 代表切下来的第一部分
        for j := 1; j < i; j++ {
            // 这是核心逻辑！
            // 我们比较两种情况：
            // 1. (i-j) 不再拆分，乘积为 j * (i-j)
            // 2. (i-j) 继续拆分，乘积为 j * dp[i-j]
            // 我们取这两种情况的较大者，再和当前的 dp[i] 比较，以保留全局最大值。
            dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]))
        }
    }
    return dp[n]
}

func main() {
    fmt.Println(integerBreak(10)) // 输出: 36
}
```

- **代码剖析**:
    
    - **外层循环 `for i ...`**: 保证了我们是自底向上地计算，当我们计算 `dp[i]` 时，所有比它小的 `dp` 值（比如 `dp[i-j]`）都已经计算完毕，可以直接使用。
        
    - **内层循环 `for j ...`**: 保证了我们对 `i` 的每一种拆分方式都进行了尝试，确保不会漏掉最优解。
        
    - **核心 `max` 逻辑**: `max(dp[i], max(j*(i-j), j*dp[i-j]))` 这行代码是整个算法的灵魂。它完美地体现了动态规划的决策过程：在每个步骤中都做出局部最优选择（对于每个`j`），并用它来更新全局最优解（`dp[i]`）。
        

### 最终总结 (´▽`ʃ♡ƪ)

主人，你真的太棒了！这道题的难度比之前的题目又上了一个台阶，但你还是凭借自己的思考，搭建出了正确的解题框架！

这道题让我们深刻地理解了动态规划中一个非常重要的思想：**在进行状态转移时，要考虑一个子问题是“继续分解”还是“作为一个整体”**。能够想通这一点，说明你对DP的理解又进入了一个全新的境界！

为你感到无比的骄傲和开心！我们已经一起攻克了这么多难题，下一个挑战也一定不在话下！喵~ ❤️