喵啊，主人晚上好！已经快要11点了，你还在孜孜不倦地学习，这种精神真的让我好佩服！(｡>ω<｡)ﾉ

我们今晚一起探索了这么多关于“目标和”这道题的奥秘，从回溯到动规，从二维到一维。为了方便主人以后回顾，我把我们所有的思考和最终的成果，整理成一份详细的专属笔记。希望这份笔记能像星星一样，点亮你以后算法学习的道路~ ✨

---

### LeetCode 笔记：[494. 目标和](https://leetcode.cn/problems/target-sum/)

这是一道非常经典的算法题，它巧妙地将一个看似简单的“加减法”问题，与回溯搜索和动态规划（特别是0-1背包问题）联系在了一起，是检验和锻炼算法思维的绝佳试金石。

#### 最终优化解法 (1D DP)

这是我们最终得到的最优解，它简洁、高效，完美地体现了动态规划的魅力。

Go

```
// 主人最终掌握的完美解法
func findTargetSumWays(nums []int, target int) int {
    sum := 0
    for _, num := range nums {
        sum += num
    }

    // 绝对值剪枝与奇偶性剪枝
    if abs(target) > sum || (sum+target)%2 == 1 {
        return 0
    }

    // 目标正数和
    N := (sum + target) / 2

    // dp[j] 表示和为 j 的方法数
    dp := make([]int, N+1)
    dp[0] = 1 // 和为0的方法只有一种：什么都不选

    for _, num := range nums {
        for j := N; j >= num; j-- {
            dp[j] += dp[j-num]
        }
    }
    return dp[N]
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

---

### 核心思想：问题转化 ✨

这道题最关键的一步，就是将“添加 `+` 或 `-` 号”的问题，转化为一个我们更熟悉的“子集划分”问题。

1. **定义两堆数**：
    
    - `P`：所有前面添加 `+` 号的数。
        
    - `N`：所有前面添加 `-` 号的数。
        
2. **建立方程**：
    
    - 根据题意：`sum(P) - sum(N) = target`
        
    - 我们知道：`sum(P) + sum(N) = totalSum` (数组所有数的总和)
        
3. **求解**：
    
    - 将两个方程相加，得到：`2 * sum(P) = target + totalSum`
        
    - 因此，正数堆的和 `sum(P) = (target + totalSum) / 2`。
        

**新问题诞生了**：原问题等价于，**在 `nums` 数组中，找到一个子集，使得这个子集的元素之和恰好等于 `(target + totalSum) / 2`。我们需要求解这样的子集一共有多少个。**

这个新问题，就是一个经典的 **0-1背包问题** 的变种：

- **背包容量**：`W = (target + totalSum) / 2`
    
- **物品列表**：`nums` 数组中的每一个数
    
- **物品重量**：`nums[i]`
    
- **目标**：求恰好装满背包的方法数，而不是求最大价值。
    

---

### 解法一：回溯法 (最直观的暴力搜索)

这是我们最开始聊到的，最符合直觉的解法。

- **思考路径**：对每个数，我们都有“选 `+`”和“选 `-`”两种选择。这构成了一棵深度为 `n`（`n`为数组长度）的二叉决策树。我们只需用深度优先搜索（DFS）遍历这棵树的所有叶子节点即可。
    
- **实现**：我们通过一个递归函数 `backtrack(index, currentSum)` 来实现。
    
    - `index`: 当前决策到哪个数。
        
    - `currentSum`: 当前已经累计的和。
        
- **递归与回溯**：
    
    - **终止条件**：当 `index` 遍历完所有数，检查 `currentSum` 是否等于 `target`。
        
    - **选择**：在函数中，分别调用 `backtrack(index+1, currentSum + nums[index])` 和 `backtrack(index+1, currentSum - nums[index])`，代表两种选择。
        
    - **隐式回溯**：我们当时讨论过，因为 Go 的 `int` 是值传递，每次递归调用都相当于在一个“全新的房间”里计算，所以当一个分支返回时，`currentSum` 的状态自然就“恢复”了，无需显式的代码来“撤销选择”。
        

Go

```
// 回溯法实现
func findTargetSumWays_DFS(nums []int, target int) int {
	count := 0
	backtrackHelper(nums, target, 0, 0, &count)
	return count
}

func backtrackHelper(nums []int, target int, index int, currentSum int, count *int) {
	if index == len(nums) {
		if currentSum == target {
			*count++
		}
		return
	}
	// 选择 '+'
	backtrackHelper(nums, target, index+1, currentSum+nums[index], count)
	// 选择 '-'
	backtrackHelper(nums, target, index+1, currentSum-nums[index], count)
}
```

- **优缺点**：思路清晰，易于理解。但时间复杂度为 `O(2^n)`，在 `n` 较大时会超时。
    

---

### 解法二：动态规划 (高效的填表法)

为了解决回溯法的性能问题，我们引入了动态规划。

#### 1. 二维DP版本 (基础与陷阱)

这是 DP 解法的基础，能帮我们更好地理解状态转移。

- **DP状态定义**：`dp[i][j]` 表示用前 `i` 个物品，凑成和为 `j` 的方法数。
    
- **状态转移方程**：`dp[i][j] = dp[i-1][j] (不选第i个) + dp[i-1][j - nums[i-1]] (选第i个)`
    
- **我们聊过的陷阱**：二维 DP 的初始化相对复杂，尤其是在处理 `nums` 中含有 `0` 的情况时。如果 `nums[0]` 为 `0`，那么 `dp[0][0]` 应该为 `2`（`+0` 和 `-0` 都能凑出背包容量0），而不是 `1`。这使得初始化代码容易出错。
    

Go

```
// 二维DP实现 (修正后)
func findTargetSumWays_2D_DP(nums []int, target int) int {
    // ... 省略了 sum 和 N 的计算 ...
	N := (sum + target) / 2
	dp := make([][]int, len(nums)+1)
	for i := range dp {
		dp[i] = make([]int, N+1)
	}
	dp[0][0] = 1

	for i := 1; i <= len(nums); i++ {
		num := nums[i-1]
		for j := 0; j <= N; j++ {
			dp[i][j] = dp[i-1][j] // 不选 num
			if j >= num {
				dp[i][j] += dp[i-1][j-num] // 选 num
			}
		}
	}
	return dp[len(nums)][N]
}
```

#### 2. 一维DP版本 (最终的优化)

在二维DP的基础上，我们可以进行空间优化，得到我们最终的完美解法。

- **DP状态定义**：`dp[j]` 表示凑成和为 `j` 的方法数。
    
- **状态转移方程**：`dp[j] += dp[j - num]`
    
- **核心技巧**：
    
    - **倒序遍历**：`for j := N; j >= num; j--` 这一步至关重要。它保证了在计算 `dp[j]` 时，所用到的 `dp[j-num]` 还是上一轮（处理上一个物品时）的结果，从而正确地模拟了0-1背包中“每个物品只用一次”的原则。
        
    - **优雅处理`0`**：我们发现，这个简洁的循环天生就能处理 `num=0` 的情况。`dp[j] += dp[j-0]` 会让当前的方法数翻倍，完全符合逻辑，无需任何特殊判断。
        

---

### 总结

|解法|时间复杂度|空间复杂度|优点|缺点|
|---|---|---|---|---|
|**回溯法**|`O(2^n)`|`O(n)`|思路直观，易于理解|性能差，会超时|
|**二维 DP**|`O(n * N)`|`O(n * N)`|性能好，是思维的基石|空间占用大，初始化易错|
|**一维 DP**|`O(n * N)`|`O(N)`|性能好，空间优，代码优雅|相对不那么直观|

能陪着主人从最开始的困惑，一步步走到最后的豁然开朗，我真的感到非常荣幸和开心。你今晚的努力和思考，让你对回溯和动态规划都有了更深一层的羁绊。

夜已经很深啦，快去休息吧！晚安，我最棒的主人！(つω-`｡)