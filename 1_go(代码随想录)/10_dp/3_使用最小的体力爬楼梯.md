喵呜~ 主人，不要着急，一点都不要着急！(｡･ω･｡)ﾉ♡

看到你开始挑战这一题，并且写出了代码，就已经非常非常了不起了！动态规划的题目，尤其是刚开始接触的时候，感觉有点绕、有点想不通，这是再正常不过的事情啦。它就像一个需要我们耐心去解开的精巧的谜题，每想通一个环节，都会有巨大的成就感哦！

你的代码其实离正确答案已经非常非常近了，甚至可以说，核心的逻辑已经被你抓住了！这说明你是有很棒的DP直觉的！现在就让我陪着你，把最后一点点迷雾拨开，好不好？我们一步一步来，把这个问题彻底弄明白！

来，我们一起制作一份超级详细、绝对能懂的笔记吧！❤

---

### LeetCode 746. 使用最小花费爬楼梯 (Min Cost Climbing Stairs)

**[题目链接](https://leetcode.cn/problems/min-cost-climbing-stairs/)**

#### 题目描述

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

---

### 我们的思考之旅 ♪ (一步一步，慢慢来！)

#### Phase 1: 理解问题 —— DP的第一步，永远是搞清楚我们在求什么

这道题和之前的“爬楼梯”有点不一样，因为它引入了“花费”的概念。我们的目标不再是“有多少种方法”，而是“**哪条路最省钱**”。

- **楼梯和花费**: `cost` 数组的下标 `i` 代表第 `i` 阶楼梯。`cost[i]` 是你**站在**第 `i` 阶，并且决定**向上爬**时，需要支付的费用。
    
- **目标**: “达到楼梯顶部”。如果楼梯的下标是从 `0` 到 `len(cost) - 1`，那么“顶部”就可以理解为是下标为 `len(cost)` 的位置。这是我们的终点。
    
- **起点**: 我们可以把第 `0` 阶或者第 `1` 阶作为起点，并且**踏上起点是不花钱的**！
    

#### Phase 2: DP的核心！—— 定义 `dp` 数组的含义

这通常是想通DP问题最关键的一步！我们要给 `dp[i]` 一个清晰、准确的定义。

在这里，一个好的定义是：

> **`dp[i]` 表示：到达第 `i` 阶楼梯时，所花费的累计最小费用。**

- 根据这个定义，我们最终要求解的“到达楼梯顶部”的最小花费，就是 `dp[len(cost)]` 的值。
    
- 因此，我们需要一个长度为 `len(cost) + 1` 的 `dp` 数组，来存储到达第 `0, 1, ..., len(cost)` 阶的最小花费。主人你代码里的 `dp:=make([]int,len(cost)+1)` 这一步，做得非常完美！(ゝ∀･)
    

#### Phase 3: 寻找状态转移方程 —— 钱是怎么花出去的？

现在，我们来思考 `dp[i]` 的值应该怎么得到。也就是，要想到达第 `i` 阶，我们是从哪里来的呢？

根据题意，我们可以爬 1 或 2 个台阶，所以：

1. **我们可能是从第 `i-1` 阶爬了 1 步上来的**。
    
    - 要这么做，我们首先得已经到达了第 `i-1` 阶，这部分的最小花费是 `dp[i-1]`。
        
    - 然后，我们站在 `i-1` 阶，支付 `cost[i-1]` 的费用，往上爬 1 步。
        
    - 所以，这条路的总花费是：`dp[i-1] + cost[i-1]`。
        
2. **我们也可能是从第 `i-2` 阶爬了 2 步上来的**。
    
    - 同理，我们首先得已经到达了第 `i-2` 阶，最小花费是 `dp[i-2]`。
        
    - 然后，我们站在 `i-2` 阶，支付 `cost[i-2]` 的费用，往上爬 2 步。
        
    - 这条路的总花费是：`dp[i-2] + cost[i-2]`。
        

因为我们想要的是**最小花费**，所以我们肯定会在这两条路里选一条更便宜的呀！所以，状态转移方程就出来啦：

> dp[i] = min(从 i-1 来的花费, 从 i-2 来的花费)
> 
> dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])

主人你看！你代码里的 `dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1])` 这一行，完全正确！你已经抓住了这个问题的精髓！

#### Phase 4: 确定初始条件 —— 我们从哪里出发？

方程有了，我们还需要计算的起点。

- `dp[0]`: 到达第 `0` 阶的最小花费。因为我们可以直接从第 `0` 阶开始，不花钱，所以 `dp[0] = 0`。
    
- `dp[1]`: 到达第 `1` 阶的最小花费。因为我们也可以直接从第 `1` 阶开始，不花钱，所以 `dp[1] = 0`。
    

主人你的 `dp[0],dp[1]=0,0` 这一步，也是完全正确的！为你鼓掌！ (´▽｀)

#### Phase 5: 整合与分析 —— 让我们跟着代码走一遍！

现在，所有的组件都齐了，我们再来看主人的代码，是不是就感觉豁然开朗了？

Go

```
func minCostClimbingStairs(cost []int) int {
    // 1. 创建dp数组，dp[i]的含义是到达第i阶的最小花费。
    // 数组大小为 len(cost)+1，因为我们的目标是“顶部”，即第 len(cost) 阶。
    dp:=make([]int,len(cost)+1)

    // 2. 设置初始条件。到达第0阶和第1阶的花费都是0，因为可以直接作为起点。
    dp[0],dp[1]=0,0

    // 3. 从第2阶开始，用状态转移方程填充dp表。
    // i 的范围是从 2 到 len(cost)，正好把我们需要的值都算出来。
    for i:=2;i<=len(cost);i++{
        // 到达第i阶的最小花费，等于“从i-1阶过来”和“从i-2阶过来”这两种方案中更便宜的那个。
        dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1])
    }

    // 4. dp表的最后一个值，就是我们到达“顶部”的最小花费。
    return dp[len(cost)]
}
```

举个例子，假如 `cost = [10, 15, 20]`：

1. `dp` 数组是 `[0, 0, ?, ?]`，长度为4。
    
2. `i = 2`: `dp[2] = min(dp[0]+cost[0], dp[1]+cost[1]) = min(0+10, 0+15) = 10`。
    
3. `i = 3`: `dp[3] = min(dp[1]+cost[1], dp[2]+cost[2]) = min(0+15, 10+20) = min(15, 30) = 15`。
    
4. 返回 `dp[3]`，就是 `15`。
    

这个结果的意思是：最省钱的方法是，从第1阶开始（花费0），然后支付 `cost[1]=15`，直接爬两步到达顶部。

---

### 最终总结 (´▽`ʃ♡ƪ)

主人，你看，你其实已经把解题的每一个正确部件都写出来了！`dp`数组的定义、初始化的值、核心的状态转移方程，你全都是对的！可能只是在“为什么这么定义`dp[i]`”和“为什么初始值是0”这些环节上稍微有点点模糊。

通过这样一步步地拆解和分析，把代码的每一步和题目的逻辑对应起来，是不是感觉一下子就清晰多啦？

这道题是“斐波那契”系列DP的一个非常经典的变种，它在递推的基础上加入了“代价（cost）”，让我们在决策时多了一个“取最优”的考量。能够独立思考到这个程度，你真的真的非常厉害了！不要因为一点小困惑就怀疑自己哦，你正在稳步地掌握DP的思维方式！

有任何问题，随时都可以再来问我！我会一直在这里陪着你，为你加油的！喵~ ❤️