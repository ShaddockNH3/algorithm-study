喵呜~ 主人是遇到背包问题的小小挑战了吗？(｡･ω･｡)ﾉ♡ 不要担心哦，这可是动态规划里非常经典又有趣的问题呢！就像是小猫咪在面对一堆小鱼干，要怎么才能装满自己的小肚子，让自己最满足一样~ ♪ 学习新知识的过程，就像是在探索一个奇妙的宝藏，每一步都充满了惊喜。

别着急，我会一步一步，把完全背包问题的理论和用 Go 语言实现的笔记，都为你整理得清清楚楚、明明白白的。让我们一起开始吧！(´▽｀)

---

### **🎒 完全背包理论超详细笔记 (Go语言版) 🎒**

完全背包问题是经典的动态规划问题之一。它和我们熟悉的 0/1 背包问题非常相似，但有一个关键的区别。

#### **1. 问题描述**

我们有 N 种物品和一个容量为 V 的背包。每种物品都有无限件可用。

第 i 种物品的重量（或费用）是 `weight[i]`，价值是 `value[i]`。

我们需要解决的问题是：如何选择装入背包的物品，使得装入背包中物品的总价值最大，并且总重量不超过背包容量。

**和 0/1 背包的核心区别：**

- **0/1 背包**：每种物品**只有一件**，要么选，要么不选。
    
- **完全背包**：每种物品有**无限件**，可以选 0 件、1 件、2 件... 任意多件，只要总重量不超过背包容量。
    

---

#### **2. 核心思想 (动态规划)**

解决背包问题的核心就是动态规划 (Dynamic Programming, DP)。我们需要定义一个状态，然后找出状态转移方程。

- **状态定义**：`dp[i][j]` 表示从前 `i` 种物品中任意选择，放入一个容量为 `j` 的背包中所能获得的最大价值。
    
- 状态转移方程：
    
    当我们考虑第 i 件物品时，对于容量为 j 的背包，我们有两种选择：
    
    1. 不放入第 i 件物品：
        
        这种情况下，最大价值就等于只考虑前 i-1 件物品放入容量为 j 的背包中的最大价值。即 dp[i-1][j]。
        
    2. 放入第 i 件物品：
        
        因为每种物品有无限件，所以我们放入第 i 件物品后，还可以继续放入第 i 件物品。这和 0/1 背包不一样哦！
        
        当我们决定放入至少一件第 i 件物品时，背包的容量至少要大于等于 weight[i]。此时的价值，就等于放入这件物品所获得的价值 value[i]，加上为容量为 j - weight[i] 的背包继续从前 i 种物品中选择所能获得的最大价值。即 value[i] + dp[i][j - weight[i]]。
        
    
    综合以上两种情况，我们总是选择价值最大的那一种方案。所以状态转移方程就是：$$dp[i][j] = \\max(dp[i-1][j], \\quad dp[i][j - \\text{weight}[i]] + \\text{value}[i]) $$这个方程就是我们解决问题的关键哦~ ♪
    

---

#### **3. Go 语言实现 (二维数组)**

二维数组的实现方式最直观，完全对应了我们的状态定义 `dp[i][j]`。

**思路分析：**

1. 创建一个二维数组 `dp`，`dp[i][j]` 存储我们定义的状态。
    
2. 初始化 `dp` 数组。当背包容量为 0 时，什么都装不了，价值为 0。所以 `dp[i][0] = 0`。
    
3. 遍历物品 (外层循环)，再遍历背包容量 (内层循环)，根据状态转移方程填充 `dp` 数组。
    

**代码实现:**

Go

```
package main

import "fmt"

func completeKnapsack2D(weights []int, values []int, capacity int) int {
	numItems := len(weights)
	// dp[i][j] 表示从前 i 种物品中选择，放入容量为 j 的背包的最大价值
	// 为了方便处理索引，我们让 dp 数组的大小为 (numItems+1) x (capacity+1)
	dp := make([][]int, numItems+1)
	for i := range dp {
		dp[i] = make([]int, capacity+1)
	}

	// 遍历物品
	for i := 1; i <= numItems; i++ {
		weight := weights[i-1] // 当前物品的重量
		value := values[i-1]  // 当前物品的价值

		// 遍历背包容量
		for j := 1; j <= capacity; j++ {
			// 默认不选第 i 个物品，价值等于只看前 i-1 个物品的情况
			dp[i][j] = dp[i-1][j]

			// 如果当前背包容量可以容纳下当前物品
			if j >= weight {
				// 比较 "不选第 i 个物品" 和 "选第 i 个物品" 哪个价值更大
				// dp[i][j-weight] + value 表示：
				// 为容量为 j-weight 的背包，继续从前 i 个物品中选择
				dp[i][j] = max(dp[i][j], dp[i][j-weight]+value)
			}
		}
	}

	return dp[numItems][capacity]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	weights := []int{1, 3, 4}
	values := []int{15, 20, 30}
	capacity := 4

	maxValue := completeKnapsack2D(weights, values, capacity)
	fmt.Printf("使用二维数组解决完全背包问题，最大价值是：%d喵~\n", maxValue) // 输出: 60 (4个物品1)
}
```

---

#### **4. 空间优化 (一维数组)**

喵~ 你看，在二维的解法中，计算 `dp[i]` 这一行的值时，我们只用到了 `dp[i-1]` 和 `dp[i]` 自己这一行的值。这给了我们优化的空间哦！我们可以把二维数组压缩成一维数组，大大减少空间复杂度。

- **状态定义**：`dp[j]` 表示容量为 `j` 的背包所能获得的最大价值。
    
- 状态转移方程：
    
    当我们用一维数组时，内层循环遍历背包容量 j 需要从前往后（正序遍历）。
    
    为什么呢？让我们来看一看：
    
    dp[j] = max(dp[j], dp[j - weight] + value)
    
    当我们在计算 `dp[j]` 时，我们需要用到 `dp[j - weight]` 的值。因为我们是正序遍历的 (`j` 从小到大)，所以 `dp[j - weight]` 在 `dp[j]` 之前就已经被更新过了。这次更新是**基于放入了当前物品 `i` 之后的结果**。这恰好符合了我们完全背包的定义：一个物品可以被放入多次。
    
    这正是完全背包和 0/1 背包一维优化最大的区别！
    
    - **0/1 背包**：内层循环**倒序**遍历，保证计算 `dp[j]` 时，所依赖的 `dp[j - weight]` 还是上一轮（即还没放入物品 `i`）的状态。
        
    - **完全背包**：内层循环**正序**遍历，计算 `dp[j]` 时，`dp[j - weight]` 已经是本轮更新过的状态，相当于物品 `i` 已经被放入过了，可以继续放。
        

**代码实现:**

Go

```
package main

import "fmt"

func completeKnapsack1D(weights []int, values []int, capacity int) int {
	numItems := len(weights)
	// dp[j] 表示容量为 j 的背包所能获得的最大价值
	dp := make([]int, capacity+1)

	// 遍历物品
	for i := 0; i < numItems; i++ {
		weight := weights[i]
		value := values[i]

		// 遍历背包容量 (正序！)
		for j := weight; j <= capacity; j++ {
			dp[j] = max(dp[j], dp[j-weight]+value)
		}
	}

	return dp[capacity]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	weights := []int{1, 3, 4}
	values := []int{15, 20, 30}
	capacity := 4

	maxValue := completeKnapsack1D(weights, values, capacity)
	fmt.Printf("使用一维数组解决完全背包问题，最大价值是：%d呀♪\n", maxValue) // 输出: 60 (4个物品1)
}

```

关于遍历顺序的小小总结：

对于使用一维数组优化的背包问题：

- 如果外层遍历背包，内层遍历物品，是无法得到正确结果的。
    
- 如果外层遍历物品，内层遍历背包：
    
    - **0/1 背包**：内层**倒序**。
        
    - **完全背包**：内层**正序**。
        

这是因为遍历顺序决定了物品被放入的次数，非常关键哦！(๑•̀ㅂ•́)و✧

---

#### **5. 总结**

|特性|二维 DP 实现|一维 DP (空间优化)|
|---|---|---|
|**状态定义**|`dp[i][j]`：前 `i` 物品，容量 `j` 的最大价值|`dp[j]`：容量 `j` 的最大价值|
|**状态转移**|`dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]]+v[i])`|`dp[j] = max(dp[j], dp[j-w[i]]+v[i])`|
|**遍历顺序**|外层物品，内层背包（正序）|外层物品，内层背包（**正序！**）|
|**空间复杂度**|`O(N*V)`|`O(V)`|
|**时间复杂度**|`O(N*V)`|`O(N*V)`|

希望这份笔记能帮助主人更好地理解完全背包问题哦！如果还有不明白的地方，随时都可以再来问我，我会一直在这里陪着你的。加油喵~ (´,,•ω•,,)♡