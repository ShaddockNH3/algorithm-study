### **🧠 LeetCode 198. 打家劫舍 - 深度学习笔记 🧠**

- **题目链接**：[LeetCode 198. 打家劫舍](https://leetcode.cn/problems/house-robber/ "null")
    

#### **1. 我们的思考之旅：小偷的“选择困难症”**

当我们站在一排房子前，核心的困境在于，对于**每一间**房子，我们都面临一个抉择：

1. **偷这家！**
    
2. **不偷这家！**
    

这个“二选一”的特性，强烈地暗示了我们可以使用动态规划来寻找最优解。

##### **定义 DP 状态**

一个清晰的状态定义是解题的关键。我们可以定义 `dp[i]` 为：**从前 `i` 间房子 (`nums[0...i-1]`) 中，能够偷窃到的最高金额**。我们的最终目标就是求解 `dp[len(nums)]`。

##### **状态转移方程**

现在，我们来思考如何计算 `dp[i]`。这取决于我们对第 `i` 间房子（也就是 `nums[i-1]`）的决定：

- **情况一：不偷第 `i` 间房子** 如果我们放弃 `nums[i-1]`，那么我们能获得的最大金额，就等于从前 `i-1` 间房子里能偷到的最大金额。也就是 `dp[i-1]`。
    
- **情况二：偷第 `i` 间房子** 如果我们决定偷 `nums[i-1]`，根据规则，我们就不能偷和它相邻的第 `i-1` 间房子 (`nums[i-2]`)。所以，这次的收益等于 `nums[i-1]` 的金额，加上我们从前 `i-2` 间房子里能偷到的最大金额，也就是 `nums[i-1] + dp[i-2]`。
    

作为一个专业的小偷，我们当然会选择收益更高的那个方案！于是，状态转移方程就诞生了：  

dp[i]=max(dp[i−1],nums[i−1]+dp[i−2])

##### **主人的完美实现**

主人的代码，正是对这个思想的完美实现！你巧妙地将 `dp` 数组的索引向后移动了一位，使得 `dp[i+1]` 对应我们公式中的 `dp[i]`，从而让代码写起来非常顺畅：

```
// 主人的代码，逻辑清晰，几乎完美！
func rob(nums []int) int {
    // 处理一下 nums 为空的边界情况会更稳妥哦~
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums)+1)

    dp[0] = 0
    dp[1] = nums[0]

    // 这里的 dp[i+1] = max(dp[i], nums[i] + dp[i-1])
    // 正好对应了 dp[k] = max(dp[k-1], nums[k-1] + dp[k-2])
    for i := 1; i < len(nums); i++ {
        dp[i+1] = max(dp[i], nums[i]+dp[i-1])
    }

    return dp[len(nums)]
}

// max 函数需要自己实现
func max(a, b int) int {
    if a > b { return a }
    return b
}
```

这段代码真的非常棒，它准确地捕捉了问题的核心，并且逻辑清晰。唯一的瑕疵是当 `nums` 为空数组时，`nums[0]` 会导致程序崩溃，但这是一个很容易修正的小问题。

#### **2. 我的优化建议：空间压缩的“滚动数组”**

我们来观察一下状态转移方程 `dp[i] = max(dp[i-1], nums[i-1] + dp[i-2])`。 你会发现，我们每次计算 `dp[i]` 时，其实只用到了它前面的**两个**状态：`dp[i-1]` 和 `dp[i-2]`。那么，我们真的需要一个完整的 `dp` 数组来存储所有历史记录吗？

答案是不需要！我们可以用两个变量来“滚动”着记录前两个状态，把空间复杂度从 O(n) 优化到 O(1)！

```
// 空间优化版
func rob_optimized(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }

    // pre 代表 dp[i-2] 的值
    // curr 代表 dp[i-1] 的值
    pre, curr := 0, 0 
    
    // 我们直接遍历 nums 数组
    for _, num := range nums {
        // 计算当前房子的最优解
        // max(不偷这家(curr), 偷这家(num + pre))
        temp := max(curr, num + pre)
        // 更新记录，向前滚动
        pre = curr
        curr = temp
    }
    
    return curr
}
```

- **思路剖析**:
    
    - 我们用 `pre` 和 `curr` 两个变量，代替了 `dp[i-2]` 和 `dp[i-1]`。
        
    - 在每一次循环中，我们计算出当前房子的最优解 `temp`，然后把 `pre` 更新为旧的 `curr`，把 `curr` 更新为新的 `temp`，就像两条毛毛虫一样，一步一步向前滚动。
        
    - 这样，我们只用了常数级别的额外空间，就完成了整个动态规划的计算，是不是非常巧妙呀？♪
        

### **最终总结 (´▽`ʃ♡ƪ)**

这次的“打家劫舍”之旅，我们从一个清晰的 DP 定义出发，构建了几乎完美的标准解法，并最终通过“滚动数组”的思想，将其优化到了极致。这完美地展现了一条从“解题”到“优化”的完整学习路径。

主人你对 DP 问题的敏感度和建模能力真的越来越强了！为你感到无比的骄傲！我们继续加油，去探索更多算法世界的奥秘吧！喵~ ❤️