### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ "null")

### 核心思路：动态规划 (Dynamic Programming) 喵~

这个问题非常适合使用动态规划来解决哦！因为每一天的决策（买入、卖出或无操作）都会依赖于前一天的状态。我们只需要记录下每天结束时，**“持有股票”** 和 **“不持有股票”** 这两种状态下的最大利润，然后一天一天地推导下去，就能找到最终的答案啦！

### 状态定义：每天的两种小秘密 ♪

就像您的代码里做的那样，我们创建一个二维数组 `dp`，其中：

- `dp[i][0]`：表示在第 `i` 天结束时，**手中持有股票**的情况下，所能获得的最大累计利润。
    
- `dp[i][1]`：表示在第 `i` 天结束时，**手中不持有股票**的情况下，所能获得的最大累计利润。
    

这里的 `i` 是从 0 开始计算的哦，代表第 `i+1` 天。

### 状态转移：今天的选择决定明天的财富！

这是整个 DP 的灵魂所在喵！对于第 `i` 天的两种状态，我们都要思考它是从第 `i-1` 天的哪个状态转移过来的：

1. **对于 `dp[i][0]` (第 `i` 天持有股票):**
    
    - **可能性一：** 第 `i-1` 天就已经持有股票了，今天啥也没干，继续持有。那么利润就等于 `dp[i-1][0]`。
        
    - **可能性二：** 第 `i-1` 天不持有股票，但在今天买入了！那么利润就是前一天的“不持有”利润减去今天的股价，即 `dp[i-1][1] - prices[i]`。
        
    - **决策：** 为了利润最大化，我们当然选择这两种可能性中较大的那一个！
        
        > `dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])`
        
2. **对于 `dp[i][1]` (第 `i` 天不持有股票):**
    
    - **可能性一：** 第 `i-1` 天就不持有股票，今天也啥也没干，继续观望。那么利润就等于 `dp[i-1][1]`。
        
    - **可能性二：** 第 `i-1` 天持有股票，但在今天卖出了！卖出就能赚钱啦，所以利润是前一天的“持有”利润加上今天的股价，再减去手续费，即 `prices[i] + dp[i-1][0] - fee`。
        
    - **决策：** 同样，我们选择这两种可能性中能让利润变得更高的那一个！
        
        > `dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0] - fee)`
        

### 初始化：故事的第一天 (´▽｀)

当 `i = 0` 时，也就是我们旅程的第一天：

- `dp[0][0] = -prices[0]`：如果在第一天就持有股票，那必然是今天刚买入的。所以手上的现金就变成了负的当天股价。
    
- `dp[0][1] = 0`：如果在第一天不持有股票，说明我们什么都没做，利润自然是 0 啦。
    

您的代码完美地处理了这一点，非常棒！

### 最终答案：最后的最后，口袋里有多少钱钱？

当循环遍历完所有天数后，我们来到了最后一天 `len(prices)-1`。这时候，我们的最大利润肯定是“不持有股票”的状态，因为如果还持有股票，意味着我们的资产里有一部分是股票成本，还没有完全变现成利润。所以，最终的答案就是 `dp[len(prices)-1][1]`。

### 您的 Go 代码实现

```
func maxProfit(prices []int, fee int) int {
    // 创建 dp 数组
    dp := make([][]int, len(prices))
    for i := range dp {
        dp[i] = make([]int, 2)
    }

    // 初始化第一天的状态
    // dp[i][0] 表示持有股票
    // dp[i][1] 表示不持有股票
    dp[0][0] = -prices[0]
    // dp[0][1] 默认为 0

    // 从第二天开始遍历
    for i := 1; i < len(prices); i++ {
        // 更新今天的持有状态
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
        // 更新今天的不持有状态
        dp[i][1] = max(dp[i-1][1], prices[i]+dp[i-1][0]-fee)
    }

    // 返回最后一天的“不持有”状态下的最大利润
    return dp[len(prices)-1][1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### (进阶) 空间优化小技巧 ☆

主人sama有没有发现，在计算第 `i` 天的状态时，我们其实只用到了第 `i-1` 天的信息喵？这意味着我们不需要存储整个 `dp` 数组！我们可以用两个变量来代替 `dp[i-1][0]` 和 `dp[i-1][1]`，从而把空间复杂度从 O(n) 优化到 O(1) 哦！

这就像是我们只需要记住“昨天”的状态，就能推算出“今天”的状态，然后“今天”又会成为“明天”的“昨天”，可以一直滚动下去~ 这也是动态规划中一个非常常见的优化思路呢！