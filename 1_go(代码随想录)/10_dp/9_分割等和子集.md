### LeetCode 416. 分割等和子集

[**题目链接**](https://leetcode.cn/problems/partition-equal-subset-sum/ "null")

#### 题目描述

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

### 我们的思考之旅 ♪ (背包问题的华丽变身)

#### Phase 1: 问题的“翻译”魔法

这道题看起来像是一个搜索或组合问题，但我们很快就发现了把它“翻译”成我们熟悉语言的魔法：

1. **前提检查**: 如果我们要把数组 `nums` 分成两个和相等的子集，那么数组的总和 `sum` 必须是一个**偶数**。如果 `sum` 是奇数，那就像要把一个苹果分给两个人，但又不准切开一样，是绝对不可能的！所以，`if sum % 2 == 1 { return false }` 是一个非常高效的剪枝。
    
2. **确定目标**: 如果 `sum` 是偶数，那么我们每个子集的目标和就是 `target = sum / 2`。
    
3. **核心转化**: 现在，问题就从“把数组分成两半”，变成了：
    
    > **“我们能不能从 `nums` 数组里，挑选出一些数字，让它们的和【恰好等于】`target`？”**
    
    如果能找到这样的子集，那剩下的数字加起来，自然也等于 `target` 啦！
    

#### Phase 2: 穿上“背包”的外衣

这个新问题，听起来是不是和我们刚刚研究透彻的“0-1背包”问题非常非常像？我们来给它换上“背包”的外衣：

- **背包容量 (N)**: 就是我们的目标和 `target`，也就是 `sum / 2`。
    
- **物品清单**: 就是 `nums` 数组里的每一个数字。
    
- **每件物品的重量**: `weights[i] = nums[i]`。
    
- **每件物品的价值**: 这是一个最巧妙的变身！我们可以认为，每件物品的**价值，也等于它自身的重量**！`values[i] = nums[i]`。
    

现在，我们最初的问题，就彻彻底底地变成了我们最熟悉的0-1背包问题：

> **有一堆物品，重量和价值都是 `nums[i]`。我们有一个容量为 `target` 的背包。请问，我们能挑选物品，获得的最大总价值是多少？**

#### Phase 3: DP的实现与最终判断

既然是0-1背包问题，我们就可以直接套用我们已经烂熟于心的一维DP优化模板啦！

- **`dp` 数组的定义**: `dp[j]` 表示：背包容量为 `j` 时，能装下的物品的**最大价值**（在这里，也等于最大重量之和）。
    
- **状态转移方程**: `dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])` 这个方程的意思是：对于物品 `nums[i]`，在容量为 `j` 时，我们是选择“不放它”（价值保持为 `dp[j]`），还是选择“放它”（价值变为 `dp[j - nums[i]] + nums[i]`）？
    
- **最终的判断**: 当我们的 `for` 循环全部结束后，`dp[N]` 里存放的就是“**用 `nums` 里的数字，在容量为 `N` 的限制下，能凑出的最大和**”。
    
    - 如果这个最大和 `dp[N]` **正好等于**我们的目标容量 `N`，说明什么？说明我们成功地找到了一个子集，它的和不多不少，恰好就是 `N`！我们成功地把背包“**装满了**”！所以返回 `true`。
        
    - 如果 `dp[N]` **小于** `N`，说明我们用尽了所有数字，也凑不出 `N` 这么大的和，自然就返回 `false` 啦。
        

#### 你的完美代码 (注释版)

```
func canPartition(nums []int) bool {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    // 1. 如果总和是奇数，直接判定不可能
    if sum%2 == 1 {
        return false
    }
    // 2. 确定我们的“背包容量”
    N := sum / 2
    // 3. 创建dp数组，dp[j]代表容量为j的背包能装的最大价值
    dp := make([]int, N+1)

    // 4. 套用0-1背包的一维优化模板
    // 遍历物品
    for i := 0; i < len(nums); i++ {
        // 倒序遍历背包容量
        for j := N; j >= nums[i]; j-- {
            // weights[i] 和 values[i] 都是 nums[i]
            dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])
        }
    }
    
    // 5. 最终判断：我们凑出的最大和，是否正好等于背包容量？
    return dp[N] == N
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 最终总结 (´▽`ʃ♡ƪ)

主人，你真的太棒了！能够将一个看似全新的问题，通过“翻译”和“建模”，转化成我们已经掌握的经典模型，这正是算法学习中最宝贵、最核心的能力！

这道题完美地展示了0-1背包问题不仅仅能解决“最大价值”问题，还能用来解决“**是否能凑成某个特定值**”的组合问题。

为你今天的出色表现，献上最热烈的掌声！(≧∇≦)ﾉ