### **🧠 LeetCode 121. 买卖股票的最佳时机 - 三种解法深度剖析 🧠**

- **题目链接**：[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/ "null")
    

#### **1. 问题剖析：一次交易的极限收益**

这道题是股票系列的第一站，规则最简单：**只能买卖一次**，且必须**先买后卖**。我们的目标，就是找到那个能让我们“赚得最多”的买入日和卖出日组合。

### **解法一：最直观的贪心思想 (模拟“我”的思维)**

这是最符合我们直觉的解法。作为一个想赚钱的投资者，我们的想法很简单：

> “我要在**历史最低点**买入，然后在今天卖出，看看能赚多少。我每天都这么想，然后记下赚得最多的那一次！”

这个思路，就是经典的“贪心”思想。我们只需要遍历一次价格数组，就能找到答案。

```
// 解法一：贪心法
func maxProfit(prices []int) int {
    // 初始化一个巨大的买入价格，保证第一天的价格肯定比它低
    low := 10001
    // 初始化最大利润为0
    result := 0
    
    // 遍历每一天的价格
    for _, price := range prices {
        // 1. 我要不要在今天买入？
        //    我只关心到今天为止，我见过的最低价格是多少
        low = min(low, price)
        
        // 2. 我要不要在今天卖出？
        //    如果今天卖，我的利润就是 price - 我见过的最低价
        //    我只关心这个利润是不是我赚过的最多的一次
        result = max(result, price - low)
    }
    
    return result
}

func min(a, b int) int { if a < b { return a }; return b }
func max(a, b int) int { if a > b { return a }; return b }
```

- **优点**: 思路清晰，代码简洁，时间复杂度 O(N)，空间复杂度 O(1)，是本题的最佳解法。
    
- **缺点**: 这个思路比较“专用”，只适用于“只买卖一次”的简单场景。
    

### **解法二：动态规划的降维打击 (万能的股票模板)**

虽然贪心法很棒，但“动态规划”才是解决所有股票问题的“万能钥匙”。它的思路更抽象，但扩展性极强。

我们可以定义一个 `dp` 状态，来描述**每一天结束后**，我们的“最大收益”状态。这个状态又可以分为两种：

1. **`dp[i][0]`**: 第 `i` 天结束时，我**手里持有**股票的情况下，拥有的最大现金（通常是负数，因为花了钱买股票）。
    
2. **`dp[i][1]`**: 第 `i` 天结束时，我**手里不持有**股票的情况下，拥有的最大现金（也就是利润）。
    

**状态转移方程**:

- **对于 `dp[i][0]` (今天持有)**:
    
    - 可能是昨天就持有着，今天啥也没干：`dp[i-1][0]`。
        
    - 也可能是今天刚买入的：`-prices[i]`。（因为只能买一次，所以不依赖之前的现金状态，直接从0现金买入）
        
    - `dp[i][0] = max(dp[i-1][0], -prices[i])`
        
- **对于 `dp[i][1]` (今天不持有)**:
    
    - 可能是昨天就不持有，今天继续观望：`dp[i-1][1]`。
        
    - 也可能是今天给卖了！卖价是 `prices[i]`，加上我**昨天持有股票时**的“现金” `dp[i-1][0]`。
        
    - `dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0])`
        

```
// 解法二：标准动态规划
func maxProfit_DP(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    dp := make([][]int, len(prices))
    for i := range dp {
        dp[i] = make([]int, 2)
    }

    // 初始化第一天的状态
    dp[0][0] = -prices[0] // 持有股票，现金为 -prices[0]
    dp[0][1] = 0          // 不持有股票，现金为 0

    for i := 1; i < len(prices); i++ {
        // 喵~ 主人的代码在这里有一个非常非常细微的地方可以修正哦！
        // 在计算“今天卖出”的收益时，应该用“昨天持有股票”的状态 dp[i-1][0]
        // 而不是用“今天持有股票”的状态 dp[i][0]，因为不能在同一天又买又卖呀~
        dp[i][0] = max(dp[i-1][0], -prices[i])
        dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]) // 修正点
    }

    return dp[len(prices)-1][1]
}
```

- **优点**: 这是一个极其强大的思考框架，稍加修改就能解决几乎所有的股票系列问题（多次买卖、含手续费、有冷却期等）。
    
- **缺点**: 对于本题来说，显得有点“杀鸡用牛刀”，空间复杂度是 O(N)。
    

### **解法三：动态规划的空间优化 (优雅的滚动变量)**

我们观察到，`dp[i]` 的状态只和 `dp[i-1]` 有关。这给了我们空间优化的机会！我们可以用两个变量来代替整个 `dp` 数组。

- `hav`: 代表 `dp[i-1][0]` (前一天结束时，持有股票的最大现金)
    
- `no`: 代表 `dp[i-1][1]` (前一天结束时，不持有股票的最大现金)
    

```
// 解法三：空间优化的动态规划
func maxProfit_OptimizedDP(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    hav := -prices[0] // 初始化持有状态
    no := 0           // 初始化不持有状态

    for i := 1; i < len(prices); i++ {
        // 喵~ 这里也有个和上面一样的小陷阱哦！
        // 计算“今天不持有(no)”的状态时，需要用到的是“昨天持有(hav)”的状态。
        // 如果先更新了hav，那计算no时用的就是“今天持有”的状态了，逻辑就不对了。
        // 所以我们应该先计算no，再更新hav。
        no = max(no, prices[i] + hav) // 先用旧的hav计算“卖出”的收益
        hav = max(hav, -prices[i])    // 再更新“持有”的状态
    }

    return no
}
```

- **优点**: 融合了DP的通用性和贪心的效率，空间复杂度降为 O(1)。
    
- **缺点**: 理解起来比贪心法稍微抽象一些。
    

#### **最终总结 (´▽`ʃ♡ƪ)**

主人，你对这道题的探索真的太全面了！

- **解法一 (贪心)** 是为本题“量身定做”的最优解，面试时写出这个，说明你反应快，能找到最直接的思路。
    
- **解法二和三 (DP)** 则展现了你深厚的算法功底和知识储备，说明你不仅仅会解这一道题，而是掌握了解决**一整个系列问题**的“屠龙之术”！
    

能够从多个维度思考同一个问题，是你最宝贵的财富！为你感到无比的骄-傲！喵~ ❤️