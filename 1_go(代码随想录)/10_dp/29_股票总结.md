### LeetCode 股票买卖问题系列总结篇！

Hello，各位在算法海洋中遨游的小伙伴们！这里是股票系列的最终总结篇章~ 我们将从最简单的一笔交易，逐步深入到包含手续费、冷冻期、交易次数限制等各种复杂情况，用动态规划这一强大的武器，彻底征服它们！

### 动态规划：核心思想

对于股票问题，我们每一天的决策都只与前一天的状态有关，这正是动态规划大显身手的绝佳舞台。我们的核心思路是定义出每一天可能处于的**状态**，然后找出从前一天到今天，这些状态之间是如何**转移**的。

通常，最核心的状态无非两种：

- **`持有股票`**
    
- **`不持有股票`**
    

所有的复杂问题，都是在这两个基本状态上进行扩展和变化的哦！

### 1. [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/ "null")

**题目核心：** 只能买卖一次，求最大利润。

#### 【贪心解法】

这是最直观的思路：我们遍历整个价格数组，同时记录下到目前为止遇到的**最低价格** (`minPrice`)。对于每一天的价格，我们都计算一下在今天卖出能获得多少利润 (`prices[i] - minPrice`)，然后更新我们的最大利润记录。

```
// 贪心算法
func maxProfit_121_greedy(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    minPrice := prices[0]
    maxProfit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] < minPrice {
            minPrice = prices[i]
        } else if prices[i] - minPrice > maxProfit {
            maxProfit = prices[i] - minPrice
        }
    }
    return maxProfit
}
```

#### 【动态规划】

- `dp[i][0]`：第 `i` 天**持有**股票所得最大现金。
    
- `dp[i][1]`：第 `i` 天**不持有**股票所得最大现金。
    

**状态转移：**

- `dp[i][0]`:
    
    - 昨天就持有：`dp[i-1][0]`
        
    - 今天才买入（因为只能买一次，所以现金就是 `-prices[i]`）
        
    - `dp[i][0] = max(dp[i-1][0], -prices[i])`
        
- `dp[i][1]`:
    
    - 昨天就不持有：`dp[i-1][1]`
        
    - 今天卖出了：`dp[i-1][0] + prices[i]`
        
    - `dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])`
        

```
// 动态规划
func maxProfit_121_dp(prices []int) int {
    n := len(prices)
    if n == 0 {
        return 0
    }
    dp := make([][2]int, n)
    dp[0][0] = -prices[0]
    dp[0][1] = 0
    for i := 1; i < n; i++ {
        dp[i][0] = max(dp[i-1][0], -prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])
    }
    return dp[n-1][1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 2. [122. 买卖股票的最佳时机II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/ "null")

**题目核心：** 可以无限次买卖，求最大利润。

#### 【贪心解法】

因为可以无限次交易，所以只要第二天的价格比第一天高，我们就可以在前一天买入、第二天卖出，把所有上涨区间的利润都“吃”到。

```
// 贪心算法
func maxProfit_122_greedy(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}
```

#### 【动态规划】

状态定义同上，但转移方程有细微但关键的区别：

- `dp[i][0]`:
    
    - 昨天就持有：`dp[i-1][0]`
        
    - 今天才买入：因为可以多次交易，所以今天买入时，本金是**昨天不持有股票时的现金**，即 `dp[i-1][1] - prices[i]`。
        
    - `dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])`
        
- `dp[i][1]`:
    
    - 昨天就不持有：`dp[i-1][1]`
        
    - 今天卖出了：`dp[i-1][0] + prices[i]`
        
    - `dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])`
        

```
// 动态规划
func maxProfit_122_dp(prices []int) int {
    n := len(prices)
    if n == 0 {
        return 0
    }
    dp := make([][2]int, n)
    dp[0][0] = -prices[0]
    dp[0][1] = 0
    for i := 1; i < n; i++ {
        // 这里的 dp[i-1][1] - prices[i] 是与 121 题唯一的不同
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]) 
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])
    }
    return dp[n-1][1]
}
```

### 3. [123. 买卖股票的最佳时机III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/ "null")

**题目核心：** 最多买卖两次。

#### 【动态规划】

这是对状态的第一次大扩展！我们需要定义更多的状态来追踪交易次数。

- `dp[i][0]`：无操作
    
- `dp[i][1]`：第一次买入
    
- `dp[i][2]`：第一次卖出
    
- `dp[i][3]`：第二次买入
    
- `dp[i][4]`：第二次卖出
    

**状态转移：**

- `dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])` (第一次买入)
    
- `dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])` (第一次卖出)
    
- `dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])` (第二次买入)
    
- `dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])` (第二次卖出)
    

```
func maxProfit_123_dp(prices []int) int {
    n := len(prices)
    if n == 0 {
        return 0
    }
    // dp 数组大小为 5，索引含义如下：
    // 0: 无操作
    // 1: 第一次买入
    // 2: 第一次卖出
    // 3: 第二次买入
    // 4: 第二次卖出
    dp := make([][5]int, n)
    dp[0][1] = -prices[0]
    dp[0][3] = -prices[0]

    for i := 1; i < n; i++ {
        dp[i][0] = dp[i-1][0]
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
        dp[i][2] = max(dp[i-1][2], dp[i-1][1]+prices[i])
        dp[i][3] = max(dp[i-1][3], dp[i-1][2]-prices[i])
        dp[i][4] = max(dp[i-1][4], dp[i-1][3]+prices[i])
    }
    return dp[n-1][4]
}
```

### 4. [188. 买卖股票的最佳时机IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/ "null")

**题目核心：** 最多买卖 `k` 次。

这是上一题的通用版本。我们把状态数组扩展到 `2*k+1` 的大小。

- `dp[i][j]`：第 `i` 天，处于状态 `j` 的最大现金。
    
- `j` 为奇数时 (`2m-1`)：表示第 `m` 次买入。
    
- `j` 为偶数时 (`2m`)：表示第 `m` 次卖出。
    

**状态转移：**

- `dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - prices[i])` (j为奇数，买入)
    
- `dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i])` (j为偶数，卖出)
    

```
func maxProfit_188_dp(k int, prices []int) int {
    n := len(prices)
    if n == 0 {
        return 0
    }
    // 状态数组大小为 2*k+1
    dp := make([][]int, n)
    for i := range dp {
        dp[i] = make([]int, 2*k+1)
    }

    // 初始化第一天的所有买入状态
    for j := 1; j < 2*k; j += 2 {
        dp[0][j] = -prices[0]
    }

    for i := 1; i < n; i++ {
        for j := 0; j < 2*k-1; j += 2 {
            // j+1 是奇数，买入状态
            dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j]-prices[i])
            // j+2 是偶数，卖出状态
            dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1]+prices[i])
        }
    }
    return dp[n-1][2*k]
}
```

### 5. [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/ "null")

**题目核心：** 无限次交易，但卖出后有一天冷冻期。

冷冻期引入了新的状态限制。我们需要更精细地划分“不持有”的状态。

- `dp[i][0]`：**持有**股票状态。
    
- `dp[i][1]`：**不持有**股票状态，且**不在**冷冻期。（可以随时买入）
    
- `dp[i][2]`：**不持有**股票状态，且**处于**冷冻期。（今天刚卖出）
    

**状态转移：**

- `dp[i][0]`:
    
    - 昨天就持有：`dp[i-1][0]`
        
    - 今天买入（必须是昨天不在冷冻期）：`dp[i-1][1] - prices[i]`
        
    - `dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])`
        
- `dp[i][1]`:
    
    - 昨天就不在冷冻期：`dp[i-1][1]`
        
    - 昨天在冷冻期，今天解冻了：`dp[i-1][2]`
        
    - `dp[i][1] = max(dp[i-1][1], dp[i-1][2])`
        
- `dp[i][2]`:
    
    - 今天卖出了（昨天必须持有）：`dp[i-1][0] + prices[i]`
        
    - `dp[i][2] = dp[i-1][0] + prices[i]`
        

```
func maxProfit_309_dp(prices []int) int {
    n := len(prices)
    if n == 0 {
        return 0
    }
    dp := make([][3]int, n)
    // dp[i][0]: 持有
    // dp[i][1]: 不持有，非冷冻期
    // dp[i][2]: 不持有，冷冻期
    dp[0][0] = -prices[0]

    for i := 1; i < n; i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][2])
        dp[i][2] = dp[i-1][0] + prices[i]
    }
    // 最后一天不持有股票的最大利润，可能来自非冷冻期或冷冻期
    return max(dp[n-1][1], dp[n-1][2])
}
```

### 6. [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ "null")

**题目核心：** 无限次交易，但每次卖出要支付手续费。

这个问题和第 122 题（无限次交易）几乎一模一样，唯一的区别就是在卖出时，利润要减去手续费 `fee`。

**状态转移：**

- `dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])`
    
- `dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee)` (这里减去手续费)
    

```
func maxProfit_714_dp(prices []int, fee int) int {
    n := len(prices)
    if n == 0 {
        return 0
    }
    dp := make([][2]int, n)
    dp[0][0] = -prices[0]

    for i := 1; i < n; i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]-fee)
    }
    return dp[n-1][1]
}
```

### 最终总结喵~

至此，股票系列就完美收官啦！我们从最基础的单次交易，一步步添加了**交易次数**、**冷冻期**、**手续费**等约束，最终发现它们万变不离其宗，都可以用**动态规划**的思路，通过**定义状态**和**寻找状态转移方程**来优雅地解决。

希望这篇总结能像一盏明灯，照亮主人sama在算法学习道路上的每一步！您真的非常棒，为您鼓掌！(ﾉ´ヮ´)ﾉ*:･ﾟ✧