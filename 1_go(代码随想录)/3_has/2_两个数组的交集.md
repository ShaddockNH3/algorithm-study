喵~ 主人你好呀！(｡･ω･｡)ﾉ♡

你把这两道“求交集”的题目放在一起对比学习，真的太聪明啦！它们就像一对双胞胎，长得很像，但性格（要求）却有一点点小小的不同。搞清楚它们的区别，对我们理解哈希表的灵活运用非常有帮助！

我这就帮你把这两道题和你写的优秀代码，整理成一份详细的专题笔记，让它们的“小秘密”都一目了然！

---

### **数组交集专题：从“有没有”到“有多少”的奇妙变身 🪄**

这两道题目的核心区别在于：

- **第 349 题**：要求的是**纯粹的、不重复的交集**。就像问：“你们两家都有苹果吗？” 只要回答“有”就行，不关心有几个。这是 **`Set`** 的思想。
    
- **第 350 题**：要求的是**考虑数量的交集**。就像问：“你家的两个苹果和我们家的三个苹果，能凑出几对来？” 这时数量就很重要了。这是 **`频率计数`** 的思想。
    

下面我们来看看，这两种不同的需求是如何通过哈希表演绎出来的吧！

---

#### **[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)**

> 给定两个数组 `nums1` 和 `nums2` ，返回 _它们的 交集_ 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

**核心要求**：找出独一无二的交集元素。

**你的优秀代码：**

Go

```
func intersection(nums1 []int, nums2 []int) []int {
	set := make(map[int]struct{})
	for _, num := range nums1 {
		set[num] = struct{}{}
	}

	result_set := make(map[int]struct{})
	for _, num := range nums2 {
		if _, ok := set[num]; ok {
			result_set[num] = struct{}{}
		}
	}

	ans := make([]int, 0, len(result_set))
	for num := range result_set {
		ans = append(ans, num)
	}

	return ans
}
```

思路喵~

这个解法非常标准和优雅，完美地体现了 Set 的思想！

1. **建立登记表 (Set)**：我们先遍历 `nums1`，用 `map[int]struct{}` 创建一个集合 `set`。`struct{}` 是一个零内存占用的空结构体，是 Go 中实现集合的专业手法。这一步的目的是把 `nums1` 中所有出现过的数字都“登记”下来，并且自动去重。
    
2. **查询并记录**：然后遍历 `nums2`，对于 `nums2` 中的每一个数字，我们都去 `set` 这个“登记表”里查一下 (`if _, ok := set[num]; ok`)。如果查到了，说明这个数字是公共的。
    
3. **确保结果唯一**：为了防止 `nums2` 中的重复元素导致结果也重复（比如 `nums1=[2], nums2=[2,2]`），我们把找到的交集元素放进另一个 `result_set` 中，利用 `map` 的 `key` 唯一性，确保了最终结果也是不重复的。
    
4. **转换输出**：最后，把 `result_set` 里的所有 `key` 拿出来，就是我们的答案啦！
    

---

#### **[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)**

> ...输出结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。

**核心要求**：找出可重复的交集元素，数量以两个数组中较少的为准。

**你的优秀代码：**

Go

```
func intersect(nums1 []int, nums2 []int) []int {
    hasmap1:=make(map[int] int)
    
    for _,num:=range nums1{
        hasmap1[num]+=1
    }

    ans:=[]int{}

    for _,num:=range nums2{
        // 检查 num 在 hasmap1 中是否存在，并且数量 > 0
        if _,ok:=hasmap1[num]; ok && hasmap1[num]>0{
            // 如果满足条件，就将库存减一
            hasmap1[num]-=1
            // 并将该元素加入结果
            ans=append(ans,num)
        }
    }
    return ans
}
```

思路喵~

这个问题需要计数，所以我们的魔法工具从“集合”升级成了“频率计数器” map[int]int！

1. **盘点库存**：我们遍历 `nums1`，用 `hasmap1` 记录下其中每个数字出现的次数。这就像在盘点我们的“仓库库存”。
    
2. **处理订单**：然后遍历 `nums2`，把 `nums2` 看作一份“客户订单”。对于订单上的每一个商品（数字 `num`）：
    
    - 我们去仓库 `hasmap1` 里查看。
        
    - 如果发现这个商品**还有库存** (`hasmap1[num] > 0`)，太棒了！我们成功匹配了一个。
        
    - 我们把这个商品加入最终的“发货包裹” `ans` 中，并且**把仓库里的库存减一** (`hasmap1[num]-=1`)。
        
3. **完成**：遍历完订单 `nums2`，发货包裹 `ans` 里的东西就是我们想要的交集啦！
    

#### **关于进阶问题的思考**

- **如果数组已排序？**
    
    - 用**双指针法**！两个指针分别指向两个数组的开头，同步向后移动比较，这是最优解。
        
- **如果 `nums1` 比 `nums2` 小？**
    
    - 用**哈希表法**，并且用**较小的 `nums1` 来构建哈希表**，这样可以节省内存空间。
        
- **如果 `nums2` 在磁盘上？**
    
    - 如果 `nums1` 能放入内存，就用 `nums1` 构建哈希表，然后分块读取 `nums2` 来比较。
        
    - 如果 `nums1` 也很大，就需要先对两个大文件进行“外部排序”，然后用双指针法分块读取比较。
        

---

### **总结一下喵~ 💖**

|问题|核心要求|魔法工具|关键操作|
|---|---|---|---|
|**349. 交集**|结果**唯一**，不重复|`map[int]struct{}` (集合)|检查 `key` 是否**存在**|
|**350. 交集 II**|结果可**重复**，次数匹配|`map[int]int` (频率图)|检查 `key` 对应的**计数值**|

主人你已经能清晰地根据题意，选择并正确地使用不同的哈希表策略了，这说明你的内功又精进了不少！为你感到骄傲！(ﾉ´ヮ`)ﾉ*:･ﾟ✧