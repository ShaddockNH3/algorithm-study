喵~ 主人你好呀！(｡･ω･｡)ﾉ♡

看见你把和“字母异位词”相关的题目都整理在了一起，我真的太佩服你了！这是一个非常棒的学习方法，把同一类型的题目放在一起“串烧”，可以帮助我们发现它们之间共通的“灵魂”，以后再遇到类似的题目，就能一眼看穿啦！

你选的这几道题，从易到难，完美地覆盖了“字母异位词”的各种经典考法。而你写的每一份代码，都精准地抓住了解决这类问题的核心魔法——**计数**！

为了表扬这么努力的你，我这就帮你把这些宝贵的学习成果，整理成一份超级详细的《字母异位词专题笔记》，我们开始吧！

---

### **字母异位词专题：用“计数魔法”征服字符串问题 🪄**

#### **核心思想：什么是字母异位词？**

两段字符串互为“字母异位词”（Anagram），本质上是说它们含有的 **每种字母的数量都完全相同**，只是排列顺序不同而已。

比如 `"anagram"` 和 `"nagaram"`，它们都含有：

- `a`: 3个
    
- `g`: 1个
    
- `m`: 1个
    
- `n`: 1个
    
- `r`: 1个
    

既然如此，解决这类问题的核心就是去 **比较它们的“字母成分表”** 是不是一模一样。

#### **我们的魔法工具：计数器数组**

因为这些题目都限定了“仅包含小写字母”，所以我们可以用一个非常高效的工具来制作“字母成分表”——一个长度为 26 的整数数组 `[26]int`。

- `array[0]` 存 `'a'` 的数量
    
- `array[1]` 存 `'b'` 的数量
    
- ...
    
- `array[25]` 存 `'z'` 的数量
    

我们可以通过 `字符 - 'a'` 这个小技巧，快速地把一个字母映射到数组的索引上。

现在，我们来看看这个魔法工具在不同题目里是如何大显神威的吧！

---

#### **[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)**

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词。
> 
> 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

**你的优秀代码：**

Go

```
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}

	ans := make([]int, 26)

	for i := 0; i < len(s); i++ {
		ans[s[i]-'a']++
	}

	for i := 0; i < len(t); i++ {
		ans[t[i]-'a']--
	}

	for _, dig := range ans {
		if dig != 0 {
			return false
		}
	}

	return true
}
```

思路喵~

这是最直接的应用！

1. 先检查长度，如果长度不同，直接淘汰！
    
2. 创建一个 26 格的“计数器”`ans`。
    
3. 遍历字符串 `s`，把遇到的每个字母对应的格子**加一**。
    
4. 遍历字符串 `t`，把遇到的每个字母对应的格子**减一**。
    
5. 如果 `s` 和 `t` 是异位词，那么一加一减之后，计数器 `ans` 的每一格都应该正好变回 0。我们最后检查一遍就好啦！
    

关于进阶问题：

如果包含 Unicode 字符（比如中文、emoji），[26]int 数组就不够用啦！这时，我们就需要一个更强大的“成分表”——真正的哈希表 map[rune]int，rune 类型可以代表任意一个 Unicode 字符。原理还是一样，只是工具升级了！

---

#### **[383. 赎金信](https://leetcode.cn/problems/ransom-note/)**

> 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。

**你的优秀代码：**

Go

```
func canConstruct(ransomNote string, magazine string) bool {
	if len(ransomNote) > len(magazine) {
		return false
	}

	ans := make([]int, 26)
    // 你的这个写法非常巧妙！
    // 先把需要的字符（负数）记录下来
	for i := 0; i < len(ransomNote); i++ {
		index := ransomNote[i] - 'a'
		ans[index]--
	}

    // 再用杂志里的字符去“偿还”
	for j := 0; j < len(magazine); j++ {
		index := magazine[j] - 'a'
		ans[index]++
	}

    // 最后检查是不是所有“债务”都还清了（没有负数）
	for _, cnt := range ans {
		if cnt < 0 {
			return false
		}
	}
	return true
}
```

思路喵~

这道题是异位词的一个小变种，它不要求“成分”完全一样，只要求 magazine 的“成分”能完全覆盖 ransomNote 的“成分”。

可以把它想象成一个“资源管理”游戏：

1. `ransomNote` 是你的“需求清单”。
    
2. `magazine` 是你的“材料仓库”。
    
3. 我们先遍历“需求清单”，在计数器上记下我们需要哪些材料（比如 `ans[0]--` 表示需要一个 'a'）。
    
4. 然后我们遍历“材料仓库”，把我们有的材料加回到计数器上（`ans[0]++` 表示我们找到了一个 'a'）。
    
5. 最后检查计数器，如果还有任何一个格子的数是**小于 0** 的，就说明我们的材料不够，无法满足需求！
    

---

#### **[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)**

> 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

**你的优秀代码：**

Go

```
func groupAnagrams(strs []string) [][]string {
	hasmap := make(map[[26]int][]string)
	for _, str := range strs {
		key := [26]int{}
		for _, c := range str {
			key[c-'a'] += 1
		}
		hasmap[key] = append(hasmap[key], str)
	}

	ans := make([][]string, 0, len(hasmap))
	for _, value := range hasmap {
		ans = append(ans, value)
	}
	return ans
}
```

思路喵~

这道题是对我们“计数魔法”的创造性应用！

1. 我们为每一个字符串，都制作一份独一无二的“**成分表**”（也就是那个 `[26]int` 数组）。
    
2. 最最神奇的一步是，我们把这份“成分表”本身，当作一个大的哈希表 `hasmap` 的 **key**！
    
3. 因为所有互为异位词的字符串，它们的“成分表”是**一模一样**的，所以它们都会被映射到 `hasmap` 的同一个 `key` 下。
    
4. 我们把原始字符串 `str` `append` 到它对应“成分表” `key` 的那个分组（一个 `[]string` 切片）里。
    
5. 最后，把 `hasmap` 里的所有分组取出来，就完成了任务！
    

---

#### **[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)**

> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。

**你的优秀代码：**

Go

```
func findAnagrams(s string, p string) []int {
    if len(s) < len(p) {
        return []int{}
    }

    ans := []int{}
    var array_p, array_s [26]int
    
    // 1. 初始化第一个窗口
    for i := 0; i < len(p); i++ {
        array_p[p[i]-'a']++
        array_s[s[i]-'a']++
    }

    // 2. 比较第一个窗口
    if array_s == array_p {
        ans = append(ans, 0)
    }

    // 3. 开始滑动窗口
    for i := len(p); i < len(s); i++ {
        // 新字符进入窗口
        array_s[s[i]-'a']++
        // 旧字符滑出窗口
        array_s[s[i-len(p)]-'a']--

        // 比较当前窗口
        if array_s == array_p {
            ans = append(ans, i-len(p)+1)
        }
    }

    return ans
}
```

思路喵~

这道题是“计数魔法”和“滑动窗口”的完美结合！

1. 我们不再是比较整个字符串，而是在长字符串 `s` 上维护一个和 `p` 等长的“滑动窗口”。
    
2. 我们同样需要两份“成分表”：一份是目标 `p` 的 `array_p`，另一份是当前窗口 `s` 的 `array_s`。
    
3. 先初始化第一个窗口，并进行比较。
    
4. 然后开始“滑动”，每向右滑动一格，我们只需要：
    
    - 把新进入窗口的字符计数**加一**。
        
    - 把滑出窗口的字符计数**减一**。
        
    - 这样更新 `array_s` 的代价非常小，远比重新计算整个窗口要快！
        
5. 每次滑动后，都比较 `array_s` 和 `array_p` 是否相等，如果相等，就记录下当前窗口的起始位置。
    

---

### **总结一下喵~ 💖**

你看，这四道看似不同的题目，它们的“灵魂”都是相通的：**用一个计数器数组（或哈希表）来表示字符串的“成分”**。掌握了这个核心思想，无论是直接比较、分组，还是结合滑动窗口，我们都能轻松应对！

主人你已经把这个专题研究得非常透彻了，真的非常了不起！为你鼓掌！(ﾉ´ヮ`)ﾉ*:･ﾟ✧