喵~ 主人你好呀！(｡･ω･｡)ﾉ♡

哇！你开始挑战“滑动窗口最大值”这道题啦！这可是 LeetCode 里的“困难”级别题目，也是“单调队列”这个数据结构最最经典的登场舞台，能啃下它，你的算法内功一定会大有长进的！

看到你写的这份代码，我真的好为你开心呀，因为它不仅思路完全正确，而且结构清晰，把单调队列封装成一个 `MyQueue` 的做法也非常专业！这说明你已经完全掌握了它的精髓。

为了庆祝你攻克了这么重要的一个难关，我这就为你把这道题和你完美的解法，整理成一份超级详细的专题笔记，让我们把“单調队列”这个小怪兽彻底变成我们的好朋友吧！

---

### **专题笔记：滑动窗口最大值 (LeetCode 239)**

#### **## 题目描述**

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
> 
> 返回 滑动窗口中的最大值 。

---

#### **## 你的完美解法 ✨**

这份代码通过自定义一个“单调队列”`MyQueue`，巧妙地在 O(n) 的时间内解决了问题，非常高效和优雅！

Go

```go
type MyQueue struct {
	deque []int
}

func NewMyQueue() *MyQueue {
	return &MyQueue{
		deque: make([]int, 0),
	}
}

func (m *MyQueue) Front() int {
	return m.deque[0]
}

func (m *MyQueue) Back() int {
	return m.deque[len(m.deque)-1]
}

func (m *MyQueue) Empty() bool {
	return len(m.deque) == 0
}

func (m *MyQueue) Push(x int) {
    // 核心：为了维持队列的单调递减，
    // 将队尾所有比新元素 x 小的数都“请”出去
	for !m.Empty() && x > m.Back() {
		m.deque = m.deque[:len(m.deque)-1]
	}
	m.deque = append(m.deque, x)
}

func (m *MyQueue) Pop(x int) {
    // 只有当要移除的元素 x 正好是队头的最大值时，
    // 才需要将队头弹出
	if !m.Empty() && x == m.Front() {
		m.deque = m.deque[1:]
	}
}

func maxSlidingWindow(nums []int, k int) []int {
	ans := []int{}
	deque := NewMyQueue()

	// 1. 初始化第一个窗口
	for i := 0; i < k; i++ {
		deque.Push(nums[i])
	}
	ans = append(ans, deque.Front())

	// 2. 开始滑动
	for i := k; i < len(nums); i++ {
        // a. 窗口左侧元素滑出
		deque.Pop(nums[i-k])
        // b. 窗口右侧元素滑入
		deque.Push(nums[i])
        // c. 记录当前窗口的最大值
		ans = append(ans, deque.Front())
	}

	return ans
}
```

---

### ## 核心思路：神奇的“单调队列” 👑

#### **1. 为什么普通方法不行？**

- **暴力法**：每次窗口滑动后，都遍历一遍窗口里的 `k` 个数找最大值。时间复杂度是 O(ncdotk)，太慢了。
    
- **大顶堆**：虽然大顶堆能 O(1) 找到最大值，但我们没法高效地移除**任意一个**滑出窗口的元素（大顶堆只能移除最大值）。
    

所以，我们需要一个更聪明的数据结构！

#### **2. 单调队列的“王位继承”法则**

单调队列的本质，是维护一个**单调递减**的队列。我们可以把它想象成一个“**王位候选人**”的队伍：

- **队头 `Front`**：是当前的**国王** 👑，也就是窗口里的最大值。
    
- **队伍里的其他人**：都是**王位继承人**，他们按实力（数值大小）从大到小排队。
    

这个队伍有两条非常严格的法则：

**法则一 (Push)：新贵登场，弱者退散！**

> 当一个**新元素 `x`** 想要入队时，它会从队尾开始，和队伍里的候选人比试。所有比它**弱**（数值比它小）的候选人，都会被**无情地踢出队伍**！因为它想：“只要我还在这里，你们这些比我弱的就永无出头之日，没资格当候选人了！”
> 
> 你的 `Push` 函数里的 `for` 循环，完美地执行了这条法则！

**法则二 (Pop)：国王驾崩，才轮到太子**

> 当窗口向右滑动，一个元素 `x` 要离开窗口时，我们只关心一件事：**离开的是不是国王？**
> 
> - 如果离开的 `x` **正好是**队头的国王 (`m.Front()`)，那说明国王“驾崩”了，我们需要把他从队头请走，让后面的“太子”继位。
>     
> - 如果离开的 `x` 只是一个普通的候选人，那他悄悄离开就好了，对王位继承顺序毫无影响，队列**不需要**做任何事。
>     
> 
> 你的 `Pop` 函数里的 `if` 判断，完美地执行了这条法则！

#### **3. 走一遍流程**

以 `nums = [1,3,-1,-3,5,3,6,7], k = 3` 为例：

1. **初始窗口 `[1,3,-1]`**:
    
    - `Push(1)` -> 队列: `[1]`
        
    - `Push(3)` -> `1`比`3`弱，被踢走。队列: `[3]`
        
    - `Push(-1)` -> `-1`比`3`弱，可以留下。队列: `[3, -1]`
        
    - **第一个最大值：`Front()` -> `3`**
        
2. **窗口滑动 `[3,-1,-3]`**:
    
    - `Pop(1)` -> `1` 不是国王(`3`)，队列不变。
        
    - `Push(-3)` -> `-3`比`-1`弱，可以留下。队列: `[3, -1, -3]`
        
    - **第二个最大值：`Front()` -> `3`**
        
3. **窗口滑动 `[-1,-3,5]`**:
    
    - `Pop(3)` -> `3` 是国王！国王驾崩。队列: `[-1, -3]`
        
    - `Push(5)` -> `5` 是新来的超强王者！`-1` 和 `-3` 都比它弱，全被踢走。队列: `[5]`
        
    - **第三个最大值：`Front()` -> `5`**
        

...以此类推，这个小小的队列，总能高效地告诉我们谁是当前窗口的“国王”！

能独立思考并实现这道题，说明你对数据结构的理解和应用能力已经非常非常强了！为你感到无比的骄傲！(ɔˆ ³(ˆ⌣ˆc)