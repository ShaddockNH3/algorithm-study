好的喵！主人你已经完全理解了用两个栈实现队列的精髓，我这就为你把这个巧妙的算法，连同你写的完美代码，整理成一份详细的专题笔记，方便你随时回顾！(｡･ω･｡)ﾉ♡

---

### **专题笔记：用栈实现队列 (LeetCode 232)**

#### **## 题目描述**

[力扣题目链接](https://leetcode.cn/problems/implement-queue-using-stacks/)

> 使用栈实现队列的下列操作：
> 
> - `push(x)` -- 将一个元素放入队列的尾部。
>     
> - `pop()` -- 从队列首部移除元素。
>     
> - `peek()` -- 返回队列首部的元素。
>     
> - `empty()` -- 返回队列是否为空。
>     

---

#### **## 你的完美解法 ✨**

这份代码巧妙地利用两个栈的角色分工，实现了队列的“先进先出”特性。

Go

```go
type MyQueue struct {
	stackIn  []int
	stackOut []int
}

func Constructor() MyQueue {
	return MyQueue{
		stackIn:  make([]int, 0),
		stackOut: make([]int, 0),
	}
}

func (this *MyQueue) Push(x int) {
	this.stackIn = append(this.stackIn, x)
}

// pour 辅助函数：仅在 stackOut 为空时，将 stackIn 的元素倒入 stackOut
func (this *MyQueue) pour() {
	if len(this.stackOut) == 0 {
		for len(this.stackIn) > 0 {
			val := this.stackIn[len(this.stackIn)-1]
			this.stackIn = this.stackIn[:len(this.stackIn)-1]
			this.stackOut = append(this.stackOut, val)
		}
	}
}

func (this *MyQueue) Pop() int {
	this.pour() // 在操作前，确保 stackOut 有“存货”
	if len(this.stackOut) == 0 {
		return -1 // 队列为空
	}
	val := this.stackOut[len(this.stackOut)-1]
	this.stackOut = this.stackOut[:len(this.stackOut)-1]
	return val
}

func (this *MyQueue) Peek() int {
	this.pour() // 在操作前，确保 stackOut 有“存货”
	if len(this.stackOut) == 0 {
		return -1 // 队列为空
	}
	return this.stackOut[len(this.stackOut)-1]
}

func (this *MyQueue) Empty() bool {
	return len(this.stackIn) == 0 && len(this.stackOut) == 0
}
```

---

### ## 核心思路：双栈“倒水”法 🧙‍♀️

#### **1. 角色分工**

这个算法的精髓在于给两个栈分配不同的角色：

- **`stackIn` (输入栈)**：扮演“**排队区**” 🚶‍♂️🚶‍♀️。所有新来的元素 (`Push`) 都先进入这个栈排队。它的内部顺序是“后进先出”（LIFO）。
    
- **`stackOut` (输出栈)**：扮演“**服务区**” 🙋。所有需要出队的元素 (`Pop`, `Peek`) 都必须从这个栈出去。它的内部顺序是“先进先出”（FIFO）。
    

#### **2. “倒水”的魔法 (`pour` 函数)**

- **`Push` 操作**：非常简单，新元素总是直接进入 `stackIn` 排队。
    
- **`Pop` / `Peek` 操作**：当需要有元素出队时，我们**先看 `stackOut` (服务区)**。
    
    - 如果 `stackOut` **不为空**，说明服务区还有人排着正确的队伍，直接服务队首的元素（也就是栈顶）即可。
        
    - **只有当 `stackOut` 为空**时，我们才执行一次“倒水”操作：将 `stackIn` (排队区) 的所有元素，**一次性地、全部地**倒入 `stackOut` (服务区)。
        
- **翻转的奥秘**：这个“倒水”的过程，实际上就是一次**翻转**。`stackIn` 中“后进先出”的顺序，在倒入 `stackOut` 后，就变成了我们想要的“先进先出”的顺序！最早进入 `stackIn` 的元素，现在正好位于 `stackOut` 的栈顶。
    

#### **3. 为什么永远不倒回去？**

一旦元素进入了 `stackOut`，它们的顺序就是**绝对正确**的出队顺序。任何新来的元素都应该排在它们的后面。我们的 `stackIn` 正是为这些新元素准备的“等候区”。如果把 `stackOut` 的元素倒回去，就会打乱已经排好的完美队形。

---

### ## 性能分析 ⏱️

- **`Push`**: 永远是 O(1)。
    
- **`Pop` / `Peek`**:
    
    - **大多数情况**：如果 `stackOut` 不为空，操作是 O(1)。
        
    - **少数情况**：如果 `stackOut` 为空，需要一次 O(n) 的“倒水”操作。
        
    - **均摊时间复杂度**: 虽然单次操作最坏是 O(n)，但每个元素一生中只会被“倒水”一次。因此，平摊到每次操作上，`Pop` 和 `Peek` 的**均摊时间复杂度**为 O(1)。
        

这个解法非常巧妙地平衡了时间和操作，是面试中考察该问题的标准最优解！主人你已经完全掌握啦！(｡ゝω･)b✧