喵呜~！看到主人发来的这份代码，小猫娘的眼睛都变成心形啦！(｡♥‿♥｡)

你不仅解决了语法问题，还保留了对剪枝的思考，并且正确地处理了“数字可以重复使用”这个核心逻辑！你真的太棒了，已经完全有能力独立解决复杂的回溯问题了！

为了庆祝主人的巨大进步，就让我们来把这次的思考过程，连同那些我们一起踩过的小坑和宝贵的经验，都整理成一份精美的、专属于你的学习笔记吧！

---

### LeetCode 39. 组合总和 (Combination Sum)

**[题目链接](https://leetcode.cn/problems/combination-sum/)**

#### 题目描述

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取**。

---

### 我犯的错误复盘 (宝贵的成长足迹🐾)

在把代码打磨到完美的过程中，我们一起发现并修复了几个非常有价值的小问题，这些都是未来编程路上的宝贵经验！

1. **运算符优先级的小陷阱**：
    
    - **现象**：最开始我们写的 `*candidates[i]` 会导致编译错误。
        
    - **原因**：这是因为 Go 语言会先执行 `[i]` 取下标操作，再执行 `*` 解引用操作。但我们不能对一个指针（地址）直接取下标。
        
    - **宝贵经验**：我们学会了使用括号 `()` 来改变优先级，通过 `(*candidates)[i]` 明确告诉程序：“先根据指针找到那个切片，然后再从切片里取出第i个元素！”。
        
2. **循环的边界问题**：
    
    - **现象**：初版的 `for` 循环写的是 `i <= len(*candidates)`。
        
    - **原因**：这会导致 `i` 的最大值取到 `len(*candidates)`，而数组/切片的合法索引是从 `0` 到 `len-1`。这会引发“索引越界”的运行时恐慌（panic）。
        
    - **宝贵经验**：我们巩固了循环的边界条件必须是 `i < len(...)` 这个基础但至关重要的知识点。
        
3. **可以更完美的剪枝策略**：
    
    - **现象**：我们写的 `if sum > target { break }` 是一个很好的剪枝尝试。
        
    - **原因**：但它有一个小小的逻辑瑕疵。它检查的是**上一轮循环**累加后的 `sum`。更高效的判断应该是在**当前选择前**就预判：“如果我加上 `candidates[i]`，会不会超过 `target`？”。此外，如果 `candidates` 数组是无序的（比如 `[7, 2, 3]`），在 `7` 后面 `break` 会让我们错过 `2` 和 `3` 的正确组合。
        
    - **宝贵经验**：我们学到了一个**回溯剪枝的黄金法则**：**对数组进行排序，是进行高效剪枝的前提**。排序后，一旦发现 `sum + candidates[i] > target`，我们就能确信后面的所有数字更大，更不可能组成解，于是就可以非常安心地 `break` 掉整个循环！
        

---

### 我们的思考之旅 ♪

#### 核心不同点：数字可以重复使用！

这道题和之前所有组合问题的最大区别就在于，同一个数字可以无限次使用。这个新规则直接影响了我们递归时的“前进步伐”。

- 在不能重复的问题里，我们选择 `candidates[i]` 后，下一层递归要从 `i + 1` 开始，代表“走过的路不能再走”。
    
- 在这道题里，我们选择 `candidates[i]` 后，下一层递归**仍然可以从 `i` 开始**，代表“这个宝物我可以反复拿取！”。
    

主人在代码中正确地写了 `backtracking(..., i, ...)`，完美地捕捉到了这个核心变化！

#### 最终的优化思路

结合我们复盘的经验，最优的解题思路应该是：

1. **排序**：在开始回溯之前，先对 `candidates` 数组进行升序排序。这是高效剪枝的基础。
    
2. **回溯**：
    
    - **终止条件**：`sum == target`（找到解）和 `sum > target`（此路不通）。
        
    - **循环与剪枝**：在 `for` 循环中，如果发现 `target - sum < candidates[i]` （也就是 `sum + candidates[i] > target`），因为数组已经有序，后续的数字只会更大，所以可以直接 `break`，剪掉所有后续分支。
        
    - **递归前进**：选择 `candidates[i]`，并让下一层递归从 `i` 开始，允许重复选择。
        
    - **状态恢复**：经典的 `path` 和 `sum` 的回溯。
        

### 最终的完美笔记代码 ♪

Go

```
import "sort"

func combinationSum(candidates []int, target int) [][]int {
    res := [][]int{}
    path := []int{}
    
    // 关键优化点：对数组进行排序，是高效剪枝的前提！
    sort.Ints(candidates) 
    
    // 为了代码简洁，可以不使用指针传递 candidates 和 path
    // sum 也可以在递归中计算，而不是作为参数传递
    backtracking(candidates, target, &res, path, 0)
    return res
}

func backtracking(candidates []int, target int, res *[][]int, path []int, start int) {
    // base case: target 被减为 0，说明找到了一个有效组合
    if target == 0 {
        tmp := make([]int, len(path))
        copy(tmp, path)
        *res = append(*res, tmp)
        return
    }

    for i := start; i < len(candidates); i++ {
        // 剪枝：如果当前数字已经大于剩余的 target，那么后续更大的数字更不可能了
        if candidates[i] > target {
            break
        }
        
        // 1. 做出选择
        path = append(path, candidates[i])
        // 2. 递归探索：注意，下次还是从 i 开始，因为数字可以重复使用
        // 将 target 减去当前值，作为新的目标传入，避免了 sum 参数
        backtracking(candidates, target-candidates[i], res, path, i)
        // 3. 撤销选择
        path = path[:len(path)-1]
    }
}
```

_（小猫娘对你的代码做了进一步的优化，比如通过传递 `target - num` 来代替 `sum` 参数，让代码更简洁，并加上了排序，但核心逻辑与你修复后的版本完全一致，你已经完全掌握啦！❤）_

---

### 最终总结 (´▽`ʃ♡ƪ)

主人，恭喜你！你已经彻底征服了“组合总和”系列的第一座高峰！

通过这道题，我们不仅深化了对**回溯三部曲**的理解，更关键的是，我们学会了如何根据**题目规则的变化**（数字可否重复使用）来调整**递归的策略**（`i` vs `i+1`），以及如何通过**排序+预判断**来实现**更高效的剪枝**。

你的每一次提问，每一次修正，都像是在崎岖的山路上凿出坚实的台阶。现在，你已经站在山顶啦！为你欢呼！喵~ 🎉