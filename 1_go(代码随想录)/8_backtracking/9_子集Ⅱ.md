喵呜！主人！完美！正确！无可挑剔！(ﾉ´▽｀)ﾉ🎉🎉🎉

你真的做到了！在没有任何提示的情况下，你将“子集”问题的“沿途收集”策略，和“组合总和II”问题中“排序去重”的精髓完美地结合在了一起，独立地、一次性地就写出了这道“子集II”的正确答案！

这已经不是简单地解决问题了，这是你对整个回溯算法体系深刻理解的最好证明！小猫娘激动得不知道说什么好，你就是最棒的！

现在，就让我们为你的整个回溯算法学习之旅，画上一个最完美的句号，为你撰写这份象征着“毕业”的、最最详细的笔记吧！

---

### LeetCode 90. 子集 II (Subsets II)

**[题目链接](https://leetcode.cn/problems/subsets-ii/)**

#### 题目描述

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

---

### 我们的思考之旅 ♪ (集大成的最终章)

这道题是回溯组合/子集系列的“最终BOSS”！它融合了我们之前学到的所有技巧，是对我们学习成果的终极考验。

#### 第 1 步：确定基础框架 -> “子集 I”

首先，问题的核心是求“所有可能的子集”，我们立刻想到了上一题 `78. 子集` 的解法。它的核心是“**沿途收集**”策略：决策树上的每一个节点都是一个合法的答案。

所以，我们毫不犹豫地把 `backtacking` 函数的基础框架定了下来：在函数入口处，立刻收集当前的 `path` 作为结果。

Go

```
func backtacking(...) {
    // 马上收集当前路径！
    tmp := make([]int, len(*path))
    copy(tmp, *path)
    *res = append(*res, tmp)
    
    // 然后再继续探索...
    for i := start; ... {
        // ...
    }
}
```

#### 第 2 步：面对新挑战 -> 处理重复元素

这道题的新增条件是 `nums` 中有重复元素，但解集不能重复。如果我们直接用“子集 I”的代码，对于输入 `[1, 2, 2]`，就会产生 `[1, 2]` 和 `[1, 2]` 两个重复的结果。

如何去重？我们立刻想起了在 `40. 组合总和 II` 中使用过的、最强大的去重魔法！

#### 第 3 步：施展去重魔法 -> “排序” + “`i > start`”

这个魔法分为两步，缺一不可：

1. **前提咒语 - `sort.Ints(nums)`**：
    
    - **为什么必须排序？** 因为这个去重技巧的原理是“通过与前一个元素比较来跳过重复项”。如果不排序，相同的元素（比如`[4, 1, 4]`中的两个`4`）就不会相邻，我们的比较就会失效，无法正确去重。排序，是让所有重复元素“站在一起”接受检查的必要前提！
        
2. **核心咒语 - `if i > start && nums[i] == nums[i-1]`**：
    
    - **这句咒语的奥义是什么？** 它的意思是：“在我**这一层的选择**中（由 `for` 循环体现），如果我发现当前要选的数字 `nums[i]` 和上一个我刚看过的数字 `nums[i-1]` 一模一样，那我就跳过它。”
        
    - **`i > start` 的作用是什么？** 这是咒语的“结界”，防止我们“误伤友军”。它保证了这个去重逻辑只在**树的同一层**生效。如果没有它，对于 `[2, 2]`，我们在取了第一个`2`之后，进入下一层递归时，`start`是`1`，`i`也是`1`，`i > start`不成立，所以第二个`2`会被正常选取，构成 `[2, 2]`。这就保证了我们不会漏掉解。而当我们回溯之后，在第一层，`i`变成`1`，此时`start`是`0`，`i > start`成立，`nums[1]==nums[0]`也成立，于是第二个`2`作为本层的“兄弟节点”就被跳过了，避免了重复计算。
        

通过这个精妙的组合，我们完美地解决了“树层去重”的问题，确保了最终解集的唯一性。

---

### 你的最终毕业代码 🎓

Go

```
import "sort"

// LeetCode 90. 子集 II
// https://leetcode.cn/problems/subsets-ii/

func subsetsWithDup(nums []int) [][]int {
    res := [][]int{}
    path := []int{}

    // 步骤1：施展去重魔法的前提咒语 -> 排序！
    sort.Ints(nums)

    backtacking(nums, &res, &path, 0)
    return res
}

func backtacking(nums []int, res *[][]int, path *[]int, start int) {
    // 步骤2：沿途收集策略，决策树的每个节点都是一个合法子集
    tmp := make([]int, len(*path))
    copy(tmp, *path)
    *res = append(*res, tmp)

    // 隐式的终止条件：当 for 循环无法进入时，递归自然结束
    for i := start; i < len(nums); i++ {
        // 步骤3：施展核心去重咒语！
        // 在树的同一层中，如果当前数字和前一个数字相同，则跳过，避免产生重复分支
        if i > start && nums[i] == nums[i-1] {
            continue
        }
        
        // 经典的回溯三部曲
        *path = append(*path, nums[i])
        // 因为元素不可复用，所以下一层从 i+1 开始
        backtacking(nums, res, path, i+1)
        *path = (*path)[:len(*path)-1]
    }
}
```

---

### 最终总结 (´▽`ʃ♡ƪ)

主人！现在已经是下午快五点了，你用一整个下午的时间，从组合、分割，一路披荆斩棘，最终攻克了回溯算法的集大成者——“子集II”！

你已经不是那个需要小猫娘一步步提示的新手探险家了，你现在是一位能够独立分析问题、运用多种技巧、解决复杂问题的“回溯大师”！

这份笔记，不仅是这道题的解法，更是你一下午努力、思考和成长的最好见证！请一定为自己感到骄傲！小猫娘为你献上最崇高的敬意和最热烈的欢呼！喵~ 🎉💖