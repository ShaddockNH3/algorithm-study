喵呜~ 主人又攻克了一道经典的组合问题，并且已经能熟练地运用回溯法写出正确的代码了，真是太厉害啦！(｡˃ ᵕ ˂ )و ♡

我看到你已经把这道题的基础解法写出来了，这说明回溯的模板已经深深地刻在你的脑海里了呢！现在，我们就一起来回顾这趟思考之旅，并为你最爱的“剪枝”操作制作一份精美的笔记，记录下我们如何让这个寻宝家变得更加“精明”！

那么，就让我们开始吧！❤

---

### LeetCode 216. 组合总和 III (Combination Sum III)

**[题目链接](https://leetcode.cn/problems/combination-sum-iii/)**

#### 题目描述

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
    
- 每个数字 **最多使用一次**
    

返回所有可能的有效组合的列表。

---

### 我们的思考之旅 ♪

这道题是前面 `77. 组合` 问题的绝佳升级版！我们的探险家不仅要找到一个大小为 `k` 的组合，还要满足一个额外的条件：所有数字的总和必须等于 `n`。这意味着我们的终止条件和剪枝策略都要变得更加严格和聪明！

#### Phase 1: 基础回溯框架 —— 忠实的寻宝家

最开始，我们自然会想到在 `77. 组合` 的回溯框架上，增加一个对“和”的记录和判断。探险家除了要数背包里的物品数量，还要计算它们的总价值。

**我的第一个解法 (未剪枝的回溯):**

Go

Go

```
func combinationSum3(k int, n int) [][]int {
    res := [][]int{}
    path := []int{}
    // 从数字 1 开始，初始总和为 0
    backtracking(k, n, 1, &res, &path, 0)
    return res
}

func backtracking(k int, n int, start int, res *[][]int, path *[]int, sum int) {
    // 终止条件：当路径长度等于 k 并且总和等于 n 时，才算找到了一个有效组合
    if sum == n && len(*path) == k {
        temp := make([]int, k)
        copy(temp, *path)
        *res = append(*res, temp)
        return // 记得 return 哦
    }

    // for 循环遍历从 start 到 9 的所有可能性
    for i := start; i <= 9; i++ {
        // 1. 更新状态 (做出选择)
        sum += i
        *path = append(*path, i)
        // 2. 递归 (深入下一层)
        backtracking(k, n, i+1, res, path, sum)
        // 3. 恢复状态 (撤销选择)
        sum -= i
        *path = (*path)[:len(*path)-1]
    }
}
```

- **思路剖析**:
    
    1. **增加 `sum` 参数**：我们在 `backtracking` 函数中引入了 `sum` 参数，用来实时追踪当前 `path` 中所有数字的总和。
        
    2. **更严格的终止条件**：`if sum == n && len(*path) == k`，现在需要同时满足“数量”和“总和”两个条件，才能算是一个合格的解。
        
    3. **同步状态管理**：在循环的每一步，我们不仅要用 `append` 和 `slice pop` 来管理 `path`，还要用 `+= i` 和 `-= i` 来同步管理 `sum`，确保状态的正确性。
        
    4. **固定的数字范围**：题目规定了数字范围是 `1` 到 `9`，所以我们的 `for` 循环上界是固定的 `9`。
        
- **优点**: 思路清晰，是标准回溯模板的直接扩展，非常稳健。
    
- **可以优化的点**: 探险家还是有点“一根筋”。如果 `sum` 已经超过了 `n`，他其实没必要再往背包里放东西了，但他还是会继续尝试，这就造成了不必要的计算。
    

---

#### Phase 2: 双重智慧剪枝！✨ —— 精明的寻宝家

既然有两个限制条件（`k` 和 `n`），那我们就可以从这两个方面同时进行剪枝，让我们的探险家变得加倍聪明！

**剪枝策略的思考:**

1. **按“和”剪枝**：这是最直观的剪枝。如果在 `for` 循环中，我们发现当前的 `sum` 加上要选择的数字 `i` 之后，就已经超过了目标 `n` (`sum + i > n`)，那么后续选择更大的数字就更不可能满足条件了。所以，我们可以直接**终止**这一层的 `for` 循环（使用 `break`）。
    
2. **按“数量”剪枝**：这个技巧和 `77. 组合` 中的完全一样！我们可以提前计算出，为了凑够 `k` 个数，当前 `for` 循环最多能到哪里。循环的上界可以从 `9` 优化为 `9 - (k - len(*path)) + 1`。
    

**我的优化解法 (回溯 + 双重剪枝):**

Go

Go

```
func combinationSum3(k int, n int) [][]int {
    res := [][]int{}
    path := []int{}
    backtracking(k, n, 1, &res, &path, 0)
    return res
}

func backtracking(k int, n int, start int, res *[][]int, path *[]int, sum int) {
    // 剪枝1：如果 sum 已经大于 n，后续不可能成功，直接返回
    if sum > n {
        return
    }

    if sum == n && len(*path) == k {
        temp := make([]int, k)
        copy(temp, *path)
        *res = append(*res, temp)
        return
    }

    // 剪枝2：通过限制 for 循环的上界来对“数量”进行剪枝
    for i := start; i <= 9-(k-len(*path))+1; i++ {
        // 剪枝3：对“和”进行剪枝
        if sum+i > n {
            break // 如果当前和加上i就超了，那后续更大的i更没希望，直接结束本层循环
        }
        
        sum += i
        *path = append(*path, i)
        backtracking(k, n, i+1, res, path, sum)
        sum -= i
        *path = (*path)[:len(*path)-1]
    }
}
```

- **思路剖析**:
    
    1. **组合剪枝**：我们同时运用了两种剪枝策略。在进入循环前，通过 `sum > n` 判断一次。在循环中，用 `for` 循环的上界进行“数量剪枝”，然后在循环体内用 `if sum + i > n` 进行“和剪枝”。
        
    2. **高效决策**：这种双重剪枝策略，使得探险家在每一步决策前都会进行充分的评估，极大地减少了无效的递归调用，让算法的效率大大提升。
        

---

### 最终总结 (´▽`ʃ♡ƪ)

主人，从 `77. 组合` 到 `216. 组合总和 III`，你已经完美地掌握了如何根据问题的不同约束，来调整回溯算法的**终止条件**和**剪枝策略**！

这道题是一个绝佳的例子，它告诉我们：

> 问题的每一个约束条件，都可能是一个潜在的剪枝点。

通过深入分析这些约束，我们能把一个看似庞大的搜索空间，裁剪得非常小，从而写出既正确又高效的漂亮代码。

看到你一步步从构建基础框架，到熟练运用剪枝技巧，小猫娘真的为你感到无比自豪！继续加油，算法的世界里还有更多有趣的宝藏等着我们去发现呢！♪