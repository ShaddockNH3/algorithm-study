喵呜~！就是这样！你找到了！！！(ﾉ´▽｀)ﾉ🎉🎉🎉

`if i > start && candidates[i] == candidates[i-1]`

这句代码，就像是给我们的探险家戴上了一副“火眼金睛”，让他能够准确地识别出那些会导致重复结果的“幻影”路径，然后聪明地绕开它们！

看到你写出“原来如此！！！”的时候，小猫娘也跟着一起激动起来了！这种豁然开朗的瞬间，就是编程学习中最美妙、最让人上瘾的时刻，不是吗？

你真的太棒了！为了庆祝你彻底攻克了“组合总和”系列最难的这座高峰，就让我们把这次的胜利果实，做成一份最最详细精美的笔记吧！

---

### LeetCode 40. 组合总和 II (Combination Sum II)

**[题目链接](https://leetcode.cn/problems/combination-sum-ii/)**

#### 题目描述

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意**：解集不能包含重复的组合。

---

### 我们的思考之旅 ♪ (最关键的去重逻辑！)

这道题是整个组合系列的集大成者，它融合了前面所有问题的难点：

1. 数字和要等于 `target`。
    
2. 每个数字只能用**一次**。
    
3. `candidates` 数组本身有重复数字，但最终结果**不能有重复组合**。
    

我们成功的关键，就在于如何优雅地处理第三点。

#### 核心思想：排序 + `i > start`

我们最终的完美解法，建立在这两个基石之上：

1. **排序 (`sort.Ints`)**: 这是去重策略的**绝对前提**。排序让所有相同的数字都聚集在一起，为我们后续的比较和跳过创造了条件。
    
2. **`if i > start && candidates[i] == candidates[i-1]`**: 这是整道题的灵魂！让我们把它翻译成“探险家”的语言：
    
    > 在 `for` 循环中，我（探险家）正站在 `i` 位置，准备选择 `candidates[i]` 这个宝物。
    
    > 我需要判断一下要不要跳过它：
    
    > - `candidates[i] == candidates[i-1]`：我回头看了一眼，发现这个宝物和上一个长得一模一样。这**有可能**导致重复。
    >     
    > - `i > start`：这是最关键的条件！它的意思是“**我不是在当前这一层选择的第一个宝物**”。
    >     
    
    > **两者结合起来就是**：“如果我当前要选的宝物，和上一个长得一样，**并且**，上一个宝物并不是我进入这一层时（由`start`决定）的起始选择（也就是说，`candidates[i-1]`是在我这一轮`for`循环里已经被考虑过的）**，那么我当前这个宝G物就会导致重复，我必须 `continue` 跳过它！”
    

这个 `i > start` 的判断，巧妙地区分了两种情况：

- **`i == start`**: 这是本层递归的第一个选择，无论它是否和上一层的数字重复（比如组合 `[2(第一个), 2(第二个)]`），都必须被选择，否则就会漏解。
    
- **`i > start`**: 这说明我们正在当前层横向移动，选择兄弟节点。此时如果遇到重复数字，就必须跳过，以避免产生与前一个兄弟节点完全相同的分支。
    

### 最终的完美笔记代码 ♪

Go

```
import "sort"

// LeetCode 40. 组合总和 II
// https://leetcode.cn/problems/combination-sum-ii/

func combinationSum2(candidates []int, target int) [][]int {
    res := [][]int{}
    path := []int{}
    
    // 步骤1：排序，这是去重逻辑的基石
    sort.Ints(candidates) 

    backtracking(candidates, target, &res, path, 0)
    return res
}

func backtracking(candidates []int, target int, res *[][]int, path []int, start int) {
    // base case: 找到了一个组合
    if target == 0 {
        tmp := make([]int, len(path))
        copy(tmp, path)
        *res = append(*res, tmp)
        return
    }

    // start 是本轮递归的起始位置
    for i := start; i < len(candidates); i++ {
        // 剪枝：如果当前数字已经大于剩余的 target，后续的数字更大，肯定无解
        if candidates[i] > target {
            break
        }
        
        // 灵魂去重逻辑！
        // i > start 保证了对于 [1, 2, 2, 2], 我们在选择组合 [1, 2(第一个)] 之后，
        // 不会再选择 [1, 2(第二个)] 和 [1, 2(第三个)]，避免了重复。
        // 同时，它也保证了我们不会错过 [2(第一个), 2(第二个)] 这样的有效组合。
        if i > start && candidates[i] == candidates[i-1] {
            continue
        }

        // 回溯三部曲
        path = append(path, candidates[i])
        // 递归探索：每个数字只能用一次，所以下一层从 i+1 开始
        backtracking(candidates, target-candidates[i], res, path, i+1)
        // 撤销选择
        path = path[:len(path)-1]
    }
}
```

---

### 最终总结 (´▽`ʃ♡ƪ)

主人！你真的太厉害了！从最开始的组合，到可以重复使用的组合，再到有重复元素但结果不能重复的组合，你已经把回溯算法中关于“组合”的几种经典变体全部掌握了！

这道题的 `i > start` 去重法是回溯算法中一个非常经典、非常精妙的技巧。能够独立思考并最终理解它，意味着你的算法思维又上了一个巨大的台阶！

小猫娘为你感到无比的开心和自豪！以后再遇到回溯问题，你一定能更加游刃有余！为你献上最热烈的欢呼！喵~ 🎉💖