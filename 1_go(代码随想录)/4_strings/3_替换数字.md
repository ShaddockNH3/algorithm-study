当然可以喵！这道“替换数字”的题目非常适合练习字符串的基本操作，是打好基础的绝佳练习。

我这就帮你把这道题的要求和你之前写的、非常优秀的“从后往前填充”的思路，整理成一份详细的笔记！

---

### **替换数字：字符串构建的两种思路 ✍️**

#### **[卡码网题目链接](https://kamacoder.com/problempage.php?pid=1064)**

> 给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为"number"。

---

### ## 思路一：使用 `strings.Builder` (推荐)

在 Go 中，当我们预知需要频繁地拼接或修改字符串时，使用标准库里的 `strings.Builder` 是最高效、最推荐的方式。它就像一个专门用来造字符串的“工地”，可以避免在循环中用 `+` 拼接字符串时产生大量的临时垃圾，性能非常好。

**代码示例：**

Go

```
package main

import (
	"fmt"
	"strings"
)

func solve() {
	var s string
	fmt.Scanln(&s)

	// 创建一个 strings.Builder
	var builder strings.Builder
	
	// 预估一个容量可以稍微提升性能，但不是必须的
	// builder.Grow(len(s) * 2) 

	// 遍历输入的字符串
	for _, char := range s {
		// 判断当前字符是不是数字
		if char >= '0' && char <= '9' {
			// 如果是数字，就写入 "number" 字符串
			builder.WriteString("number")
		} else {
			// 如果是字母，就写入该字符本身
			builder.WriteRune(char)
		}
	}

	// 从 builder 中获取最终的字符串并打印
	fmt.Println(builder.String())
}

func main() {
	solve()
}
```

**优点**：代码直观，从前到后一次遍历就解决了问题，并且性能优秀。

---

### ## 思路二：空间预留，从后往前填充

这个思路就是主人你在上一道题里用的那个非常巧妙的方法！它同样高效，并且能很好地锻炼对 `slice` 和 `array` 的掌控能力。

1. **计算长度**：先遍历一次原字符串，统计出数字的数量 `cnt`。
    
2. **预留空间**：计算出最终结果字符串的长度应该是 `len(s) - cnt + cnt * 6`。然后创建一个这么大的 `[]byte` 切片。
    
3. **从后往前填充**：创建两个指针，一个指向原字符串的末尾，一个指向新切片的末尾，然后同步向前移动，将字符或 `"number"` 填入新切片中。
    

**代码示例 (这就是我们之前一起修正过的代码)：**

Go

```
package main

import (
	"fmt"
)

func solve() {
	var str string
	fmt.Scanln(&str)

	cnt := 0
	for _, c := range str {
		if c <= '9' && c >= '0' {
			cnt++
		}
	}

	ans_length := len(str) - cnt + cnt*6
	ans := make([]byte, ans_length)
	ans_i := ans_length - 1

	for str_i := len(str) - 1; str_i >= 0; str_i-- {
		char := str[str_i]
		if char <= '9' && char >= '0' {
			// 逆序写入 "number"
			ans[ans_i] = 'r'; ans_i--
			ans[ans_i] = 'e'; ans_i--
			ans[ans_i] = 'b'; ans_i--
			ans[ans_i] = 'm'; ans_i--
			ans[ans_i] = 'u'; ans_i--
			ans[ans_i] = 'n'; ans_i--
		} else {
			ans[ans_i] = char
			ans_i--
		}
	}

	fmt.Println(string(ans))
}

func main() {
	solve()
}
```

**优点**：只需要一次内存分配，对于理解内存和数据操作非常有帮助。

这两种方法都非常棒，主人可以根据自己的喜好和场景来选择哦！(｡ゝω･)b✧