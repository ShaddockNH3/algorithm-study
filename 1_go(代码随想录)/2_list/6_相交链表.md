当然可以喵！这道“链表相交”题非常经典，而主人你写的这个解法，正是其中最巧妙、最浪漫的一种！(｡･ω･｡)ﾉ♡

我这就为你整理一份包含三种主流解法的详细笔记，并着重解释你那种解法背后的数学推导过程。

---

### **专题笔记：链表相交 (面试题 02.07)**

#### **## 题目描述**

[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

---

### ## 三种解法思路喵~

#### **方法一：双指针法 (你的巧妙解法) —— “你走过我来时的路”**

这是空间复杂度为 O(1) 的最优解法之一，代码简洁且富有哲理。

**你的优秀代码：**

Go

```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 * Val int
 * Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	pa, pb := headA, headB

	// 如果两个指针不相遇，就一直走下去
	for pa != pb {
		// pa 走一步，如果走到 A 的尽头，就转到 B 的开头
		if pa == nil {
			pa = headB
		} else {
			pa = pa.Next
		}
		// pb 走一步，如果走到 B 的尽头，就转到 A 的开头
		if pb == nil {
			pb = headA
		} else {
			pb = pb.Next
		}
	}
	// 循环结束时，pa 和 pb 要么在交点相遇，要么都为 nil
	return pa
}
```

推导过程 (为什么这个方法可行？)

这个方法的浪漫之处在于，它保证了两个指针 pa 和 pb 在相遇前，走过的总路程是完全一样的！

我们来分解一下路程：

- 设链表 A 的独有部分长度为 `a`，链表 B 的独有部分长度为 `b`，公共部分长度为 `c`。
    
- `pa` 的旅程：先走完 A 的独有部分 `a`，再走完公共部分 `c`，然后转到 B 的开头，走完 B 的独有部分 `b`。总路程 = `a + c + b`。
    
- `pb` 的旅程：先走完 B 的独有部分 `b`，再走完公共部分 `c`，然后转到 A 的开头，走完 A 的独有部分 `a`。总路程 = `b + c + a`。
    

你看！`a + c + b` 和 `b + c + a` 完全相等！因为两个指针速度相同，走的路程也相同，所以它们**必然会在某个时刻相遇**。如果存在交点，它们就会在第一个交点上相遇；如果不存在交点 (`c=0`)，它们会在走完 `a+b` 的路程后，同时到达终点 `nil`。

---

#### **方法二：哈希集合法 —— “我走过的路都做了标记”**

这个方法非常直观，容易理解，是典型的用空间换时间的思路。

**思路：**

1. 先遍历一条链表（比如 `headA`），把所有经过的节点的**内存地址**都存入一个哈希集合 `set` 中。
    
2. 再遍历另一条链表 `headB`，对于 `headB` 中的每一个节点，都去 `set` 中查询。
    
3. 第一个在 `set` 中被查询到的 `headB` 的节点，就是两条链表的交点。
    
4. 如果 `headB` 遍历完了还没找到，说明没有交点。
    

**Go 代码示例：**

Go

```
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    set := make(map[*ListNode]struct{})
    
    // 1. 将链表 A 的所有节点存入 Set
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        set[tmp] = struct{}{}
    }
    
    // 2. 遍历链表 B，检查节点是否存在于 Set 中
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        if _, ok := set[tmp]; ok {
            return tmp // 找到了第一个交点
        }
    }
    
    return nil
}
```

- **时间复杂度**: O(m+n)
    
- **空间复杂度**: O(m) 或 O(n)
    

---

#### **方法三：长度差法 —— “让你先跑几步，我们再一起走”**

这也是一个空间复杂度为 O(1) 的方法，思路非常清晰。

**思路：**

1. 分别遍历两条链表，得到它们的长度 `lenA` 和 `lenB`。
    
2. 计算出长度差 `diff = abs(lenA - lenB)`。
    
3. 让**较长**的那条链表的指针，**先走 `diff` 步**。
    
4. 现在，两个指针距离它们各自的终点，路程就一样长了！
    
5. 然后让两个指针**同步前进**，它们第一次相遇的节点，就是交点。
    

**Go 代码示例：**

Go

```
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    lenA, lenB := 0, 0
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        lenA++
    }
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        lenB++
    }

    // pa 指向长链表，pb 指向短链表
    pa, pb := headA, headB
    if lenB > lenA {
        pa, pb = headB, headA
    }

    // 长链表的指针先走 diff 步
    diff := lenA - lenB
    if lenB > lenA {
        diff = lenB - lenA
    }
    for i := 0; i < diff; i++ {
        pa = pa.Next
    }
    
    // 两个指针同步前进，直到相遇
    for pa != pb {
        pa = pa.Next
        pb = pb.Next
    }
    
    return pa
}
```

- **时间复杂度**: O(m+n)
    
- **空间复杂度**: O(1)
    

---

### **总结一下喵~ 💖**

| 方法        | 时间复杂度  | 空间复杂度       | 优点          |
| --------- | ------ | ----------- | ----------- |
| **双指针法**  | O(m+n) | O(1)        | 代码最简洁、思路最巧妙 |
| **哈希集合法** | O(m+n) | O(m) 或 O(n) | 思路最直观、容易想到  |
| **长度差法**  | O(m+n) | O(1)        | 思路清晰，容易理解   |

主人你写的正是第一种方法，它通常被认为是这道题最优雅的解法哦！(｡ゝω･)b✧