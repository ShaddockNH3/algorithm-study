å½“ç„¶å¯ä»¥å–µï¼è¿™é“â€œé“¾è¡¨ç›¸äº¤â€é¢˜éžå¸¸ç»å…¸ï¼Œè€Œä¸»äººä½ å†™çš„è¿™ä¸ªè§£æ³•ï¼Œæ­£æ˜¯å…¶ä¸­æœ€å·§å¦™ã€æœ€æµªæ¼«çš„ä¸€ç§ï¼(ï½¡ï½¥Ï‰ï½¥ï½¡)ï¾‰â™¡

æˆ‘è¿™å°±ä¸ºä½ æ•´ç†ä¸€ä»½åŒ…å«ä¸‰ç§ä¸»æµè§£æ³•çš„è¯¦ç»†ç¬”è®°ï¼Œå¹¶ç€é‡è§£é‡Šä½ é‚£ç§è§£æ³•èƒŒåŽçš„æ•°å­¦æŽ¨å¯¼è¿‡ç¨‹ã€‚

---

### **ä¸“é¢˜ç¬”è®°ï¼šé“¾è¡¨ç›¸äº¤ (é¢è¯•é¢˜ 02.07)**

#### **## é¢˜ç›®æè¿°**

[åŠ›æ‰£é¢˜ç›®é“¾æŽ¥](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

> ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `headA` å’Œ `headB` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›žä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æžœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å›ž `null` ã€‚

---

### ## ä¸‰ç§è§£æ³•æ€è·¯å–µ~

#### **æ–¹æ³•ä¸€ï¼šåŒæŒ‡é’ˆæ³• (ä½ çš„å·§å¦™è§£æ³•) â€”â€” â€œä½ èµ°è¿‡æˆ‘æ¥æ—¶çš„è·¯â€**

è¿™æ˜¯ç©ºé—´å¤æ‚åº¦ä¸º O(1) çš„æœ€ä¼˜è§£æ³•ä¹‹ä¸€ï¼Œä»£ç ç®€æ´ä¸”å¯Œæœ‰å“²ç†ã€‚

**ä½ çš„ä¼˜ç§€ä»£ç ï¼š**

Go

```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 * Val int
 * Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	pa, pb := headA, headB

	// å¦‚æžœä¸¤ä¸ªæŒ‡é’ˆä¸ç›¸é‡ï¼Œå°±ä¸€ç›´èµ°ä¸‹åŽ»
	for pa != pb {
		// pa èµ°ä¸€æ­¥ï¼Œå¦‚æžœèµ°åˆ° A çš„å°½å¤´ï¼Œå°±è½¬åˆ° B çš„å¼€å¤´
		if pa == nil {
			pa = headB
		} else {
			pa = pa.Next
		}
		// pb èµ°ä¸€æ­¥ï¼Œå¦‚æžœèµ°åˆ° B çš„å°½å¤´ï¼Œå°±è½¬åˆ° A çš„å¼€å¤´
		if pb == nil {
			pb = headA
		} else {
			pb = pb.Next
		}
	}
	// å¾ªçŽ¯ç»“æŸæ—¶ï¼Œpa å’Œ pb è¦ä¹ˆåœ¨äº¤ç‚¹ç›¸é‡ï¼Œè¦ä¹ˆéƒ½ä¸º nil
	return pa
}
```

æŽ¨å¯¼è¿‡ç¨‹ (ä¸ºä»€ä¹ˆè¿™ä¸ªæ–¹æ³•å¯è¡Œï¼Ÿ)

è¿™ä¸ªæ–¹æ³•çš„æµªæ¼«ä¹‹å¤„åœ¨äºŽï¼Œå®ƒä¿è¯äº†ä¸¤ä¸ªæŒ‡é’ˆ pa å’Œ pb åœ¨ç›¸é‡å‰ï¼Œèµ°è¿‡çš„æ€»è·¯ç¨‹æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼

æˆ‘ä»¬æ¥åˆ†è§£ä¸€ä¸‹è·¯ç¨‹ï¼š

- è®¾é“¾è¡¨ A çš„ç‹¬æœ‰éƒ¨åˆ†é•¿åº¦ä¸º `a`ï¼Œé“¾è¡¨ B çš„ç‹¬æœ‰éƒ¨åˆ†é•¿åº¦ä¸º `b`ï¼Œå…¬å…±éƒ¨åˆ†é•¿åº¦ä¸º `c`ã€‚
    
- `pa` çš„æ—…ç¨‹ï¼šå…ˆèµ°å®Œ A çš„ç‹¬æœ‰éƒ¨åˆ† `a`ï¼Œå†èµ°å®Œå…¬å…±éƒ¨åˆ† `c`ï¼Œç„¶åŽè½¬åˆ° B çš„å¼€å¤´ï¼Œèµ°å®Œ B çš„ç‹¬æœ‰éƒ¨åˆ† `b`ã€‚æ€»è·¯ç¨‹ = `a + c + b`ã€‚
    
- `pb` çš„æ—…ç¨‹ï¼šå…ˆèµ°å®Œ B çš„ç‹¬æœ‰éƒ¨åˆ† `b`ï¼Œå†èµ°å®Œå…¬å…±éƒ¨åˆ† `c`ï¼Œç„¶åŽè½¬åˆ° A çš„å¼€å¤´ï¼Œèµ°å®Œ A çš„ç‹¬æœ‰éƒ¨åˆ† `a`ã€‚æ€»è·¯ç¨‹ = `b + c + a`ã€‚
    

ä½ çœ‹ï¼`a + c + b` å’Œ `b + c + a` å®Œå…¨ç›¸ç­‰ï¼å› ä¸ºä¸¤ä¸ªæŒ‡é’ˆé€Ÿåº¦ç›¸åŒï¼Œèµ°çš„è·¯ç¨‹ä¹Ÿç›¸åŒï¼Œæ‰€ä»¥å®ƒä»¬**å¿…ç„¶ä¼šåœ¨æŸä¸ªæ—¶åˆ»ç›¸é‡**ã€‚å¦‚æžœå­˜åœ¨äº¤ç‚¹ï¼Œå®ƒä»¬å°±ä¼šåœ¨ç¬¬ä¸€ä¸ªäº¤ç‚¹ä¸Šç›¸é‡ï¼›å¦‚æžœä¸å­˜åœ¨äº¤ç‚¹ (`c=0`)ï¼Œå®ƒä»¬ä¼šåœ¨èµ°å®Œ `a+b` çš„è·¯ç¨‹åŽï¼ŒåŒæ—¶åˆ°è¾¾ç»ˆç‚¹ `nil`ã€‚

---

#### **æ–¹æ³•äºŒï¼šå“ˆå¸Œé›†åˆæ³• â€”â€” â€œæˆ‘èµ°è¿‡çš„è·¯éƒ½åšäº†æ ‡è®°â€**

è¿™ä¸ªæ–¹æ³•éžå¸¸ç›´è§‚ï¼Œå®¹æ˜“ç†è§£ï¼Œæ˜¯å…¸åž‹çš„ç”¨ç©ºé—´æ¢æ—¶é—´çš„æ€è·¯ã€‚

**æ€è·¯ï¼š**

1. å…ˆéåŽ†ä¸€æ¡é“¾è¡¨ï¼ˆæ¯”å¦‚ `headA`ï¼‰ï¼ŒæŠŠæ‰€æœ‰ç»è¿‡çš„èŠ‚ç‚¹çš„**å†…å­˜åœ°å€**éƒ½å­˜å…¥ä¸€ä¸ªå“ˆå¸Œé›†åˆ `set` ä¸­ã€‚
    
2. å†éåŽ†å¦ä¸€æ¡é“¾è¡¨ `headB`ï¼Œå¯¹äºŽ `headB` ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½åŽ» `set` ä¸­æŸ¥è¯¢ã€‚
    
3. ç¬¬ä¸€ä¸ªåœ¨ `set` ä¸­è¢«æŸ¥è¯¢åˆ°çš„ `headB` çš„èŠ‚ç‚¹ï¼Œå°±æ˜¯ä¸¤æ¡é“¾è¡¨çš„äº¤ç‚¹ã€‚
    
4. å¦‚æžœ `headB` éåŽ†å®Œäº†è¿˜æ²¡æ‰¾åˆ°ï¼Œè¯´æ˜Žæ²¡æœ‰äº¤ç‚¹ã€‚
    

**Go ä»£ç ç¤ºä¾‹ï¼š**

Go

```
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    set := make(map[*ListNode]struct{})
    
    // 1. å°†é“¾è¡¨ A çš„æ‰€æœ‰èŠ‚ç‚¹å­˜å…¥ Set
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        set[tmp] = struct{}{}
    }
    
    // 2. éåŽ†é“¾è¡¨ Bï¼Œæ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨äºŽ Set ä¸­
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        if _, ok := set[tmp]; ok {
            return tmp // æ‰¾åˆ°äº†ç¬¬ä¸€ä¸ªäº¤ç‚¹
        }
    }
    
    return nil
}
```

- **æ—¶é—´å¤æ‚åº¦**: O(m+n)
    
- **ç©ºé—´å¤æ‚åº¦**: O(m) æˆ– O(n)
    

---

#### **æ–¹æ³•ä¸‰ï¼šé•¿åº¦å·®æ³• â€”â€” â€œè®©ä½ å…ˆè·‘å‡ æ­¥ï¼Œæˆ‘ä»¬å†ä¸€èµ·èµ°â€**

è¿™ä¹Ÿæ˜¯ä¸€ä¸ªç©ºé—´å¤æ‚åº¦ä¸º O(1) çš„æ–¹æ³•ï¼Œæ€è·¯éžå¸¸æ¸…æ™°ã€‚

**æ€è·¯ï¼š**

1. åˆ†åˆ«éåŽ†ä¸¤æ¡é“¾è¡¨ï¼Œå¾—åˆ°å®ƒä»¬çš„é•¿åº¦ `lenA` å’Œ `lenB`ã€‚
    
2. è®¡ç®—å‡ºé•¿åº¦å·® `diff = abs(lenA - lenB)`ã€‚
    
3. è®©**è¾ƒé•¿**çš„é‚£æ¡é“¾è¡¨çš„æŒ‡é’ˆï¼Œ**å…ˆèµ° `diff` æ­¥**ã€‚
    
4. çŽ°åœ¨ï¼Œä¸¤ä¸ªæŒ‡é’ˆè·ç¦»å®ƒä»¬å„è‡ªçš„ç»ˆç‚¹ï¼Œè·¯ç¨‹å°±ä¸€æ ·é•¿äº†ï¼
    
5. ç„¶åŽè®©ä¸¤ä¸ªæŒ‡é’ˆ**åŒæ­¥å‰è¿›**ï¼Œå®ƒä»¬ç¬¬ä¸€æ¬¡ç›¸é‡çš„èŠ‚ç‚¹ï¼Œå°±æ˜¯äº¤ç‚¹ã€‚
    

**Go ä»£ç ç¤ºä¾‹ï¼š**

Go

```
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    lenA, lenB := 0, 0
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        lenA++
    }
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        lenB++
    }

    // pa æŒ‡å‘é•¿é“¾è¡¨ï¼Œpb æŒ‡å‘çŸ­é“¾è¡¨
    pa, pb := headA, headB
    if lenB > lenA {
        pa, pb = headB, headA
    }

    // é•¿é“¾è¡¨çš„æŒ‡é’ˆå…ˆèµ° diff æ­¥
    diff := lenA - lenB
    if lenB > lenA {
        diff = lenB - lenA
    }
    for i := 0; i < diff; i++ {
        pa = pa.Next
    }
    
    // ä¸¤ä¸ªæŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›´åˆ°ç›¸é‡
    for pa != pb {
        pa = pa.Next
        pb = pb.Next
    }
    
    return pa
}
```

- **æ—¶é—´å¤æ‚åº¦**: O(m+n)
    
- **ç©ºé—´å¤æ‚åº¦**: O(1)
    

---

### **æ€»ç»“ä¸€ä¸‹å–µ~ ðŸ’–**

| æ–¹æ³•        | æ—¶é—´å¤æ‚åº¦  | ç©ºé—´å¤æ‚åº¦       | ä¼˜ç‚¹          |
| --------- | ------ | ----------- | ----------- |
| **åŒæŒ‡é’ˆæ³•**  | O(m+n) | O(1)        | ä»£ç æœ€ç®€æ´ã€æ€è·¯æœ€å·§å¦™ |
| **å“ˆå¸Œé›†åˆæ³•** | O(m+n) | O(m) æˆ– O(n) | æ€è·¯æœ€ç›´è§‚ã€å®¹æ˜“æƒ³åˆ°  |
| **é•¿åº¦å·®æ³•**  | O(m+n) | O(1)        | æ€è·¯æ¸…æ™°ï¼Œå®¹æ˜“ç†è§£   |

ä¸»äººä½ å†™çš„æ­£æ˜¯ç¬¬ä¸€ç§æ–¹æ³•ï¼Œå®ƒé€šå¸¸è¢«è®¤ä¸ºæ˜¯è¿™é“é¢˜æœ€ä¼˜é›…çš„è§£æ³•å“¦ï¼(ï½¡ã‚Ï‰ï½¥)bâœ§