喵呜~ 主人，我们又见面啦！(｡˃ ᵕ ˂ )♡

这道“K次取反后最大化的数组和”也是一道非常经典的贪心问题呢！它非常考验我们如何把“贪心”这个想法，通过不同的策略，一步步优化，最终变成最优雅的代码。

你在这个问题上，从最开始的两次排序，到优化成一次排序，再到我们一起学习了“代码随想录”里那个更有针对性的排序方法，这一整个思考过程非常完整和宝贵。现在，就让我来为你把这趟精彩的旅程，整理成一份详细的笔记吧！

---

### LeetCode 1005. K次取反后最大化的数组和

**[力扣题目链接](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)**

#### 题目描述

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 `i` 并将 `A[i]` 替换为 `-A[i]`，然后总共重复这个过程 `K` 次。（我们可以多次选择同一个索引 `i`。）

以这种方式修改数组后，返回数组可能的最大和。

---

### 我们的思考之旅：如何做出最“贪心”的选择？

这个问题的核心，在于我们的每一次“取反”操作，都应该让最终的和**增加得最多**，或者**减少得最少**。

1. **当有负数时**: 翻转一个负数（比如 `-5` 变成 `5`），总和会增加 `10`。翻转一个绝对值越大的负数，总和增加得就越多。所以我们的贪心策略是：**优先翻转绝对值最大的负数**。
    
2. **当全是正数时**: 如果我们还剩下翻转次数，就不得不翻转正数了。翻转一个正数（比如 `5` 变成 `-5`），总和会减少 `10`。为了让损失最小，我们应该选择**绝对值最小的正数**来翻转。
    

我们探索的三种思路，都是围绕这个核心贪心策略展开的，只是实现的方式越来越巧妙！

---

### 三种思路的演进与实现 (Go语言)

#### 思路一：最直观的两次排序法

这是我们最开始想到的方法，思路非常朴素和直接，完全符合人的直觉。

- **思考过程**:
    
    1. 要想优先翻转最小的负数，最简单的办法就是**按数值从小到大排序**。
        
    2. 排序后，我们从头遍历，把所有负数都翻转成正数，直到 `K` 用完或者没有负数为止。
        
    3. 翻转后，数组的顺序被打乱了。如果此时 `K` 还有剩余，并且是奇数，我们就需要翻转一次那个当前数组中最小的数。为了找到它，最简单的办法就是**再排序一次**。
        
    4. 最后求和。
        
- **代码实现**:
    
    Go
    
    ```
    import "sort"
    
    // 解法一：两次排序
    func largestSumAfterKNegations_twoSorts(nums []int, k int) int {
        // 第一次排序：按数值从小到大
        sort.Ints(nums)
    
        // 翻转所有负数
        for i := 0; i < len(nums) && k > 0; i++ {
            if nums[i] < 0 {
                nums[i] = -nums[i]
                k--
            } else {
                break
            }
        }
    
        // 第二次排序：为了找到当前数组的最小值
        sort.Ints(nums)
    
        // 如果K还剩下奇数次，则将当前数组的最小值翻转
        if k%2 == 1 {
            nums[0] = -nums[0]
        }
    
        sum := 0
        for _, num := range nums {
            sum += num
        }
        return sum
    }
    ```
    
- **评价**: 逻辑正确，思路清晰。但进行了两次排序（O(n log n)），在效率上不是最优的。
    

#### 思路二：优化！用一次遍历代替第二次排序

这是我们在思路一基础上的优化，我们发现第二次排序的“目的性”太强了，有点“杀鸡用牛刀”。

- **思考过程**: 我们第二次排序的目的，仅仅是为了**找到一个最小值**。而找最小值，根本不需要对整个数组进行排序，我们只需要**从头到尾遍历一遍**就可以啦！
    
- **代码实现**:
    
    Go
    
    ```
    import (
        "math"
        "sort"
    )
    
    // 解法二：一次排序 + 一次遍历
    func largestSumAfterKNegations_oneSort(nums []int, k int) int {
        // 第一次排序，必不可少
        sort.Ints(nums)
    
        // 翻转所有负数
        for i := 0; i < len(nums) && k > 0; i++ {
            if nums[i] < 0 {
                nums[i] = -nums[i]
                k--
            } else {
                break
            }
        }
    
        // 如果K还有剩余，并且是奇数
        if k%2 == 1 {
            // 优化点：不再排序，而是用一次遍历找到最小值
            minVal := math.MaxInt
            for _, num := range nums {
                if num < minVal {
                    minVal = num
                }
            }
            // 使用一个数学技巧来修正总和，避免修改数组
            // sum -= 2 * minVal 也可以，这里为了清晰先求和再减
        }
    
        sum := 0
        // ... (求和逻辑与上面类似，但要结合上面的minVal处理)
        // 一个更简洁的写法是在求和时一起处理
        minVal := math.MaxInt
        for _, num := range nums {
            if num < minVal {
                minVal = num
            }
            sum += num
        }
        if k%2 == 1 {
            sum -= 2 * minVal
        }
        return sum
    }
    ```
    
- **评价**: 效率得到提升！我们将一个 O(n log n) 的操作替换为了 O(n) 的操作，是算法优化中常见的思路。
    

#### 思路三：优雅的“一步到位”排序法 (代码随想录思路)

这是我们一起学习的、更巧妙的贪心策略。它通过一次“有针对性”的排序，一劳永逸地解决了所有问题。

- **思考过程**: 我们贪心的目标，其实都和**绝对值**有关（翻转绝对值大的负数，翻转绝对值小的正数）。那为什么我们不直接**按绝对值来排序**呢？
    
- **代码实现**:
    
    Go
    
    ```
    import "sort"
    
    // 解法三：按绝对值大小排序
    func largestSumAfterKNegations_absSort(nums []int, k int) int {
        // 关键的第一步：按绝对值从大到小排序
        sort.Slice(nums, func(i, j int) bool {
            // math.Abs需要float64，我们直接比较乘积来避免类型转换
            // 为了清晰，还是用标准的math.Abs
            return math.Abs(float64(nums[i])) > math.Abs(float64(nums[j]))
        })
    
        // 遍历，翻转所有负数
        for i := 0; i < len(nums); i++ {
            if nums[i] < 0 && k > 0 {
                nums[i] = -nums[i]
                k--
            }
        }
    
        // 如果K还剩下奇数次，直接翻转最后一个元素
        // 因为按绝对值从大到小排序，最后一个一定是绝对值最小的数！
        if k%2 == 1 {
            nums[len(nums)-1] = -nums[len(nums)-1]
        }
    
        sum := 0
        for _, num := range nums {
            sum += num
        }
        return sum
    }
    ```
    
- **评价**: 非常优雅！通过一次自定义排序，同时满足了“优先翻转绝对值大的负数”和“找到绝对值最小的数”这两个需求，避免了任何额外的排序或遍历。
    

---

### 总结与心得 (´▽`ʃ♡ƪ)

主人，你看，解决同一个问题，我们可以有这么多不同的思路，而且思路在不断地演进和优化！

- **思路一**是我们的**直觉**，它能保证做对。
    
- **思路二**是我们的**优化**，它体现了对效率的思考。
    
- **思路三**是我们的**升华**，它展现了抓住问题本质、一招制敌的算法之美。
    

能够完整地理解这三种思路的演变，说明你对贪心算法的理解已经非常深入啦！为你感到骄傲！(つ´ω`)つ