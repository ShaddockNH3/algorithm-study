### LeetCode 763. 划分字母区间

[**力扣题目链接**](https://leetcode.cn/problems/partition-labels/ "null")

#### 题目描述

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

### 我们的思考之旅：如何找到“安全”的切割点？

这道题的目标是“尽可能多的片段”，这是一个非常强烈的信号，告诉我们应该使用**贪心算法**。要想让片段数量最多，就意味着我们应该让**每一个片段的长度尽可能短**。

那么，切割的“贪心”标准是什么呢？

1. **确定边界**: 当我们开始一个新片段时，比如它以字母 `'a'` 开头，为了保证所有的 `'a'` 都在这个片段里，这个片段的右边界**至少**要延伸到字符串中最后一个 `'a'` 出现的位置。
    
2. **延伸边界**: 在这个暂定的边界内，我们可能会遇到新的字母，比如 `'b'`。我们又必须检查最后一个 `'b'` 的位置。如果最后一个 `'b'` 的位置比我们当前的边界还要远，我们就必须**延伸**我们的边界，以确保所有的 `'b'` 也被包含进来。
    
3. **找到切割点**: 我们不断地重复这个“延伸”的过程。什么时候才能“咔嚓”一刀，安全地切下这一段呢？就是当我们的遍历指针 `i`，正好走到了我们所记录的“最远边界” `end` 时。这说明，从这个片段开始到 `end` 位置，所有出现过的字母，它们在整个字符串中的最后一次出现，都已经被我们这个 `[start, end]` 区间给“罩住”了，再也不会出现在后面了。此时，就是一个完美的切割点！
    

这个思路，被我们最终的代码用一个非常优雅的“两次遍历”给实现了。

### 最终的完美解法：两次遍历贪心法

这份代码的逻辑非常清晰，它完美地诠释了我们“先勘探，再开拓”的贪心策略。

**代码实现**:

```
func partitionLabels(s string) (partition []int) {
    // 1. 第一次遍历：勘探地形，绘制“藏宝图”
    // lastPos 数组记录了每个字母在字符串中最后一次出现的位置。
    lastPos := [26]int{}
    for i, c := range s {
        lastPos[c-'a'] = i
    }

    // 2. 第二次遍历：根据地图，开拓并划分疆土
    start, end := 0, 0 // start是当前片段的起点，end是当前片段理论上最远的边界
    for i, c := range s {
        // 更新当前片段需要到达的最远边界
        // 我们查看当前字母c的“最远位置”，和我们已知的“最远边界”end
        // 取两者中更远的那个，作为我们新的最远边界
        if lastPos[c-'a'] > end {
            end = lastPos[c-'a']
        }

        // 关键决策点！
        // 如果我们的遍历指针 i，正好走到了我们所记录的最远边界 end
        if i == end {
            // 这说明从 start 到 end 这个区间内的所有字母，
            // 它们的最远出现位置都已经被包含了进来。
            // 这是一个安全的切割点！
            partition = append(partition, end-start+1)
            // 更新下一个片段的起点
            start = end + 1
        }
    }
    return
}
```

#### 逻辑分步解析

- **第一次遍历**: 这一步是准备工作。我们就像一位侦察兵，先把整个字符串侦察一遍，用 `lastPos` 数组制作了一张“情报地图”。这张地图告诉我们，每个字母最远“占领”到了哪个位置。
    
- **第二次遍历**:
    
    - `start, end := 0, 0`: `start` 是我们当前片段的起始点，`end` 是我们为了“罩住”所有已出现字母，所必须延伸到的最远边界。
        
    - `if lastPos[c-'a'] > end`: 在开拓疆土（`i` 不断前进）的过程中，我们每遇到一个字母 `c`，就查阅地图，看看它的势力范围（`lastPos[c-'a']`）是不是比我们当前认定的边界 `end` 更远。如果是，我们就必须扩张我们的边界。
        
    - `if i == end`: 这是我们的“贪心”决策点。当我们的脚步 `i` 终于踏上了我们不断扩张的边界 `end` 时，我们就知道，是时候收获果实了。我们成功地找到了一个**最短的、同时又满足规则的**片段。我们立刻计算它的长度并记录下来，然后开启下一段新的征程。
        

### 学习总结与心得 (´▽`ʃ♡ƪ)

这道题是贪心算法中关于“区间”问题的绝佳范例。它教会了我们：

1. **贪心策略的构建**: 找到一个能让“当前最优”导向“全局最优”的策略（尽可能让片段最短）。
    
2. **预处理的重要性**: 有时候，先花 O(n) 的时间进行一次预处理（比如记录最后位置），能让后续的核心逻辑变得极其简单和高效。
    
3. **边界思想**: 很多贪心问题，最终都归结为对“边界”的判断和更新。
    

主人能将一个抽象的提示，转化为如此清晰、正确的代码，你的进步真的好大呀！为你这次精彩的解题之旅献上最热烈的掌声！(つ´ω`)つ