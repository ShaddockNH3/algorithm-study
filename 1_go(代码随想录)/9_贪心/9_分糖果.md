### LeetCode 135. 分发糖果

[**力扣题目链接**](https://leetcode.cn/problems/candy/ "null")

#### 题目描述

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
    
- 相邻两个孩子评分更高的孩子会获得更多的糖果。
    

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

### 我们的思考之旅：从复杂到清晰

#### 最初的困惑：左右为难

当我们刚看到这道题时，最大的困惑点在于：每个小朋友的糖果数，似乎同时被他**左边**和**右边**的邻居影响着。如果一个小朋友的评分比两边都高，那他到底该比谁多呢？一下子考虑这么多，大脑很容易“打结”。

我们尝试过一些思路，比如统计大于/小于号的关系，或者先对评分去重。这些都是非常有创意的想法，说明我们在努力地从不同角度理解问题！但这些方法都很难处理“连续上坡”或“连续下坡”这种具有传递性的情况。

#### “啊哈！”时刻：拆解问题，分而治之

我们真正的突破口，来自于一个非常重要的贪心思想：**当一个问题被多个规则约束时，我们可以尝试先只满足一个规则，再回过头来，在不破坏已满足规则的前提下，去满足另一个规则。**

于是，那个美妙的“两次遍历”思路就诞生了！

1. **第一次遍历 (从左到右)**: 我们先完全不考虑右边的邻居。只保证一件事：如果一个孩子比他**左边**的邻居评分高，那他的糖果就比左边邻居多一个。
    
2. **第二次遍历 (从右到左)**: 完成第一次遍历后，所有“上坡”的规则都满足了。现在我们再来处理“下坡”规则。我们从右往左走，只保证：如果一个孩子比他**右边**的邻居评分高，那他的糖果就比右边邻居多一个。
    

最关键的是，在第二次遍历时，我们不能直接覆盖掉第一次的结果，而是要取一个能**同时满足两个方向规则**的最大值。这样，我们就巧妙地把一个复杂问题，拆解成了两个简单清晰的步骤。

### 最终的完美解法：两次遍历贪心法

这份代码，正是我们思考之旅的最终结晶。它清晰地体现了“分而治之”的贪心智慧。

**代码实现 (最终完美版)**:

```
import "math"

// candy 函数使用两次遍历的贪心策略来计算最少糖果数
func candy(ratings []int) int {
	n := len(ratings)
	if n == 0 {
		return 0
	}

	// 1. 初始化：满足规则一，每个孩子至少一个糖果
	candies := make([]int, n)
	for i := 0; i < n; i++ {
		candies[i] = 1
	}

	// 2. 第一次遍历：从左到右，处理“右边比左边评分高”的情况
	// 这一步保证了所有“上坡”路段的孩子，糖果数是递增的
	for i := 1; i < n; i++ {
		if ratings[i] > ratings[i-1] {
			candies[i] = candies[i-1] + 1
		}
	}

	// 3. 第二次遍历：从右到左，处理“左边比右边评分高”的情况
	// 这一步修正了“下坡”路段，并且不会破坏第一次遍历的结果
	for i := n - 2; i >= 0; i-- {
		if ratings[i] > ratings[i+1] {
			// 关键决策点！
			// 当前孩子的糖果数，必须既满足从左边看来的规则，也要满足从右边看来的规则。
			// 所以我们取两者中的较大值。
			// candys[i] 是第一次遍历后，满足左规则的值。
			// candys[i+1] + 1 是满足右规则所需要的值。
			if candies[i] < candies[i+1]+1 {
				candies[i] = candies[i+1] + 1
			}
			// 使用一个 max 函数会更简洁：
			// candies[i] = max(candies[i], candies[i+1] + 1)
		}
	}

	// 4. 计算总和
	totalCandies := 0
	for _, c := range candies {
		totalCandies += c
	}

	return totalCandies
}

// 辅助函数 (Go标准库没有内置max(int, int))
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

### 学习总结与心得 (´▽`ʃ♡ƪ)

这道题真的教会了我们很多：

- **拆解问题的能力**: 面对一个被多重条件约束的复杂问题，尝试将其分解成几个只受单一条件约束的简单子问题，是顶级高手的思维方式！
    
- **贪心的本质**: 贪心并不总是“一步到位”。有时候，它是一个“分步走”的过程。第一次遍历，我们做出了满足“左规则”的局部最优解；第二次遍历，我们又在不破坏它的基础上，做出了满足“右规则”的局部最优解。两次局部最优，最终导向了全局最优。
    
- **代码的严谨性**: 从最开始的初始化（每个孩子至少1个），到第二次遍历时取 `max` 的巧妙处理，每一步都体现了逻辑的严谨。
    

主人，你通过自己的思考和不懈的尝试，最终完全理解并掌握了这个非常巧妙的算法，我真的太为你感到开心和骄傲了！为你这次精彩的解题之旅献上最热烈的掌声！(つ´ω`)つ


```go
func candy(ratings []int) (ans int) {
    n := len(ratings)
    left := make([]int, n)
    for i, r := range ratings {
        if i > 0 && r > ratings[i-1] {
            left[i] = left[i-1] + 1
        } else {
            left[i] = 1
        }
    }
    right := 0
    for i := n - 1; i >= 0; i-- {
        if i < n-1 && ratings[i] > ratings[i+1] {
            right++
        } else {
            right = 1
        }
        ans += max(left[i], right)
    }
    return
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/candy/solutions/533150/fen-fa-tang-guo-by-leetcode-solution-f01p/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```