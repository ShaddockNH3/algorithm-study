### LeetCode 435. 无重叠区间

[**力扣题目链接**](https://leetcode.cn/problems/non-overlapping-intervals/ "null")

#### 题目描述

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 _需要移除区间的最小数量，使剩余区间互不重叠_ 。

**注意** 只在一点上接触的区间是 **不重叠的**。例如 `[1, 2]` 和 `[2, 3]` 是不重叠的。

### 我们思考的核心：贪心选择

在开始探索两种具体的实现方法之前，我们先确立我们共同的、最核心的贪心策略，这也是整个解法的灵魂！

1. **第一步：排序** 为了能方便地比较相邻的区间，我们首先要让它们变得有序。最直观的方法就是**按照区间的左边界（`start`）从小到大排序**。
    
2. **第二步：做出贪心选择** 当两个区间（比如 `A` 和 `B`）发生重叠时，我们必须移除一个。为了给后面的区间留出尽可能多的空间，我们应该做出什么样的选择呢？
    
    > **贪心选择：总是保留那个“结束得更早”的区间，移除那个“结束得更晚”的区间。**
    
    因为结束得早，意味着我们的“时间线”能更早地空闲下来，从而有更大的希望能接纳后续的、更多的区间。
    

我们接下来要记录的两种思路，都是围绕这个核心贪心策略展开的，只是它们在代码中的“表现形式”不同而已哦~

### 思路一：“修改跑道”法 —— 在原数组上记录状态 (你的原创思路！)

这是主人你自己独创的思路哦！它非常聪明，因为它尝试在不使用额外变量的情况下，通过**修改数组本身**来传递“下一次应该和谁比较”这个状态。

**思考过程**:

1. 我们先按左边界排序。
    
2. 然后从第二个区间开始，依次比较 `intervals[i]` 和 `intervals[i-1]`。
    
3. 如果它们重叠了 (`intervals[i-1][1] > intervals[i][0]`)，我们就知道必须移除一个 (`count++`)。
    
4. 接下来是最关键的一步：为了让下一次循环（`i+1`）能和**被我们保留下来的那个区间**进行比较，我们需要更新状态。
    
    - 如果我们决定**保留 `intervals[i-1]`**（因为它结束得更早），我们就得想办法让 `i+1` 和 `intervals[i-1]` 比较。一个巧妙的办法就是，**用 `intervals[i-1]` 的值去覆盖 `intervals[i]`**。这样，在下一次循环中，新的 `intervals[i]` 其实就是我们保留下来的 `intervals[i-1]` 啦！
        
    - 如果我们决定**保留 `intervals[i]`**（因为它结束得更早），我们什么都不用做。因为下一次循环，自然就会用 `intervals[i+1]` 和 `intervals[i]` 进行比较，这正是我们想要的！
        

**代码实现 (修正后)**:

```
import "sort"

// 解法一：通过修改数组来传递状态
func eraseOverlapIntervals_modifyArray(intervals [][]int) int {
	if len(intervals) < 2 {
		return 0
	}
	// 1. 按左边界排序
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

	count := 0
	for i := 1; i < len(intervals); i++ {
		// 2. 检查与前一个区间的重叠情况
		// 注意：这里的 intervals[i-1] 可能是上一次循环保留下来的优胜者
		if intervals[i][0] < intervals[i-1][1] {
			// 发生重叠，必须移除一个
			count++
			// 3. 贪心决策：谁的右边界更小，谁就成为新的“前一个区间”
			// 以便和 i+1 继续比较
			if intervals[i][1] > intervals[i-1][1] {
				// 如果前一个区间结束得更早，我们就保留它
				// 通过把它“传递”给当前区间，来影响下一次循环
				intervals[i] = intervals[i-1]
			}
			// 如果当前区间 intervals[i] 结束得更早，我们什么都不用做
			// 它自然会成为下一次循环的 intervals[i-1]
		}
	}
	return count
}
```

- **优点**: 构思非常巧妙，在原地完成了操作，空间复杂度为 O(1)。
    
- **缺点**: 在遍历的过程中修改被遍历的数组，会让代码的逻辑变得晦涩难懂，是大家通常会尽量避免的写法，容易出错。
    

### 思路二：“设立路标”法 —— 用变量记录边界 (经典解法)

这是我们后来优化的、更常规也更清晰的思路。我们不修改跑道，而是派一个小小的“裁判”（变量），站在我们保留的最后一个区间的终点线上。

**思考过程**:

1. 同样先按左边界排序。
    
2. 我们不需要修改数组，只需要一个变量 `end_boundary` 来记录**当前已确定的、不重叠区间的“最右边界”**。
    
3. 我们遍历所有区间，用每个区间的左边界和 `end_boundary` 比较。
    
    - **如果不重叠** (`intervals[i][0] >= end_boundary`)：太好了！说明这个区间可以被保留。我们就把它变成我们新的参考，更新 `end_boundary` 为这个区间的右边界。
        
    - **如果重叠** (`intervals[i][0] < end_boundary`)：必须移除一个 (`count++`)。移除谁呢？当然是结束得晚的那个。所以，我们只需要把 `end_boundary` 更新为**两者中更小的那个右边界**，这就相当于我们保留了结束得早的那个区间。
        

**代码实现**:

```
import "sort"

// 解法二：用变量记录右边界（推荐！）
func eraseOverlapIntervals(intervals [][]int) int {
	if len(intervals) < 2 {
		return 0
	}
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

	count := 0
	// end_boundary 记录我们保留的最后一个区间的右边界
	end_boundary := intervals[0][1]

	for i := 1; i < len(intervals); i++ {
		// 如果当前区间与我们保留的最后一个区间重叠了
		if intervals[i][0] < end_boundary {
			count++ // 必须移除一个
			// 贪心决策：更新边界为两者中更早结束的那个
			if intervals[i][1] < end_boundary {
				end_boundary = intervals[i][1]
			}
		} else {
			// 如果不重叠，就更新边界，把它作为新的参考
			end_boundary = intervals[i][1]
		}
	}
	return count
}
```

- **优点**: 逻辑非常清晰，代码易于理解和维护，是解决此类问题的标杆性写法。
    
- **缺点**: 使用了一个额外的变量（但这点消耗可以忽略不计啦~）。
    

### 总结与心得 (´▽`ʃ♡ƪ)

主人你看，这两份代码，内心深处流淌的都是**同一个贪心策略的血液**，但它们的外表和“性格”却截然不同！

- **思路一**像一个喜欢挑战、不走寻常路的天才，构思精巧但略显复杂。
    
- **思路二**则像一个沉稳可靠的大师，每一步都清晰明了，稳扎稳打。
    

能够理解并实现这两种方法，特别是能把自己独特的思考过程也打磨正确，这真的太了不起了！为你感到骄傲！(つ´ω`)つ