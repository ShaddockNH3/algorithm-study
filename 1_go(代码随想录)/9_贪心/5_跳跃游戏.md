喵呜~ 主人，我们终于来到了这道“跳跃游戏”的终点站！(｡˃ ᵕ ˂ )♡

从最开始那个模拟“油量”的巧妙想法，到一步步打磨，再到领悟那个更宏观、更优雅的“最远距离”解法，你在这个过程中的每一步思考都闪烁着智慧的光芒。

现在，就让我为你把这两种同样正确、但视角不同的美妙思路，都仔細地整理成一份永久珍藏的学习笔记吧！

---

### LeetCode 55. 跳跃游戏

**[题目链接](https://leetcode.cn/problems/jump-game/)**

#### 题目描述

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

---

### 两种思路的深度剖析

这道题是考验我们“贪心”思维的经典题目。我们可以用两种不同的“贪心”角度来解决它，它们都非常聪明哦！

#### 思路一：飞行器的巡航 —— 关心“我还能跳多远？”

这是主人你最开始想到的、非常形象生动的解法哦！我们把自己想象成一个穿着飞行背包的人，`current` 变量就是我们背包里的剩余油量。

**核心思想**:

1. **初始油量**: 从起点 `nums[0]` 出发，获得初始油量 `nums[0]`。
    
2. **消耗与补充**: 我们一步一步（`i++`）向前走，每走一步就消耗 `1` 点油量 (`current--`)。
    
3. **贪心决策**: 每到达一个新的位置 `i`，我们都会比较一下“我手里剩下的油”和“这个位置能给我补充的油 `nums[i]`”，我们总是选择那个能让我们飞得更远的油量，即 `current = max(current, nums[i])`。
    
4. **失败条件**: 如果在还没到达终点时，我们的油量就耗尽了 (`current == 0`)，那就说明我们被困住了，任务失败。
    

**代码实现**:

Go

```go
// 解法一：模拟“剩余步数/油量”
func canJump_fuelMethod(nums []int) bool {
    if len(nums) == 1 {
        return true
    }

    // current 代表我们可用的“剩余步数”
    current_fuel := 0
    for i := 0; i < len(nums)-1; i++ {
        // 在当前位置i，我们总是选择一个更大的剩余步数
        // 1. nums[i]: 从当前位置i起跳，能提供的步数
        // 2. current_fuel: 从之前某个位置跳过来后，到i这里时还剩的步数
        if nums[i] > current_fuel {
            current_fuel = nums[i]
        }
        
        // 如果油量耗尽，就失败了
        if current_fuel == 0 {
            return false
        }
        
        // 每走一步，消耗一点油量
        current_fuel--
    }

    // 如果能走完循环，说明成功到达
    return true
}
```

- **优点**: 思路非常直观，贴近现实生活的模拟，容易理解。
    
- **缺点**: 代码逻辑中的 `current--` 和 `max` 的更新交织在一起，需要仔细思考才能确保其正确性。
    

---

#### 思路二：王者的征程 —— 关心“我的疆土能扩张多远？”

这是解决此问题的最经典、最高效的贪心解法。我们不再关心“剩下多少油”，而是站在一个更高的视角，关心我们能触及的“最远边界”。

**核心思想**:

1. **初始疆土**: 我们维护一个变量 `max_reach`，代表从起点出发，我们已知的、能够到达的最远位置的下标。
    
2. **扩张疆土**: 我们一步步地遍历数组。每踏上一片新的土地 `i`（前提是这片土地在我们的疆土范围之内，即 `i <= max_reach`），我们就在这片土地上插上新的旗帜，计算出从这里能到达的更远方 `i + nums[i]`，并用它来尝试更新（扩张）我们的 `max_reach`。
    
3. **胜利/失败条件**:
    
    - **胜利**: 如果在任何时候，我们的 `max_reach` 已经覆盖了终点（`>= len(nums) - 1`），那么征途就已经胜利了。
        
    - **失败**: 如果我们尝试踏上的土地 `i`，已经超出了我们已知的疆土范围（`i > max_reach`），那就说明我们后继无人，永远也到不了这里了，征途失败。
        

**代码实现 (最终完美版)**:

Go

```
// 解法二：记录“最远可达距离”
func canJump(nums []int) bool {
    max_reach := 0
    // i 是我们当前想访问的位置
    for i, jump_power := range nums {
        // 如果当前位置 i 已经超出了我们能到达的最远距离，说明失败
        if i > max_reach {
            return false
        }

        // 更新我们的最远可达距离
        new_reach := i + jump_power
        if new_reach > max_reach {
            max_reach = new_reach
        }
        
        // 剪枝优化：如果最远距离已经能覆盖终点，直接胜利
        if max_reach >= len(nums)-1 {
            return true
        }
    }

    // 如果循环能正常走完（虽然上面的剪枝通常会提前返回）
    return true
}
```

- **优点**: 逻辑非常清晰、简洁，代码优雅。是解决此类问题的标杆性思路。
    
- **缺点**: 需要将思维从“剩余多少”转变为“最远能到哪里”，需要一个小小的视角切换。
    

### 总结一下喵~

|对比维度|思路一 (飞行器巡航)|思路二 (王者征程)|
|---|---|---|
|**思考角度**|微观：关心每一步的剩余能量|宏观：关心可触及的边界|
|**核心变量**|`current_fuel` (剩余步数)|`max_reach` (最远下标)|
|**代码风格**|模拟过程，步步为营|贪心扩张，目标明确|
|**优雅指数**|⭐⭐⭐⭐|⭐⭐⭐⭐⭐ (强烈推荐！)|

主人，你凭借自己的努力，不仅独立想出了第一种完全正确的解法，还通过提示，迅速理解并掌握了第二种更优雅的解法。这两种思维方式都是你宝贵的财富！为你这次精彩的征途鼓掌！(つ´ω`)つ