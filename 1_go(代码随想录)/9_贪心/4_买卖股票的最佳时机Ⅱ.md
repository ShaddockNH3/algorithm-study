喵呜~ 主人，我们又回到这道有趣的股票问题啦！(｡˃ ᵕ ˂ )♡

经过我们上次的讨论，你不但找到了解法，还对不同解法的优劣进行了深入的思考，这真的太棒了！为了让你对这道题的理解更加深刻和系统，就让我们把这两种闪烁着不同智慧光芒的思路，都整整齐齐地记录在我们的学习笔记里吧！

---

### LeetCode 122. 买卖股票的最佳时机 II

**[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**

#### 题目描述

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回你能获得的 **最大** 利润。

---

### 两种思路的深度剖析

这道题是经典的贪心算法问题，我们可以从两个不同的角度来思考，它们最终会得到相同的正确答案，但思考路径和代码的优雅程度却截然不同哦。

#### 思路一：登山者的智慧 —— 寻找完整的“波峰”与“波谷”

这是主人你最初想到的方法，非常直观！就像一位经验丰富的登山者，我们把价格曲线看作连绵的山脉，我们的目标就是在每一个山谷（Valley）的底部买入，然后在接下来遇到的第一个山峰（Peak）的顶部卖出。

**核心思想**:

1. 找到一个价格的“谷底”（比后一天价格低的点）。
    
2. 从这个谷底出发，一直往上爬，直到找到价格的“波峰”（比后一天价格高的点）。
    
3. 计算“波峰”与“波谷”的差价，计入总利润。
    
4. 然后，从这个波峰之后的位置，继续寻找下一个“谷底”，重复以上过程。
    

**代码实现**:

Go

```
// 解法一：寻找波峰波谷
func maxProfit_peakValley(prices []int) int {
    if len(prices) <= 1 {
        return 0
    }

    maxProfit := 0
    i := 0
    for i < len(prices)-1 {
        // 步骤1：找到一个谷底（价格不再下降的地方）
        for i < len(prices)-1 && prices[i] >= prices[i+1] {
            i++
        }
        valley := prices[i] // 这就是我们的买入点

        // 步骤2：找到一个波峰（价格不再上升的地方）
        for i < len(prices)-1 && prices[i] <= prices[i+1] {
            i++
        }
        peak := prices[i] // 这就是我们的卖出点

        // 步骤3：计算利润并累加
        maxProfit += peak - valley
    }

    return maxProfit
}
```

- **优点**: 思路非常符合直觉，很好理解，就像是现实中我们做波段交易的策略一样。
    
- **缺点**: 代码相对复杂，需要用循环来控制指针的移动，处理边界情况时需要格外小心，不然容易出错。
    

---

#### 思路二：美食家的哲学 —— 品尝每一份“正收益”

这是这道题最经典、最优雅的贪心解法。我们不再纠结于完整的“波峰”和“波谷”，而是像一位美食家，只要眼前有一口好吃的（有利润），就绝不错过！

**核心思想**:

我们把整个交易过程分解到每一天。从第二天开始，我们只关注一件事：**今天的价格是不是比昨天高？**

- 如果 `prices[i] > prices[i-1]`，那就说明昨天到今天有利润可图。我们就把这部分利润 `prices[i] - prices[i-1]` 累加起来。
    
- 我们不关心明天是涨是跌，只赚取所有“上涨”部分带来的利润。
    

这个策略的奇妙之处在于，所有连续上涨日的利润之和，等于在这段上涨的起点买入、终点卖出的利润。

例如，价格从1涨到5 (1 -> 3 -> 5)：

- 我们的方法是 `(3-1) + (5-3) = 2 + 2 = 4`。
    
- 波峰波谷法是 5 - 1 = 4。
    
    两者在数学上是完全等价的！
    

**代码实现**:

Go

```
// 解法二：贪心算法 (累加所有正利润)
func maxProfit(prices []int) int {
    maxProfit := 0
    // 从第二天开始遍历
    for i := 1; i < len(prices); i++ {
        // 只要今天的价格比昨天高，就累加利润
        if prices[i] > prices[i-1] {
            maxProfit += prices[i] - prices[i-1]
        }
    }
    return maxProfit
}
```

- **优点**: 代码极其简洁、优雅、清晰！只需要一次遍历和一个 `if` 判断，完全不需要复杂的指针控制，也不容易出错。
    
- **缺点**: 思路相对抽象一点，可能需要稍微思考一下才能理解其正确性。
    

### 总结一下喵~

|对比维度|思路一 (波峰波谷法)|思路二 (每日收益贪心法)|
|---|---|---|
|**核心思想**|找到完整的上涨区间，低买高卖|累加所有上涨日的微小利润|
|**代码复杂度**|较高，需要小心处理指针和边界|极低，非常简洁|
|**直观程度**|非常直观，模拟现实交易|较为抽象，需要理解数学等价性|
|**推荐指数**|⭐⭐⭐|⭐⭐⭐⭐⭐ (强烈推荐！)|

主人能把这两种思路都掌握，说明你的思维既能做到严谨缜密（思路一），又能做到灵活变通、化繁为简（思路二），真的太了不起了！(つ´ω`)つ