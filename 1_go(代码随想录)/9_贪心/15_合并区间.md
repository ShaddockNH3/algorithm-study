### LeetCode 56. 合并区间

[**力扣题目链接**](https://leetcode.cn/problems/merge-intervals/ "null")

#### 题目描述

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。

### 我们思考的核心：贪心策略的基石 —— 排序

无论是哪种解法，我们都离不开一个最关键、最基础的步骤：**排序**。

为了能方便地、有条不紊地处理区间，我们必须先让它们变得有序。最直观也是最有效的方法，就是将所有区间按照**左边界（`start`）从小到大**进行排序。

**为什么这么做？** 因为排序后，我们就可以保证，当我们处理第 `i` 个区间时，所有可能与它重叠的区间，在排序后的数组里一定都紧挨在它前面。我们只需要回头看，而不需要担心后面还没处理的区间会跳回来和它重叠。这为我们的贪心策略奠定了坚实的基础。

```
// 排序是所有贪心策略的基础
sort.Slice(intervals, func(i, j int) bool {
    return intervals[i][0] < intervals[j][0]
})
```

### 思路一：“独立变量”法 —— 用 `start` 和 `end` 追踪

这是主人你最开始尝试的思路，它非常直观，就像我们手动在草稿纸上合并区间一样。

**核心思想**:

1. 我们用两个独立的变量 `start` 和 `end` 来维护**当前正在合并的这个大区间**。
    
2. 初始时，这个大区间就是排序后的第一个区间。
    
3. 我们从第二个区间开始遍历，用每个新区间来和我们手上的 `[start, end]` 比较。
    
    - **情况A (无重叠)**: 如果新来的区间的左边界，大于我们手上区间的 `end`，说明它们分开了。我们就把手上这个合并好的 `[start, end]` 区间放入最终结果集，然后用这个新区间来开启一个新的合并过程（更新 `start` 和 `end`）。
        
    - **情况B (有重叠)**: 如果有重叠，我们就不需要开启新区间，而是要**扩张**我们手上这个区间的右边界 `end`，让它等于两者中更大的那个右边界 `max(end, new_interval_end)`。
        
4. **一个常见的陷阱**: 循环结束后，我们手上还拿着**最后一个**合并好的区间，千万不要忘记把它也加入结果集哦！
    

**代码实现**:

```
import "sort"

// 解法一：使用独立变量来追踪当前合并的区间
func merge_vars(intervals [][]int) [][]int {
	if len(intervals) <= 1 {
		return intervals
	}
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

	// 初始化结果集为一个空的篮子
	merged := make([][]int, 0)
	// 初始化第一个合并区间
	start := intervals[0][0]
	end := intervals[0][1]

	for i := 1; i < len(intervals); i++ {
		// 情况A：新区间与当前合并区间不重叠
		if intervals[i][0] > end {
			// 将上一个合并好的区间放入结果集
			merged = append(merged, []int{start, end})
			// 开启一个新的合并区间
			start = intervals[i][0]
			end = intervals[i][1]
		} else {
			// 情况B：有重叠，更新右边界
			if intervals[i][1] > end {
				end = intervals[i][1]
			}
		}
	}

	// 千万不要忘记把最后一个合并好的区间也放进去！
	merged = append(merged, []int{start, end})

	return merged
}
```

- **优点**: 思路非常贴近手动计算的过程，容易理解。
    
- **缺点**: 需要额外的 `start` 和 `end` 变量，并且很容易忘记在循环结束后处理最后一个区间，容易出错。
    

### 思路二：“直接操作结果集”法 —— 更优雅、更安全 (推荐！)

这是我们后来讨论的、更不容易出错的实现方式。我们不使用额外的临时变量，而是直接在最终的结果集 `merged` 上进行判断和操作。

**核心思想**:

1. 同样先排序。
    
2. 我们先把**第一个区间**直接放入结果集 `merged`，把它作为我们第一个合并好的基准。
    
3. 我们从第二个区间开始遍历，每次都拿当前区间 `intervals[i]`，去和结果集 `merged` 里的**最后一个区间**进行比较。
    
    - **情况A (有重叠)**: 如果当前区间的左边界，小于等于结果集里最后一个区间的右边界，说明它们重叠了。我们**不需要**添加新区间，而是直接**更新**结果集里最后一个区间的右边界，让它扩张到两者中更大的那个。
        
    - **情况B (无重叠)**: 如果不重叠，说明这是一个全新的、独立的区间。我们就直接把它 `append` 到结果集的末尾。
        

**代码实现**:

```
import "sort"

// 解法二：直接在结果集上进行比较和操作
func merge(intervals [][]int) [][]int {
	if len(intervals) <= 1 {
		return intervals
	}
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

	// 先把第一个区间作为基准放入结果集
	merged := [][]int{intervals[0]}

	for i := 1; i < len(intervals); i++ {
		// 获取结果集中的最后一个区间
		last_interval := merged[len(merged)-1]

		// 情况A：有重叠
		if intervals[i][0] <= last_interval[1] {
			// 直接更新结果集中最后一个区间的右边界
			if intervals[i][1] > last_interval[1] {
				merged[len(merged)-1][1] = intervals[i][1]
			}
		} else {
			// 情况B：不重叠，直接将新区间加入结果集
			merged = append(merged, intervals[i])
		}
	}

	return merged
}
```

- **优点**: 逻辑非常清晰，代码健壮。因为每一步都在维护最终的结果集，所以不会有初始化或遗漏结尾的问题。
    
- **缺点**: 可能需要稍微习惯一下直接操作结果集末尾元素的这种写法。
    

### 总结与心得 (´▽`ʃ♡ƪ)

主人你看，这两份代码，虽然实现细节不同，但它们的“心脏”都是那个“**先排序，再贪心**”的策略。

- **思路一**更像是一位按部就班的**会计**，用临时账本记录，最后再统一入账。
    
- **思路二**则像是一位经验丰富的**仓库管理员**，直接在货架上整理和合并货物。
    

能够完整地理解并实现这两种方法，说明你对区间问题的理解已经非常透彻和灵活啦！为你感到无比的骄傲！(つ´ω`)つ