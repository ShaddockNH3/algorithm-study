### LeetCode 738. 单调递增的数字

[**力扣题目链接**](https://leetcode.cn/problems/monotone-increasing-digits/ "null")

#### 题目描述

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 _小于或等于 `n` 的最大数字，且数字呈 **单调递增**__ 。

### 我们思考的核心：贪心策略

这道题的贪心策略，我们已经一起总结出来了，那就是：**从右往左找到第一个破坏单调规则的“断崖”，将“断崖”前的数字减一，并将“断崖”后的所有数字都置为9。**

这个核心思想是不会变的，但如何找到这个“断崖”并进行修改，就有两种非常巧妙的实现方式啦！

### 思路一：你的巧思解法 —— “向前探索，回头修正”

这是主人你自己独立完成的、非常聪明的解法！它完美地体现了“发现问题，追溯源头”的思考过程。

**思考过程**:

1. **向前探索**: 我们从左到右遍历数字数组，这是最符合直觉的。
    
2. **发现问题**: 当我们找到第一个 `d[i-1] > d[i]` 的地方时，我们知道，这里出问题了！
    
3. **回头修正**: 我们意识到，真正需要修改的，可能不是 `d[i-1]` 本身，而是它左边和它相等的、那一串“平原”的起始点（比如 `1332` 中的第一个`3`）。所以，我们用一个精巧的内循环，从当前位置 `i` **回头往左**，找到这个平原的真正起点。
    
4. **执行修改**: 找到起点后，将其减一，并将该位置之后的所有数字都变成 `9`。
    

**代码实现 (你的杰作！)**:

```
import "strconv"

// 解法一：从左到右遍历，找到问题点再向左回溯
func monotoneIncreasingDigits_original(n int) int {
	digitsArray := IntToSlice(n) // 辅助函数见文末

	for i := 1; i < len(digitsArray); i++ {
		// 1. 向前探索，找到第一个“断崖”
		if digitsArray[i-1] > digitsArray[i] {
			// 2. 向左回溯，找到“平原”的起点
			for i >= 2 && digitsArray[i-1] == digitsArray[i-2] {
				i--
			}
			// 3. 修正：将起点减一
			digitsArray[i-1]--
			// 4. 铺平后续：将起点之后的所有位都变成9
			for j := i; j < len(digitsArray); j++ {
				digitsArray[j] = 9
			}
			return SliceToInt(digitsArray) // 辅助函数见文末
		}
	}
	// 如果没有断崖，直接返回原数
	return n
}
```

- **评价**: 非常聪明！准确地模拟了“追溯问题源头”的过程，逻辑完全正确。但因为有嵌套的、修改外层循环变量的逻辑，代码的流程稍微有点绕。
    

### 思路二：更优雅的解法 —— “从后往前，一次定位”

这是解决此问题更常见、代码流程更顺畅的一种思路。它不需要“回头”，因为它是倒着走的，最后遇到的问题，一定是最根本的问题。

**思考过程**:

1. **改变方向**: 我们**从右往左**遍历数字数组。
    
2. **寻找并记录**: 我们一路寻找“断崖” (`d[i] > d[i+1]`)。一旦找到，我们就知道 `d[i]` 这个位置需要被减一，并且它**后面**的所有位置，都将变成 `9`。我们用一个变量 `nine_start_index` 来记下这个“变成9的起始位置”。
    
3. **一锤定音**: 因为我们是从右往左走的，所以我们**最后一次**更新 `nine_start_index` 的位置，一定就是最靠左的那个、最根本的“断崖”位置。
    
4. **执行修改**: 遍历结束后，我们再根据最终的 `nine_start_index`，把从它开始到结尾的所有数字，一次性地全部刷成 `9`。
    

**代码实现 (更优美的版本)**:

```
import "strconv"

// 解法二：从右到左遍历，一次性找到最终修改点
func monotoneIncreasingDigits(n int) int {
	// 同样先转成数组（这里用字符串对应的[]byte更方便修改）
	s := []byte(strconv.Itoa(n))

	// nine_start_index 记录从哪个位置开始，后面的都要变成9
	// 初始时设为一个不可能的位置
	nine_start_index := len(s)

	// 1. 从右到左遍历
	for i := len(s) - 2; i >= 0; i-- {
		// 2. 寻找“断崖”
		if s[i] > s[i+1] {
			// 3. 修正断崖前的数字，并记下“9的起始点”
			s[i]--
			nine_start_index = i + 1
		}
	}

	// 4. 根据最后确定的起始点，将后续所有位变成9
	for i := nine_start_index; i < len(s); i++ {
		s[i] = '9'
	}

	// 最后再转换回数字
	res, _ := strconv.Atoi(string(s))
	return res
}
```

### 两种思路的对比与总结

|对比维度|思路一 (你的巧思)|思路二 (优雅解法)|
|---|---|---|
|**遍历方向**|从左到右找问题，再向左回溯|从右到左，一次性找到最终问题点|
|**代码结构**|嵌套循环，控制流略复杂|两个独立的简单循环，逻辑清晰|
|**核心思想**|发现问题 -> 追溯源头|倒序检查 -> 最后的问题才是真问题|

主人你看，两种方法都是正确的贪心，但**思路二**的代码结构更清晰，因为它把“寻找问题点”和“执行修改”这两个步骤，通过两次独立的、简单的循环分开了，从而避免了复杂的嵌套逻辑。

你不仅独立做出了第一种解法，还激发了对更优美解法的探索，这个学习和思考的过程真的太宝贵了！为你感到骄傲！(つ´ω`)つ