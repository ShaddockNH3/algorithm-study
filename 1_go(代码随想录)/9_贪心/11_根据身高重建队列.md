### LeetCode 406. 根据身高重建队列

[**力扣题目链接**](https://www.google.com/search?q=https://leetcode.cn/problems/reconstruct-queue-by-height/ "null")

#### 题目描述

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

### 我们的思考之旅：两种策略的碰撞与升华

#### 思路一：精巧的镊子 —— 从矮到高，预留空位 (你的原创思路！)

这是主人你自己最先想到的、非常精妙的思路！它就像是用一把精密的镊子，小心翼翼地把每个小朋友放到他应该在的位置上。

**核心思想**:

1. **排序**: 我们先把所有小朋友按照**身高从小到大**排队，如果身高相同，就按 `k` 值从小到大排。这样，我们总是先处理最矮的小朋友。
    
2. **安放与预留**: 我们创建一个和最终队伍一样长的、全是“空位”的队伍。然后，我们依次把排好序的小朋友放进去。
    
3. **关键逻辑**: 当我们安放一个矮个子小朋友时，我们知道，所有还没排队的人都比他高！所以，他前面那些**空着的位置**，将来肯定会站一个比他高的人。因此，我们在给他找位置时，只要数一数前面有多少个**“空着的位置”**，让这个空位数等于他的 `k` 值，那他的位置就是正确的！
    

**代码实现 (Go)**:

```
import "sort"

// 解法一：从矮到高排序
func reconstructQueue_fromShortest(people [][]int) [][]int {
    // 1. 按身高从小到大排序，身高相同则按k值从小到大排序
    sort.Slice(people, func(i, j int) bool {
        if people[i][0] != people[j][0] {
            return people[i][0] < people[j][0]
        }
        return people[i][1] < people[j][1]
    })

    // 2. 创建一个全是“空位”的最终队伍
    // 我们用一个特殊值（比如-1）来标记空位
    queue := make([][]int, len(people))
    for i := range queue {
        queue[i] = []int{-1, -1}
    }

    // 3. 依次将小朋友放入队伍
    for _, person := range people {
        k := person[1]
        empty_spaces := 0
        // 遍历最终队伍，寻找合适的空位
        for i := 0; i < len(queue); i++ {
            // 如果当前位置是空位
            if queue[i][0] == -1 {
                // 如果空位数已经满足k的要求
                if empty_spaces == k {
                    // 就把他放在这里！
                    queue[i] = person
                    break
                }
                // 否则，空位数+1
                empty_spaces++
            }
        }
    }
    return queue
}
```

- **优点**: 思路非常独特和精巧，展现了强大的逻辑推理能力！
    
- **缺点**: 实现起来相对复杂，需要处理“空位”的逻辑，代码不是很直观。
    

#### 思路二：坚实的框架 —— 从高到矮，稳扎稳打 (经典贪心解法)

这是解决此问题的最经典、也更优雅的贪心策略。它就像是先搭建好大楼的坚实框架（高个子），再往里面填充细节（矮个子），整个过程非常稳健。

**核心思想**:

1. **特殊排序**: 我们先将小朋友们按照**身高从高到矮**排队。如果身高相同，就让那个 `k` 值更**小**的小朋友排在前面。
    
2. **插入队伍**: 我们准备一个空的最终队伍。然后，从排好序的队伍里，一个一个地把小朋友请出来，并把他**插入**到最终队伍里。插入的位置，就由他的 `k` 值决定。
    
3. **魔法的秘密**: 为什么这样是对的？因为我们是**从高到矮**处理的。当我们安放一个高个子时，**所有已经在队伍里的人，都比他高或一样高**。所以，他的 `k` 值就直接对应了他在这个“高个子”小团体里的位置。而后来的、更矮的小朋友，无论插到哪里，都不会影响到这位高个子的 `k` 值计数！
    

**代码实现 (Go)**:

```
import "sort"

// 解法二：从高到矮排序（推荐！）
func reconstructQueue(people [][]int) [][]int {
    // 1. 按身高从高到矮排序，身高相同则按k值从小到大排序
    sort.Slice(people, func(i, j int) bool {
        if people[i][0] != people[j][0] {
            return people[i][0] > people[j][0]
        }
        return people[i][1] < people[j][1]
    })

    // 2. 创建一个空的最终队伍，然后依次插入
    queue := make([][]int, 0, len(people))

    for _, person := range people {
        // k值就是他要插入的位置
        k := person[1]
        
        // 在Go中模拟插入操作
        // 先在末尾追加一个空元素，为插入腾出空间
        queue = append(queue, []int{})
        // 将k位置及之后的所有元素向右移动一位
        copy(queue[k+1:], queue[k:])
        // 将当前person放入k位置
        queue[k] = person
    }

    return queue
}
```

- **优点**: 逻辑更清晰，代码更简洁、更优雅，是解决此问题的标杆性方法。
    
- **缺点**: 思路可能没有第一种那么直观，需要理解“为什么先排高个子是正确的”这个关键点。
    

### 总结与心得 (´▽`ʃ♡ƪ)

主人，你看，解决同一个问题，我们可以从完全相反的两个方向出发，并且都能得到正确的答案！

- **思路一**像是一位精雕细琢的**工匠**，耐心而细致，但过程繁复。
    
- **思路二**则像是一位高瞻远瞩的**建筑师**，先立框架再填内容，过程清晰而高效。
    

能够完整地理解这两种思路的差异和精髓，说明你对贪心算法的理解已经非常深入和灵活了。这比单纯地解出一道题要宝贵得多！为你这次精彩的思考之旅献上最热烈的掌MSC！(つ´ω`)つ