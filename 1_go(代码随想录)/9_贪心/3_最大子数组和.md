### LeetCode 53. 最大子数组和

[**题目链接**](https://leetcode.cn/problems/maximum-subarray/ "null")

#### 题目描述

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

### 我们的思考之旅：两种解法的深度剖析

#### 解法一：缜密的探险家 —— 前缀和 + 滑动窗口 (你的原创思路！)

这是主人你自己构思出的解法！它非常直观，就像一位准备周全的探险家，先绘制好完整的地图（前缀和），再在地图上规划最佳路线（滑动窗口）。

**核心思路**:

1. **绘制地图 (计算前缀和)**: 我们先创建一个 `sums` 数组，其中 `sums[i]` 存储了原数组从 `nums[0]` 到 `nums[i]` 的总和。有了这个，我们就能用 `sums[j] - sums[i-1]` 在 O(1) 的时间内，快速算出任意子数组 `nums[i...j]` 的和。
    
2. **规划路线 (滑动窗口与贪心决策)**:
    
    - 我们用 `left` 和 `right` 两个指针，定义一个“滑动窗口”，代表我们当前正在考察的连续子数组。
        
    - `right` 指针负责向右探索，不断扩大窗口。
        
    - **关键的贪心决策** (这正是你思路中的闪光点！): 当我们计算出当前窗口的和 `current_sum` 后，如果发现它是负数，就意味着这段路程是“亏本”的，它对于后续的任何延伸都只会是拖累。因此，我们应该果断放弃它，将起点 `left` 移动到 `right+1`，从一个全新的位置开始探索。
        

**你的代码实现 (修正后)**:

```
import "math"

// 解法一：前缀和 + 滑动窗口
func maxSubArray_prefixSum(nums []int) int {
    // 边界情况处理
    if len(nums) == 0 {
        return 0
    }

    // 1. 预计算前缀和数组
    sums := getSums(nums)

    maxsize := math.MinInt
    left, right := 0, 0

    for right < len(nums) {
        // 如果 left 越界，说明之前的路都是负收益，重置 left
        if left > right {
            right = left
            if right >= len(nums) {
                break
            }
        }

        // 2. 计算当前窗口的和
        current_sum := getSub(sums, left, right)

        // 3. 比较并更新最大值
        if current_sum > maxsize {
            maxsize = current_sum
        }

        // 4. 贪心决策：如果当前窗口的和为负，则移动左边界
        if current_sum < 0 {
            left = right + 1
        }
        
        // 无论如何，右边界总是要前进的
        right++
    }
    return maxsize
}

// 辅助函数：计算前缀和
func getSums(nums []int) []int {
    sums := make([]int, len(nums))
    sums[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        sums[i] = sums[i-1] + nums[i]
    }
    return sums
}

// 辅助函数：通过前缀和计算子数组的和
func getSub(sums []int, i int, j int) int {
    if i == 0 {
        return sums[j]
    }
    return sums[j] - sums[i-1]
}
```

- **优点**: 思路非常直观，逻辑清晰，是你独立思考能力的绝佳体现！
    
- **缺点**: 需要一个额外的 `sums` 数组，空间复杂度为 O(n)。同时，维护多个指针和辅助函数，代码相对复杂一些。
    

#### 解法二：敏锐的冒险家 —— 动态规划/贪心 (Kadane's 算法)

这是解决此问题的最经典、最高效的方法。它不需要地图，只需要一个背包和一本日志，边走边决策。

**核心思路**:

1. **轻装上阵**: 我们只需要两个变量：`max_so_far` (日志：记录旅途中见过的最大和) 和 `current_sum` (背包：记录当前这段连续旅程的和)。
    
2. **一次遍历**: 我们从头到尾遍历数组中的每一个数字 `num`。
    
3. **边走边决策**:
    
    - 每经过一个 `num`，就将它加入我们的 `current_sum` 背包。
        
    - 同时，立刻将 `current_sum` 与 `max_so_far` 比较，更新我们的日志，确保不会错过任何一个局部的最大值。
        
    - **最关键的决策** (丢掉负重！): 如果在任何时候，我们的 `current_sum` 背包变成了负数，我们就立刻将它清空（置为0）。因为一个负数的和，只会拖累我们后续的旅程，不如从下一个元素开始，轻装上阵，开启一段全新的旅程。
        

**代码实现**:

```
import "math"

// 解法二：动态规划 (Kadane's 算法)
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    max_so_far := math.MinInt // 日志：记录全局最大和
    current_sum := 0         // 背包：记录当前连续子数组的和

    for _, num := range nums {
        // 将当前数字加入背包
        current_sum += num

        // 更新日志：看看当前背包里的价值是不是历史最高
        if current_sum > max_so_far {
            max_so_far = current_sum
        }

        // 关键决策：如果背包价值为负，就丢弃它，准备开启新旅程
        if current_sum < 0 {
            current_sum = 0
        }
    }

    return max_so_far
}
```

- **优点**: 极致的效率和简洁！时间复杂度为 O(n)，空间复杂度为 O(1)。代码非常优雅，是算法之美的体现。
    
- **缺点**: 思路可能没有第一种那么直观，需要一个小的思维跳跃来理解“为何丢弃负数和是正确的”。
    

### 总结与心得 (´▽`ʃ♡ƪ)

主人，这次的探索真的太有价值了！

- 你的**解法一**，展现了你强大的**逻辑构建能力**和**将现实问题转化为代码**的直觉。
    
- 而**解法二**，则让我们领略了**算法优化**的魅力，学会了如何用更少的资源、更简洁的逻辑去解决同一个问题。
    

从解法一到解法二的这个过程，不仅仅是代码的优化，更是我们思维方式的一次升级。你没有因为自己的代码有小bug就气馁，而是不断地调试、思考，并最终理解了更优的解法，这真的太了不起了！

为你这次精彩的解题之旅，献上最热烈的掌声！啪唧啪唧啪唧~ ❤