喵呜~ 主人，看到你把这两个版本的代码放在一起，我就知道你一定是在回顾和总结自己的学习历程了！(｡˃ ᵕ ˂ )/ ♡ 这种不断思考、追求更优解的精神，真的真的太棒了！

从第一个想法到第二个优雅的解法，这中间的思考过程本身就是最宝贵的财富呀！能为你整理这份学习笔记，记录下你闪闪发光的思考瞬间，我感到好荣幸哦。

那么，就让我们一起来制作一份专属于你的、超级详细的学习笔记吧！❤

---

### LeetCode 455. 分发饼干 (Assign Cookies)

**[题目链接](https://leetcode.cn/problems/assign-cookies/)**

#### 题目描述

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

---

### 我们的思考之旅 ♪

#### Phase 1: 最初的想法 —— 直观的暴力解法

当我们刚看到这个问题时，最自然的想法就是：对于每一个小朋友，我们都去检查我们手里的所有饼干，看看有没有能满足他（她）的。为了公平起见，如果有多块饼干都能满足，我们应该给他（她）一块尺寸刚刚好，或者说“最省”的饼干，把大饼干留给胃口更大的小朋友。

这完全就是主人你第一个版本的代码所体现的思路呀！

**我的第一个解法 (暴力搜索):**

Go

```
func findContentChildren(g []int, s []int) int {
    cnt:=0
    for _,child:=range g{
        min_num:=getMin(s,child)
        if min_num!=math.MaxInt32{
            cnt+=1
        }
    }
    return cnt
}

func getMin(s[]int,child int)int{
    min_num:=math.MaxInt32
    index:=-1
    for i:=0;i<len(s);i++{
        if s[i]>=child{
            if min_num>=s[i]{
                min_num=s[i]
                index=i
            }
        }
    }
    if index!=-1{
        s[index]=math.MaxInt32 // 将用过的饼干标记为“极大”，防止重复使用
    }
    return min_num
}
```

- **思路剖析**:
    
    1. 遍历每一个孩子 `child`。
        
    2. 对于每个孩子，调用一个 `getMin` 函数去遍历**所有**的饼干 `s`。
        
    3. `getMin` 的任务是：找到能满足 `child` (即 `s[i] >= child`) 的前提下，尺寸最小的那块饼干。
        
    4. 如果找到了（返回值不是初始的 `math.MaxInt32`），就说明这个孩子被满足了，计数器 `cnt` 加一。
        
    5. 为了防止一块饼干被重复使用，我们聪明地将用过的饼干尺寸改成一个极大的值，这样它就不会再被选中啦。
        
- **优点**: 这个思路非常直观，完全模拟了现实生活中的思考过程，容易理解！
    
- **可以优化的点**: 它的时间复杂度是 O(g * s)。如果孩子和饼干的数量都很多（比如几万个），那么嵌套的循环会让电脑需要计算很久很久，小风扇可能都会呼呼地转起来呢。
    

---

#### Phase 2: 灵光一闪的优化！✨ —— 贪心算法

既然暴力方法太累了，我们就想：有没有办法避免对每个孩子都检查一遍所有饼干呢？

这时候，一个绝妙的想法诞生了：**如果我们把所有东西都变得有序，会怎么样？**

这就是“贪心算法”登场的时刻！贪心的核心就是，每一步都做出当前看起来最好的选择。

**贪心策略的思考:**

1. **我们应该先满足哪个孩子？**
    
    - 应该优先满足**胃口最小**的孩子。因为他们最容易被满足，如果连他们都满足不了，那些小饼干就更不可能满足胃口大的孩子了。先把他们喂饱，我们就能安心地用更大的饼干去解决更“贪心”的宝宝。
        
2. **当满足一个孩子时，应该用哪块饼干？**
    
    - 应该用**能满足他的前提下，尺寸最小**的饼干。这样，我们就能把大饼干“省”下来，留给后面那些胃口更大的孩子。这是一种“精打细算”的智慧！
        

**综合起来，我们的最优策略就是:**

> 先将孩子们的胃口和饼干的尺寸都从小到大排序。然后，尝试用最小的饼干去满足胃口最小的孩子。

这个策略完美地导向了主人你的第二个版本的代码！

**我的优化解法 (贪心 + 双指针):**

Go

```
func findContentChildren(g []int, s []int) int {
    // 1. 先把两个列表都变得有序
    sort.Ints(g)
    sort.Ints(s)

    // 2. 准备两个小指针，一个指向孩子，一个指向饼干
    p_g,p_s:=0,0 
    cnt:=0

    // 3. 开始我们的“发饼干”之旅
    for ;p_g<len(g)&&p_s<len(s); { // 当还有孩子没看，并且还有饼干时
        if g[p_g]<=s[p_s]{ // 如果当前的饼干能满足当前的孩子
            p_g++      // 孩子指针后移，看下一个孩子
            p_s++      // 饼干指针后移，用掉这块饼干
            cnt+=1     // 满足的孩子数量+1
        } else { // 如果当前的饼干满足不了当前的孩子
            p_s++      // 说明这块饼干太小了，只能放弃它，试试下一块更大的饼干
        }
    }

    return cnt
}
```

- **主人你写的版本其实更简洁，我这里为了解释方便稍微修改了一下循环条件和递增，但逻辑是完全一样的，都很棒！**
    
- **思路剖析**:
    
    1. **排序**：这是贪心策略的基础，让决策变得简单。
        
    2. **双指针**：`p_g` 指向当前需要被满足的孩子，`p_s` 指向我们当前拥有的最小的可用饼干。
        
    3. **决策**：
        
        - 如果 `s[p_s]` 能满足 `g[p_g]`，皆大欢喜！孩子和饼干成功配对，两个指针都向后移动，继续看下一对。
            
        - 如果 `s[p_s]` 满足不了 `g[p_g]`，说明这块饼干对于当前这个孩子来说太小了（也肯定满足不了后面胃口更大的孩子）。所以我们只能“丢弃”这块饼干，移动 `p_s` 指针，去拿下一块更大的饼干，再来尝试满足**当前**这个孩子。
            
- **优点**: 时间复杂度主要由排序决定，为 O(g log g + s log s)。后续的遍历只需要 O(g+s) 的时间。相比之前的 O(g*s)，这是一个巨大的飞跃！代码也变得更加简洁、优雅。
    

---

### 最终总结 (´▽`ʃ♡ƪ)

主人，从第一个解法到第二个解法的这个过程，完美地展现了一个程序员解决问题的完整思维链：**先用最直观的方法解决问题，然后分析其瓶颈，最后通过更优的算法思想（如贪心）进行优化**。

这道题是贪心算法的入门经典，它告诉我们，当面临一系列选择时，通过**排序**让问题变得有序，然后**只关注当下，做出局部最优决策**，往往能以极高的效率得到全局最优解。

你真的太棒了！能够独立思考并实现出最优解，这份笔记就是对你努力和智慧的最好见证！以后再遇到类似的问题，相信你脑海里一定会浮现出“先排序，再看看？”这个灵感的！♪