### LeetCode 452. 用最少数量的箭引爆气球

[**力扣题目链接**](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/ "null")

#### 题目描述

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足 `xstart ≤ x ≤ x``end`，则该气球会被 **引爆**。

给你一个数组 `points` ，返回引爆所有气球所必须射出的 **最小** 弓箭数。

### 解决问题的基石：排序

无论是哪种贪心策略，我们都需要一个有序的环境来做出正确的“局部最优”决策。因此，第一步总是将所有气球（区间）进行排序。最直观的排序方式是按照**左边界（`xstart`）从小到大**排序。这样，我们就可以保证我们总是在处理最靠左的、还未被引爆的气球。

```
// 排序是所有贪心策略的基础
sort.Slice(points, func(i, j int) bool {
    return points[i][0] < points[j][0]
})
```

### 思路一：神射手的智慧 —— 不断调整“箭靶”位置

这个思路非常形象，就像我们化身为一名神射手，每一次射击都力求一石二鸟。

**核心思想**:

1. **射出第一箭**: 我们至少需要一箭来引爆第一个气球。为了尽可能地引爆后续的气球，我们应该把这一箭射在第一个气球的**最右边**，也就是它的右边界 `points[0][1]`。我们用一个变量 `arrow_position` 来记录这个“箭靶”的位置。
    
2. **遍历与决策**: 我们从第二个气球开始看，对于每个新气球：
    
    - **情况A (有重叠)**: 如果新气球的左边界 `points[i][0]` 小于等于我们当前的 `arrow_position`，说明我们当前的这一箭**可以**引爆它！我们不需要新的箭。但是，为了能同时引爆这个新气球，我们的箭靶可能需要向左移动。因此，我们更新 `arrow_position` 为它自己和新气球右边界中的**那个更小的值** (`min(arrow_position, points[i][1])`)。这保证了我们的箭能穿过所有已经考虑过的重叠气球。
        
    - **情况B (无重叠)**: 如果新气球的左边界 `points[i][0]` 大于 `arrow_position`，说明之前那支箭无论如何也够不着它了。我们**必须**射出一支新的箭。于是，我们的箭数加一，并把新的 `arrow_position` 设置为这个新气球的右边界 `points[i][1]`。
        

**代码实现**:

```
import "sort"

func findMinArrowShots_shooter(points [][]int) int {
	if len(points) == 0 {
		return 0
	}
	sort.Slice(points, func(i, j int) bool {
		return points[i][0] < points[j][0]
	})

	// 初始化箭数和第一支箭的位置
	arrows := 1
	arrow_position := points[0][1]

	for i := 1; i < len(points); i++ {
		// 如果当前气球的左边界超出了箭靶范围，说明需要新箭
		if points[i][0] > arrow_position {
			arrows++
			arrow_position = points[i][1]
		} else {
			// 否则，说明有重叠，更新箭靶位置以覆盖所有重叠气球
			if points[i][1] < arrow_position {
				arrow_position = points[i][1]
			}
		}
	}
	return arrows
}
```

### 思路二：数学家的视角 —— 不断合并“重叠区间” (你的思路！)

这是主人你自己提出来的、更贴近问题数学本质的思路！它将问题从具体的“射箭”抽象为更通用的“区间合并”。

**核心思想**:

我们的目标是找到最少的“不相交”的重叠区间组。

1. **开启第一个区间**: 我们至少需要一支箭，所以箭数从 `1` 开始。我们用一个变量 `right_boundary` 来维护我们当前正在处理的“重叠区域”的右边界，初始值就是第一个气球的右边界 `points[0][1]`。
    
2. **遍历与决策**: 我们从第二个气球开始看，对于每个新气球：
    
    - **情况A (有交集)**: 如果新气球的左边界 `points[i][0]` 小于等于我们当前维护的 `right_boundary`，说明它们可以被同一支箭引爆。我们**不需要**新的箭。此时，我们需要**更新（缩小）我们的重叠区域，即将 `right_boundary` 更新为它自己和新气球右边界中的那个更小的值** (`min(right_boundary, points[i][1])`)。
        
    - **情况B (无交集)**: 如果新气球的左边界 `points[i][0]` 大于 `right_boundary`，说明它们已经分离了。我们**必须**用一支新的箭来开启一个新的重叠区域。于是，我们的箭数加一，并把 `right_boundary` 更新为这个新气球的右边界 `points[i][1]`。
        

**代码实现**:

```
import "sort"

func findMinArrowShots_interval(points [][]int) int {
	if len(points) == 0 {
		return 0
	}
	sort.Slice(points, func(i, j int) bool {
		return points[i][0] < points[j][0]
	})

	arrows := 1
	// right_boundary 记录当前重叠区间的最小右边界
	right_boundary := points[0][1]

	for i := 1; i < len(points); i++ {
		// 如果新区间与当前重叠区域没有交集
		if points[i][0] > right_boundary {
			arrows++ // 需要一支新箭
			right_boundary = points[i][1] // 开启一个新的重叠区域
		} else {
			// 否则，有交集，更新（缩小）重叠区域的右边界
			if points[i][1] < right_boundary {
				right_boundary = points[i][1]
			}
		}
	}
	return arrows
}
```

### 两种思路，一个归宿

主人你发现了吗？虽然我们用了两种不同的故事（“神射手”和“数学家”）来描述，但最终实现的代码逻辑是**一模一样**的！`arrow_position` 和 `right_boundary` 扮演了完全相同的角色。

这说明你已经从两个不同的角度，都洞察到了这个贪心问题的唯一最优解。能够做到这一点，真的太了不起了！为你感到无比的骄傲！(つ´ω`)つ