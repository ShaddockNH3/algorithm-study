喵~ 主人，你好呀！(｡･ω･｡)ﾉ♡

看见你整理了这么多关于二分查找的题目和代码，我真的好为你开心！这说明你正在系统地学习和征服这个算法世界里非常非常重要的知识点。从最基础的查找，到寻找边界，再到计算平方根，你已经把二分查找的几种核心应用都探索了一遍，真的太棒了！

为了庆祝你的进步，也为了让你以后回顾起来更方便，我来帮你把这些珍贵的学习成果，整理成一份超级详细、超级可爱的“二分查找完全征服笔记”吧！

---

### **二分查找 · 完全征服笔记 💖**

#### **1. 喵~ 什么是二分查找？(Binary Search)**

二分查找不是一个具体的函数，而是一种美妙的 **算法思想**。

**核心思想** 🧠

> 在一个 **有序** 的集合中，通过每次将搜索范围 **缩小一半** 来快速定位目标。

**超级重要的前提** ‼️

> 集合 **必须** 是 **有序的**！这就像一个魔法契约，没有它，二分查找的魔法就会失效。

**为什么它那么快？(O(logn))**

> 想象一下在一部 1024 页的字典里找一个单词。你不会一页一页翻（这是 O(n)）。你会先翻到中间第 512 页，看要找的单词在前半部分还是后半部分，一下就排除了 512 页！如此反复，每次都排除一半，很快就能找到。这就是对数级别的威力，即使数据量巨大，查找次数也增长得非常缓慢。

---

#### **2. 最基础的模板：寻找一个确切的值 (LeetCode 704)**

这是二分查找最经典、最纯粹的形式，就像是我们学习走路的第一步。

**🎯 目标：** 在一个没有重复元素的有序数组中，找到 `target` 的位置。找到了就返回下标，找不到就返回 `-1`。

**主人你的完美代码：**

Go

```
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    // 1. 只要搜索区间 [left, right] 还存在，就继续
    for left <= right {
        mid := left + (right - left) / 2 // 防溢出的mid计算法，非常棒！
        
        // 2. 核心的三段式判断
        if nums[mid] == target {
            // 找到了！直接返回，任务完成！
            return mid
        } else if nums[mid] > target {
            // 中间值太大了，目标肯定在左边
            right = mid - 1
        } else { // nums[mid] < target
            // 中间值太小了，目标肯定在右边
            left = mid + 1
        }
    }
    // 3. 循环结束了还没找到，说明不存在
    return -1
}
```

**小结**：这个模板非常适合处理 **没有重复元素** 且 **只要求找到一个就行** 的场景。

---

#### **3. 重要的变种I：寻找边界 (LeetCode 35, 34)**

这是二分查找的第一个重要升级！我们不再满足于“找到就行”，而是要精确地找到一个“**位置**”，比如“它应该被插入的位置”或“它第一次出现的位置”。

**🎯 目标：**

- **LeetCode 35**：找到 `target` 的插入位置。
    
- **LeetCode 34**：找到 `target` 的起始和结束位置。
    

这两个问题的核心，都是在寻找 **“左侧边界”**。也就是，找到第一个 **大于或等于** `target` 的元素的位置。

**心态转变** 🐾

> 当我们使用基础模板时，`nums[mid] == target` 意味着成功。但在寻找左边界时，`nums[mid] == target` 仅仅意味着 `mid` 是一个**潜在**的答案，我们必须尝试继续向左寻找，看看有没有更靠前的答案。

**寻找左侧边界的模板 (主人的 `searchLeft` 思想)：**

Go

```
// 这是一个更纯粹的“寻找左边界”函数
func findLeftBoundary(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right - left) / 2
        
        if nums[mid] >= target {
            // 中间值大于或等于目标，说明它可能是答案，
            // 或者答案在它的左边。我们向左收缩！
            right = mid - 1
        } else { // nums[mid] < target
            // 中间值小于目标，那答案一定在它的右边。
            left = mid + 1
        }
    }
    // 循环结束后，left 就是第一个 >= target 的位置
    return left
}
```

**如何应用这个强大的模板？**

- **解决 LeetCode 35 `searchInsert`**:
    
    - 这个模板返回的 `left`，直接就是 `target` 的插入位置！所以 `searchInsert` 函数其实就是 `findLeftBoundary` 函数。
        
- **解决 LeetCode 34 `searchRange`**:
    
    - **找起始位置**: 就是 `target` 的左侧边界，直接调用 `leftBound := findLeftBoundary(nums, target)`。
        
    - **找结束位置**: 这是最巧妙的地方！我们可以去找 `target + 1` 的左侧边界，然后把结果减 1！`rightBound := findLeftBoundary(nums, target + 1) - 1`。
        
    - **别忘了检查！**: 找到 `leftBound` 后，一定要检查 `nums[leftBound]` 是不是真的等于 `target`，否则就说明 `target` 根本不存在。
        

---

#### **4. 重要的变种II：在概念空间上二分 (LeetCode 69, 367)**

二分查找不仅能用在给定的数组上，还能用在一个**概念上、逻辑上**的有序空间里！比如从 0 到 x 的所有整数。

**🎯 目标：**

- **LeetCode 69**：计算 `x` 的整数平方根。
    
- **LeetCode 367**：判断 `num`是不是一个完全平方数。
    

这两个问题的本质，都是在 `[0, x]` 这个数字范围内，寻找一个满足特定条件的**边界**。对于 `mySqrt(x)`，我们要寻找**最大的整数 `k`，使得 `k*k <= x`**。

**主人你的完美代码 (寻找右侧边界的变种)：**

Go

```
func mySqrt(x int) int {
    if x == 0 || x == 1 {
        return x
    }
    left, right := 1, x
    var ans int
    for left <= right {
        mid := left + (right - left) / 2
        // 使用 mid <= x/mid 来防止 mid*mid 溢出，非常严谨！
        if mid <= x / mid { 
            // 如果 mid 的平方 <= x，说明 mid 是一个可能的答案。
            // 我们把它记下来，然后去右边尝试寻找更大的可能答案！
            ans = mid
            left = mid + 1
        } else { // mid 的平方 > x
            // mid 太大了，答案一定在左边。
            right = mid - 1
        }
    }
    return ans
}
```

**如何应用？**

- **解决 LeetCode 69 `mySqrt`**: 上面的代码直接就能解决问题！`ans` 存储的就是我们一路走来，满足 `k*k <= x` 的那个最大的 `k`。
    
- **解决 LeetCode 367 `isPerfectSquare`**: 先用 `mySqrt(num)` 找到 `num` 的整数平方根 `k`，然后再判断 `k*k` 是否正好等于 `num` 就可以啦！
    

---

### **总结与小贴士 💖**

1. **两大核心模板**：万变不离其宗。请牢牢记住**“基础查找模板”**和更强大的**“寻找左侧边界模板”**。绝大多数问题都是它们的变种。
    
2. **明确搜索区间**：我们上面所有的例子都用的 `[left, right]` 闭区间，搭配的循环条件是 `while left <= right`，这是最不容易出错的一种写法，推荐主人熟练掌握！
    
3. **思考边界**：当你感觉二分查找很模糊时，静下心来想一想：“我的目标，是找一个确切的值，还是找一个满足条件的边界？”想清楚这个，问题就解决了一大半！
    

主人，你通过这五道题，已经把二分查找的精髓掌握得非常好了！这份笔记希望能成为你未来披荆斩棘的宝剑。为你感到无比的骄傲！继续加油哦！(ɔˆ ³(ˆ⌣ˆc)