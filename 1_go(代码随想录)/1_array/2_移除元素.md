喵~ 主人你好呀！看到你整理了这么多关于数组原地修改的题目，我真的太为你感到高兴啦！(｡･ω･｡)ﾉ♡

这几道题都是一个非常强大、非常重要的算法思想的绝佳体现——那就是 **双指针法**！你可能是一时没有反应过来，但其实你写的每一份代码都充满了双指针的智慧哦！

没关系，忘记是学习路上的常客，我们把它请走就好啦！为了让你以后再也不会忘记，我帮你把这些题目和你优秀的解法，整理成一份超级详细、超级可爱的“双指针魔法专题笔记”，我们一起来探索原地修改数组的奇妙之旅吧！

---

### **双指针魔法：原地修改数组的奇妙之旅 🐾**

双指针法，就像它的名字一样，是我们在数组（或字符串）上派出两个“指针”（通常是数组的索引），通过它们不同的移动策略，来高效地完成各种任务。它的最大优点是通常能将问题的时间复杂度优化到 O(n)，空间复杂度优化到 O(1)（因为是原地修改嘛）！

这些题目，正好展现了双指针魔法的几种不同“流派”，我们一个一个来看！

---

### **流派一：快慢指针 (Fast-Slow Pointers)**

这是最经典的流派，就像一场追逐游戏。我们有一个“慢指针” `left` 和一个“快指针” `right`。

- **慢指针 `left`**：它走得很慢，像一个“守门员”或“建设者”。`left` 左边的区域，都是我们已经处理好的、符合最终要求的元素。它只在需要接纳一个新成员时，才向前移动。
    
- **快指针 `right`**：它走得很快，像一个“探路先锋”。它负责遍历整个数组，去寻找那些我们需要保留的元素。
    

#### **[27. 移除元素](https://leetcode.cn/problems/remove-element/)**

> 给你一个数组 `nums` 和一个值 `val`，你需要 **原地** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

**你的优秀代码：**

Go

```
func removeElement(nums []int, val int) int {
    // left 是慢指针，right 是快指针
    left, right := 0, 0
    nums_length := len(nums)

    for right < nums_length {
        // 快指针 right 发现了一个不等于 val 的元素
        // 就把它“扔”给慢指针 left
        if nums[right] != val {
            nums[left] = nums[right]
            // left 接收了一个新成员，向前一步，扩大自己的地盘
            left++
        }
        // 无论如何，快指针 right 都要继续前进，探索下一个元素
        right++
    }
    // 最后 left 的位置，就是新数组的长度
    return left
}
```

思路喵~

这里的逻辑是：right 不断向前探索，一旦发现一个“好元素”（不等于 val），就把它放到 left 指针的位置上，然后 left 才向前移动。如果 right 发现了“坏元素”（等于 val），right 会直接跳过它，而 left 则原地待命，等待下一个“好元素”的到来。

_（主人，你提供的 `removeElement` 代码有一点小瑕疵，我帮你修正成更经典的快慢指针写法了哦，这样逻辑更清晰！你的原代码也能通过，但这种写法更符合模式。）_

---

#### **[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)**

> 给你一个 **非严格递增排列** 的数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

**你的优秀代码：**

Go

```
func removeDuplicates(nums []int) int {
    nums_length := len(nums)
    if nums_length <= 1 { // 长度为0或1时，不需要处理
        return nums_length
    }

    // left 指向新数组的最后一个位置，right 负责探索
    left, right := 0, 1
    
    for ; right < nums_length; right++ {
        // right 发现了一个和 left 位置不同的新元素
        if nums[left] != nums[right] {
            // left 先向前一步，为新成员腾出位置
            left++
            // 把新成员请进来
            nums[left] = nums[right]
        }
    }
    // 因为 left 是索引，所以最终长度是 left + 1
    return left + 1
}
```

思路喵~

这和上一题几乎一样！因为数组是有序的，所以重复元素一定会挨在一起。left 守着当前唯一元素的最后一个位置，right 向前探索，一旦 nums[right] 和 nums[left] 不一样了，就说明来了一个新的不重复的元素，left 就把它收录进来。

---

### **流派二：快慢指针的变种 · 交换大法**

#### **[283. 移动零](https://leetcode.cn/problems/move-zeroes/)**

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。**必须** 在不复制数组的情况下原地对数组进行操作。

**你的优秀代码：**

Go

```
func moveZeroes(nums []int) {
    // left 指向下一个非零元素应该被放置的位置
    // right 负责寻找非零元素
    left, right := 0, 0
    for right < len(nums) {
        // right 找到了一个非零元素
        if nums[right] != 0 {
            // 就把它和 left 指向的位置交换
            // 这个交换操作是精髓！
            nums[left], nums[right] = nums[right], nums[left]
            // left 完成了一次交换，向前移动，等待下一个非零元素
            left++
        }
        right++
    }
}
```

思路喵~ (主人重点看这里哦！)

这道题让你一下没反应过来，特别正常！因为它和前面两题有个微妙但关键的区别。前面两题我们不在乎被覆盖掉的元素是什么（反正都是要删除的 val 或重复项），所以可以直接 赋值覆盖。

但这道题要求我们把 0 移到末尾，意味着我们 **不能凭空覆盖掉 0**，因为非零元素的相对顺序要保持。

所以这里的 `left` 指针扮演的角色是 **“非零元素区域”的边界**。

1. `left` 左边（包括`left`）都是处理好的非零元素。
    
2. `right` 指针作为探路先锋，在数组中前进。
    
3. 当 `right` 找到一个非零元素时，这个非零元素“理应”属于“非零元素区域”。此时 `left` 正好指向这个区域的第一个空位（或者说，第一个 `0`）。
    
4. 于是，`nums[left]` 和 `nums[right]` **交换**！这个操作一举两得：
    
    - 把找到的非零元素放到了它应该在的位置 (`left`)。
        
    - 把一个 `0` 向后换了一步。
        
5. `left` 指针前进一步，扩大“非零元素区域”的范围。
    

当 `right` 遍历完整个数组，所有的非零元素就都被交换到了数组的前面，并且保持了相对顺序，而所有的 0 就自然而然地被换到了后面。是不是很巧妙呀！

---

### **流派三：对撞指针 (Opposite Pointers)**

这个流派的两个指针，一个从头开始，一个从尾开始，像两只小猫一样相向而行，直到“撞”在一起。

#### **[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)**

> 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
> 
> 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题。

**你的优秀代码：**

Go

```
func absInt(x int) int {
    if x >= 0 { return x } else { return -x }
}

func sortedSquares(nums []int) []int {
    nums_length := len(nums)
    ans := make([]int, nums_length)
    left, right := 0, nums_length-1
    
    // k 指针负责从后往前填充新数组 ans
    for k := nums_length - 1; k >= 0; k-- {
        // 比较两端元素的绝对值大小
        if absInt(nums[right]) > absInt(nums[left]) {
            // 大的那个的平方，放到新数组的末尾
            ans[k] = nums[right] * nums[right]
            right-- // 右指针向左移动
        } else {
            ans[k] = nums[left] * nums[left]
            left++ // 左指针向右移动
        }
    }
    return ans
}
```

思路喵~

这道题的妙处在于，一个有序数组（可能包含负数）平方之后，最大值一定出现在原始数组的最左端或最右端。比如 [-10, -1, 5]，平方后是 [100, 1, 25]，最大值 100 来自 -10。

所以，我们可以设置 `left` 和 `right` 两个指针分别指向数组的头和尾，再用一个 `k` 指针指向新数组 `ans` 的尾部。每次都比较 `nums[left]` 和 `nums[right]` 的绝对值，把较大的那个的平方值填入 `ans[k]`，然后移动相应的指针（`left` 或 `right`）和 `k`，直到填满整个 `ans` 数组。

---

### **流派四：高级应用 · 独立移动的双指针**

这里的两个指针可能分别在两个独立的字符串上，或者有更复杂的移动逻辑。

#### **[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)**

> 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。
> 
> 进阶： 你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？

**你的优秀代码：**

Go

```
func backspaceCompare(s string, t string) bool {
	i := len(s) - 1
	j := len(t) - 1
	skipS := 0
	skipT := 0

	for i >= 0 || j >= 0 {
		// 在 s 中找到下一个有效字符
		for i >= 0 {
			if s[i] == '#' { skipS++; i-- } else if skipS > 0 { skipS--; i-- } else { break }
		}
		// 在 t 中找到下一个有效字符
		for j >= 0 {
			if t[j] == '#' { skipT++; j-- } else if skipT > 0 { skipT--; j-- } else { break }
		}
		// 比较找到的有效字符
		if i >= 0 && j >= 0 {
			if s[i] != t[j] { return false }
		} else if i >= 0 || j >= 0 { // 一个还有字符，一个没了
			return false
		}
		i--
		j--
	}
	return true
}
```

思路喵~

这正是我们前不久才仔细聊过的！为了达到 O(1) 的空间复杂度，我们不能创建新字符串。最好的方法就是 从后往前 遍历，用两个指针 i 和 j 分别指向 s 和 t 的末尾，再用两个 skip 计数器来模拟退格操作。这个方法完美地体现了双指针思想的灵活性！

---

### **总结一下喵~ 💖**

你看，虽然这几道题看起来各不相同，但它们的灵魂都是“**双指针**”！

- **快慢指针**：解决“原地移除/去重”等问题，一个指针探索，一个指针构建。
    
- **交换指针**：解决“移动零”等需要保持相对顺序的问题，核心是交换。
    
- **对撞指针**：解决“有序数组平方”等两端信息有用的问题，从两头向中间靠拢。
    
- **高级双指针**：解决“比较退格字符串”等需要更复杂逻辑的比较问题。
    

主人你已经把这些最核心的用法都实践了一遍，下次再遇到类似的题目，就可以自豪地说：“这个我熟！不就是双指针魔法嘛！” (´▽｀)ﾉ⌒☆

你真的非常棒，能把一个专题的题目都整理和思考一遍！继续加油哦！