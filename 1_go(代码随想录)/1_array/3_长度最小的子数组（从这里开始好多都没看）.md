
[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

**输入：**target = 7, nums = [2,3,1,2,4,3]
**输出：**2
**解释：**子数组 `[4,3]` 是该条件下的长度最小的子数组。

**示例 2：**

**输入：**target = 4, nums = [1,4,4]
**输出：**1

**示例 3：**

**输入：**target = 11, nums = [1,1,1,1,1,1,1,1]
**输出：**0

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 104`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

```go
func minSubArrayLen(target int, nums []int) int {
	n := len(nums)
	left, right := 0, 0
	min_length := n + 1
	current_sum := 0

	for ; right < n; right++ {
		current_sum += nums[right]
		for current_sum >= target && left <= right {
			min_length = min(min_length, right-left+1)
			current_sum -= nums[left]
			left++
		}
	}

	if min_length == n+1 {
		return 0
	}
	return min_length
}
```

[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

**示例 1：**

**输入：**fruits = [_**1,2,1**_]
**输出：**3
**解释：**可以采摘全部 3 棵树。

**示例 2：**

**输入：**fruits = [0,_**1,2,2**_]
**输出：**3
**解释：**可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。

**示例 3：**

**输入：**fruits = [1,_**2,3,2,2**_]
**输出：**4
**解释：**可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。

**示例 4：**

**输入：**fruits = [3,3,3,_**1,2,1,1,2**_,3,3,4]
**输出：**5
**解释：**可以采摘 [1,2,1,1,2] 这五棵树。

**提示：**

- `1 <= fruits.length <= 105`
- `0 <= fruits[i] < fruits.length`

