[904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/description/)

本题使用40分钟

整体的思路没问题，但是细节还是差了点。

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        if(fruits.empty()){
            return 0;
        }
        vector<int> nums(2,-1);
        nums[0]=fruits[0];
        int maxlength=0;

        for(int slow=0,fast=0;fast<fruits.size();){
            if(fruits[fast]!=nums[0] && fruits[fast]!=nums[1]){
                if(nums[1]==-1){
                    nums[1]=fruits[fast];
                }
                else{
                    slow=fast-1;
                    while(slow>=1&&fruits[slow]==fruits[slow-1]){
                        slow--;
                    }
                    nums[0]=fruits[slow];
                    nums[1]=fruits[fast];
                }

            }

            maxlength = max(maxlength, fast-slow+1);
            fast++;

        }
        return maxlength;
    }
};
```

这里主要是注意四个地方。

第一，我使用了slow回溯，这里本来是想优化掉的，但是还是先用了

第二，currentlength的问题，事实上currentlength如果放在循环的太前面，那么并不会实时更新，这也是卡住我这次问题的一个主要的点

错误代码：

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        if(fruits.empty()){
            return 0;
        }
        vector<int> nums(2,-1);
        nums[0]=fruits[0];
        int maxlength=0;

        for(int slow=0,fast=0;fast<fruits.size();){
            int currentlength=fast-slow+1;
            if(fruits[fast]!=fruits[slow]){
                if(nums[1]==-1){
                    nums[1]=fruits[fast];
                }
                else if(fruits[fast]==nums[1]){
                    ;
                }
                else{
                    slow=fast-1;
                    while(slow>=1&&fruits[slow]==fruits[slow-1]){
                        slow--;
                    }
                    nums[0]=fruits[slow];
                    nums[1]=fruits[fast];
                }

            }

            maxlength = max(maxlength, currentlength);
            fast++;

        }
        return maxlength;
    }
};
```

第三，if的进入条件。刚开始的时候我把进入条件设置为了一个很复杂的东西，虽然是对的但是读起来很复杂，大概意思就是判断nums[slow]是否等于nums[fast]，并且在if里面再判断是否属于nums[1]，事实上我们更关注的应该是fast的变化。

代码是对的

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        if(fruits.empty()){
            return 0;
        }
        vector<int> nums(2,-1);
        nums[0]=fruits[0];
        int maxlength=0;

        for(int slow=0,fast=0;fast<fruits.size();){
            if(fruits[fast]!=fruits[slow]){
                if(nums[1]==-1){
                    nums[1]=fruits[fast];
                }
                else if(fruits[fast]==nums[1]){
                    ;
                }
                else{
                    slow=fast-1;
                    while(slow>=1&&fruits[slow]==fruits[slow-1]){
                        slow--;
                    }
                    nums[0]=fruits[slow];
                    nums[1]=fruits[fast];
                }

            }

            maxlength = max(maxlength, fast-slow+1);
            fast++;

        }
        return maxlength;
    }
};
```

第四，多余的flag。本来在slow回溯那里我增加了flag，但是实际上不需要，我也不知道为啥，问一下gemini

- 带 `flag` 的版本是在调整后的 **下一轮** 循环中计算并比较这个窗口长度的。
- 不带 `flag` 的版本是在调整 `slow` 的 **同一轮** 循环末尾计算并比较这个窗口长度的。

就相当于脱了裤子放屁，大概懂这个意思了

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        if(fruits.empty()){
            return 0;
        }
        vector<int> nums(2,-1);
        nums[0]=fruits[0];
        int maxlength=0;

        for(int slow=0,fast=0;fast<fruits.size();){
            int flag=1;

            if(fruits[fast]!=nums[0] && fruits[fast]!=nums[1]){
                if(nums[1]==-1){
                    nums[1]=fruits[fast];
                }
                else{
                    slow=fast-1;
                    while(slow>=1&&fruits[slow]==fruits[slow-1]){
                        slow--;
                    }
                    nums[0]=fruits[slow];
                    nums[1]=fruits[fast];
                    flag=0;
                }

            }

            maxlength = max(maxlength, fast-slow+1);
            fast++;

        }
        return maxlength;
    }
};
```