本题在ai的辅助下，花了100分钟

[76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/)

```cpp
class Solution {
public:

    bool isSubMultiset(const string& collectionA, const string& collectionB) {
        unordered_map<char, int> freqA;
        for (const char& item : collectionA) {
            freqA[item]++;
        }

        unordered_map<char, int> freqB;
        for (const char& item : collectionB) {
            freqB[item]++;
        }

        for (const auto& pairB : freqB) {
            const char& itemInB = pairB.first;
            int countInB = pairB.second;

            if (freqA.count(itemInB) == 0) {
                return false;
            }

            if (freqA.at(itemInB) < countInB) {
                return false;
            }
        }

        return true;
    }
    string minWindow(string s, string t) {

        int left=0,right=0;
        string minstring="";
        string currentstring="";

        // substr(num,count);
        unordered_set<char> tset;
        for(char ch:t){
            tset.insert(ch);
        }

        int flag=1;

        while(right<s.size()){
            if(flag==1){
                currentstring+=s[right];
            }
            else if(flag==0){
                flag=1;
            }
            if(isSubMultiset(currentstring,t)){
                if(minstring==""){minstring=currentstring;}
                else if(minstring.size()>currentstring.size()){
                    minstring=currentstring;
                }
                left+=1;
                while(left<=right&&tset.find(s[left])==tset.end()){
                    left++;
                }
                currentstring=s.substr(left,right-left+1);
                flag=0;
            }
            if(flag==1){
                right++;
            }
            
        }
        return minstring;
    }
};
```

这个是采用的是最暴力的想法，下面那个采用的就是另一个方法。这个方法利用了字符串本身的性质

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        if (s == t) {
            return t;
        } else if (s.size() < t.size()) {
            return "";
        }

        int left = 0, right = 0;
        string minstring = "";
        string currentstring = "";

        // substr(num,count);
        unordered_map<char, int> thasmap;
        for (char ch : t) {
            thasmap[ch] += 1;
        }

        int flag = 1;
        int matches = 0;
        unordered_map<char, int> haswindow;

        while (right < s.size()) {
            if (flag == 1) {
                currentstring += s[right];
                haswindow[s[right]] += 1;
                if (haswindow[s[right]] == thasmap[s[right]]) {
                    matches += 1;
                }
            } else if (flag == 0) {
                flag = 1;
            }

            if (matches == thasmap.size()) {
                if (minstring == "") {
                    minstring = currentstring;
                } else if (minstring.size() > currentstring.size()) {
                    minstring = currentstring;
                }

                haswindow[s[left]] -= 1;

                if (haswindow[s[left]] < thasmap[s[left]]) {
                    matches -= 1;
                }

                left += 1;
                currentstring = s.substr(left, right - left + 1);
                flag = 0;
            }

            if (flag == 1) {
                right++;
            }
        }
        return minstring;
    }
};
```

但是由于始终复制有很大的开销

统计词频法，也是最终答案：

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        if(t.empty()){
            return "";
        }
        else if (s == t) {
            return t;
        } else if (s.size() < t.size()) {
            return "";
        }

        int left = 0, right = 0;

        unordered_map<char, int> thasmap;
        for (char ch : t) {
            thasmap[ch] += 1;
        }

        int flag = 1;
        int matches = 0;
        int minleft = -1, minright = -1;

        unordered_map<char, int> haswindow;

        while (right < s.size()) {
            if (flag == 1) {
                haswindow[s[right]] += 1;
                if (thasmap.count(s[right]) > 0 &&
                    haswindow[s[right]] == thasmap[s[right]]) {
                    matches += 1;
                }
            } else if (flag == 0) {
                flag = 1;
            }

            if (matches == thasmap.size()) {
                if (minleft == -1 && minright == -1) {
                    minleft = left;
                    minright = right;
                } else if (minright - minleft > right - left) {
                    minleft = left;
                    minright = right;
                }

                haswindow[s[left]] -= 1;

                if (thasmap.count(s[left]) > 0 &&
                    haswindow[s[left]] < thasmap[s[left]]) {
                    matches -= 1;
                }

                left += 1;
                flag = 0;
            }

            if (flag == 1) {
                right++;
            }
        }
        if(minleft==-1&&minright==-1){
            return "";
        }
        return s.substr(minleft, minright - minleft + 1);
    }
};
```


