[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

第一个版本的代码：

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        int mid=(left+right)/2;

        while(left<=right){
            if(nums[mid]==target){
                return mid;
            }
            else if(nums[mid]<target){
                left=mid;
            }
            else{
                right=mid;
            }

            mid=(left+right)/2;
        }

        return -1;
    }
};
```

测试样例超出时间限制

显然是未考虑到如果target不存在的情况

于是第二版如下，但仍有错误：

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        int mid=(left+right)/2;

        while(left<=right){
            if(nums[mid]<target){
                left=mid;
            }
            else{
                right=mid;
            }

            if(nums[mid]==target){
                return mid;
            }

            mid=(left+right)/2;

            if(mid==left ||mid==right){
                return -1;
            }
            
        }

        return -1;
    }
};
```

解答错误，nums=[2,5]，targt=5

我的输出是-1，但是实际上应该是1

改了好几版（不是一次ak）

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        int mid = (left + right) / 2;

        while (right-left>1) {
            if (nums[mid] == target) {
                return mid;
            }

            else if (nums[mid] < target) {
                left = mid;
            }

            else {
                right = mid;
            }

            mid = (left + right) / 2;
        }

        if(target==nums[left]){return left;}
        if(target==nums[right]){return right;}

        return -1;
    }
};
```

写出来一个及其丑陋的版本，现在想办法解决

问题的矛盾点就在于边界条件，当right-left>1的时候无所谓，而如果left和right相邻的时候，就意味着要结束了。

我的代码有两个问题

第一个，使用left+right再除以2可能会导致溢出

第二，如果只是使用mid的话会导致死循环。

注意到事实上如果触发第二个选项，那么nums[mid]必然不是target，也意味着left=mid的时候，新的nums[left]必然不是答案，而nums[left+1]则解决了。

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        int mid = left +(right-left) / 2;

        while (left<=right) {
            if (nums[mid] == target) {
                return mid;
            }

            else if (nums[mid] < target) {
                left = mid+1;
            }

            else {
                right = mid-1;
            }

            mid = (left + right) / 2;
        }

        return -1;
    }
};
```

本题我的问题就是

首先，并没有完全ak，并没有从原理入手

### 总结：

二分法的前提：有序无重复数组

**对区间的定义没有想清楚，区间的定义就是不变量**

[left,right]

=> [mid+1,mid-1]

[left,right)

=> [mid+1,mid)

注意这里的区别