[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target, int left, int right) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int first_target = search(nums, target, 0, nums.size() - 1);
        if (first_target == -1) {
            return {-1, -1};
        }
        int left = first_target;
        int right = first_target;
        while (1) {
            int current_left = search(nums, target, 0, left - 1);
            if (current_left != -1) {
                left = current_left;
            } else {
                break;
            }
        }

        while (1) {
            int current_right =
                search(nums, target, right + 1, nums.size() - 1);
            if (current_right != -1) {
                right = current_right;
            } else {
                break;
            }
        }

        return {left, right};
    }
};
```

一遍过

但是我感觉我的代码效率有点低，因为重复调用了search。

事实上就是二分的变种，就是说并非三个分支，而是合并为两个分支，这样可以找到最边界的地方

想了一下，写出了第二个版本，但是这次是使用了三次

```cpp
class Solution {
public:

    bool searchNormal(vector<int>&nums,int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                return true;
            }
            else if(nums[mid]<target){
                left=mid+1;
            }
            else{
                right=mid-1;
            }
        }
        return false;
    }

    int searchLeft(vector<int> &nums,int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            int current_num=nums[mid];
            if(current_num<target){
                left=mid+1;
            }
            else{
                right=mid-1;
            }
        }
        return left;
    }

    int searchRight(vector<int> &nums,int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            int current_num=nums[mid];
            if(current_num<=target){
                left=mid+1;
            }
            else{
                right=mid-1;
            }
        }
        return right;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        if(!searchNormal(nums,target)){
            return {-1,-1};
        }
        int left=searchLeft(nums,target);
        int right=searchRight(nums,target);
        return {left,right};
    }
};
```

在Gemini的提示下：

**一个小小的思考方向（欧尼酱可以想一下，但现在的版本已经很好了喵！）：** 其实，我们也可以只用两次查找就完成任务哦。比如，我们可以先调用 `searchLeft` 找到 `left_boundary`。 然后检查一下：

- 如果 `left_boundary` 等于数组的长度 `nums.size()` （说明所有元素都比 `target` 小，`target` 不存在）。
- 或者 `nums[left_boundary]` 不等于 `target` （说明 `target` 也不存在，`left_boundary` 指向的是第一个大于 `target` 的元素）。 如果这两种情况发生了，就说明 `target` 没找到，可以直接返回 `{-1, -1}`。这样就用 `searchLeft` 的结果顺便完成了存在性检查，可以省掉 `searchNormal` 的调用。 如果 `target` 存在，那么 `left_boundary` 就是起始位置，然后再调用 `searchRight` (或者一个类似 `upper_bound` 的逻辑去找右边界的下一个位置再减1) 来找到结束位置。

写出了第三个版本：

```cpp
class Solution {
public:

    int searchLeft(vector<int> &nums,int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            int current_num=nums[mid];
            if(current_num<target){
                left=mid+1;
            }
            else{
                right=mid-1;
            }
        }
        return left;
    }

    int searchRight(vector<int> &nums,int target){
        int left=0,right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            int current_num=nums[mid];
            if(current_num<=target){
                left=mid+1;
            }
            else{
                right=mid-1;
            }
        }
        return right;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int left=searchLeft(nums,target);
        if(left==nums.size() || nums[left]!=target){
            return {-1,-1};
        }
        int right=searchRight(nums,target);
        return {left,right};
    }
};
```

不要上来就想如果一起寻找左右区间，搞着搞着就会顾此失彼，绕进去拔不出来了。

