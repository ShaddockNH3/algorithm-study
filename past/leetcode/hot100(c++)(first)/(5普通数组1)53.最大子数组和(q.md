[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

### 基本

这道题本来是做过的，但是后面忘记了。其实思路很简单，就是通过一次遍历一直更新sum和ans。用自然语言解释就是说，sum向后移动，并且当sum自己小于nums[i]的时候，就肯定说明前面的sum已经失效，应该抛弃，否则该sum就还是有用的，应该保留继续向后算。

这里有个坑，和之前双指针的东西，以及没注意到pair差不多，只需要再来一个变量记录就行了。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans=nums[0];
        int sum=0;
        
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
            sum=max(sum,nums[i]);
            ans=max(sum,ans);
        }
        return ans;
    }
};
```

### 分治法

暂时省略