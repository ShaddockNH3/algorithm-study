


我尝试的解法只能解决单调非负的情况

```cpp
class Solution {
public:
    int sub_sum(int right, int left, int sums[]) {
        if (left == 0) {
            return sums[right];
        }
        return sums[right] - sums[left-1];
    }

    int subarraySum(vector<int>& nums, int k) {
        int sums[nums.size()+1];
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0) {
                sums[i] = nums[i];
            } else {
                sums[i] = nums[i] + sums[i - 1];
            }
        }

        int left = 0, right = 0;
        int ans = 0;

        while (left < nums.size()&& right < nums.size()) {
            while (left < nums.size() && right < nums.size() &&
                   sub_sum(right, left, sums) < k) {
                right++;
            }
            while (left < nums.size() && right < nums.size() &&
                   sub_sum(right, left, sums) == k) {
                ans++;
                right++;
            }
            while (left < nums.size() && right < nums.size() &&
                   sub_sum(right, left, sums) > k) {
                left++;
            }
        }

        return ans;
    }
};
```



前缀和+哈希优化

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> hasmap;
        hasmap[0]=1;

        int ans=0;
        int sum=0;

        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
            if(hasmap.find(sum-k)!=hasmap.end()){
                ans+=hasmap[sum-k];
            }
            hasmap[sum]++;
        }
        
        return ans;
    }
};
```