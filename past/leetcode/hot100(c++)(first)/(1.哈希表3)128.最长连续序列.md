https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked

尚未完全搞懂
---
### 暴力解法

```cpp
class Solution {
public:

    int longestConsecutive(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        auto newend=unique(nums.begin(),nums.end());
        nums.erase(newend,nums.end());

        int maxsize=0;

        for(int i=0;i<nums.size();i++){
            int current_sum=1;
            for(int j=i+1;j<nums.size();j++){
                if(nums[j]-nums[j-1]==1){
                    current_sum++;
                }
                else{
                    break;
                }
            }
            maxsize=maxsize>current_sum?maxsize:current_sum;
        }
        return maxsize;
    }
};
```

### 哈希表

貌似被标签误导了，我只需要进行查询就行了好像。

并查集那里是可以直接找出序列的，而题目要求并不需要找出序列，只需要找到最大的长度。其实和第一题一样，只需要将查找的遍历改为检查是否存在的遍历就可以了。

然而还是超出了时间限制，最后还得用并查集去解决

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> numset(nums.begin(),nums.end());
        int maxsize=0;

        for(int num:nums){
            if(numset.find(num-1)==numset.end()){
                int current_num=num;
                int current_max=1;

                while(numset.find(current_num+1)!=numset.end()){
                    current_num+=1;
                    current_max+=1;
                }
                maxsize=maxsize>current_max?maxsize:current_max;
            }
        }
        return maxsize;
    }
};
```
### 并查集？

标签里有说并查集，那我先手打一个并查集出来先。

从暴力的思路出发优化，暴力的想法是先排序，然后剔除重复元素，最后进行计算。所以，这里的想法应该是将排序转换为其他东西？

这里实际上不要求序列元素再原数组中连续，所以可以将一组数放在一起的一个办法就是集合。

但是要怎么构造这个集合呢？

我的想法是检查有没有和原来的集合里有距离等于1的元素

```cpp
class UnionFind{
public:
    unordered_map<int,int> parent;
    unordered_map<int,int> rank;
    unordered_map<int,int> size;

    int find(int x){
        if(parent[x]!=x){
            parent[x]=find(parent[x]);
        }
        return parent[x];
    }

    void unite(int x,int y){
        int rootx=find(x);
        int rooty=find(y);
        if(rootx!=rooty){
            if(rank[rootx]>rank[rooty]){
                parent[rooty]=parent[rootx];
                size[rootx]+=size[rooty];
            }
            else if(rank[rootx]<rank[rooty]){
                parent[rootx]=parent[rooty];
                size[rooty]+=size[rootx];
            }
            else{
                parent[rooty]=rootx;
                size[rootx]+=size[rooty];
                rank[rootx]++;
            }
        }
    }
    
    void add(int x){
        if(parent.find(x)==parent.end()){
            parent[x]=x;
            rank[x]=1;
            size[x]=1;
        }
    }

    bool connected(int x,int y){
        if(parent.find(x)==parent.end()||parent.find(y)==parent.end()){
            return false;
        }
        return find(x)==find(y);
    }

    int getsize(int x){
        return size[find(x)];
    }
};

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        UnionFind uf;
        for(int num:nums){
            uf.add(num);
            if(uf.parent.find(num-1)!=uf.parent.end()){
                uf.unite(num,num-1);
            }
            if(uf.parent.find(num+1)!=uf.parent.end()){
                uf.unite(num,num+1);
            }
        }
        int maxsize=0;
        for(int num:nums){
            maxsize=max(maxsize,uf.getsize(num));
        }
        return maxsize;
    }
};
```

但是只打败了24.72%的人，看看问题。

### 二刷（2025.5.2）

正确但超时，虽然是O(n)，但是有很多重复步骤

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int,int> hasmap;
        int max_num=0;

        for(int i=0;i<nums.size();i++){
            hasmap[nums[i]]=1;
            int current_num=nums[i];

            while(hasmap.count(current_num-1)){
                hasmap[nums[i]]++;
                current_num--;
            }

            current_num=nums[i];

            while(hasmap.count(current_num+1)){
                hasmap[nums[i]]++;
                current_num++;
            }

            max_num=max(hasmap[nums[i]],max_num);
        }
        return max_num;
    }
};
```

错误，就差一点点

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int,int> hasmap;
        int max_num=0;

        for(int i=0;i<nums.size();i++){
            hasmap[nums[i]]=1;

            if(hasmap.count(nums[i]-1)){
                hasmap[nums[i]]+=hasmap[nums[i]-1];
            }

            if(hasmap.count(nums[i]+1)){
                hasmap[nums[i]]+=hasmap[nums[i]+1];
            }

            max_num=max(hasmap[nums[i]],max_num);
        }
        return max_num;
    }
};


```

想了一下，去重即可

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int,int> hasmap;
        int max_num=0;

        set<int> num_set(nums.begin(), nums.end());
        vector<int> new_nums(num_set.begin(), num_set.end());

        for(int i=0;i<new_nums.size();i++){
            hasmap[new_nums[i]]=1;

            if(hasmap.count(new_nums[i]-1)){
                hasmap[new_nums[i]]+=hasmap[new_nums[i]-1];
            }

            if(hasmap.count(new_nums[i]+1)){
                hasmap[new_nums[i]]+=hasmap[new_nums[i]+1];
            }

            max_num=max(hasmap[new_nums[i]],max_num);
        }
        return max_num;
    }
};

```


