[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/?envType=study-plan-v2&envId=top-100-liked)

众数，这道题其实去年的时候做过，余春艳上课的时候有说可以用摩尔投票法最简单

我的实现就是直接摩尔投票：

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int current_max=nums[0];
        int times=1;
        for(int i=1;i<nums.size();i++){
            if(current_max!=nums[i]){
                times-=1;
            }
            else{
                times+=1;
            }
            if(times==0){
                times=1;
                current_max=nums[i];
            }
        }
        return current_max;
    }
};
```

不过实际上，可以拓展一下思路，不只是摩尔投票，还有非常非常多的想法：

### 1. 排序

将nums排序后会发现，无论如何，那个最大的数肯定会在nums.size()/2那里。

所以：

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
```


### 2. 哈希表

压入哈希表后，然后检索最大的那个即可

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int,int> hasmap;
        for(int i=0;i<nums.size();i++){
            hasmap[nums[i]]+=1;
            if(hasmap[nums[i]]>nums.size()/2){
                return nums[i];
            }
        }
        return EOF;
    }
};
```

### 3.