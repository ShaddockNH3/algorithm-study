![[d011076bed8e294488ffe49e5766d808.jpg]]
```
#include<iostream>
#include<vector>
using namespace std;

int middle_num(int n, vector<int> v1,vector<int> v2);

int main() {
	vector<int> nums1;
	vector<int> nums2;
	int n; cin >> n;
	int num;
	for (int i = 0; i < n; i++) {
		cin >> num;
		nums1.push_back(num);
	}
	for (int i = 0; i < n; i++) {
		cin >> num;
		nums2.push_back(num);
	}
	cout << middle_num(n, nums1, nums2) << endl;
	return 0;
}

int middle_num(int n, vector<int> v1,vector<int> v2) {
	int i = 0, j = 0;
	while (n--) {
		if (v1[i] >= v2[j]) {
			if(n!=0)
				j++;
		}
		else {
			if(n!=0)
				i++;
		}
	}
	return v1[i] < v2[j] ? v1[i] : v2[j];
}
```

我感觉这样应该是可以的！
如果不行的话就把vector换掉，该用vector的时候用vector，不该用的时候还是算了。

![[75f74d1aedb8880fabab016996d6c07a.jpg]]
比较简单，略

![[28e007b17c84d0abfe1baea3bfbcb313.jpg]]
```
#include<iostream>
using namespace std;

int arr[100005];
int length[100005] = { 0 };

void find_max_list(int n) {
	for (int i = 0; i < n - 1; i++) {
		if (arr[i] < arr[i + 1]) {
			length[i + 1] = length[i] + 1;
		}
	}
	int max = length[0];
	int tax = 0;
	for (int i = 0; i < n; i++) {
		if (max < length[i]) {
			max = length[i];
			tax = i;
		}
	}
	for (int i = tax - max; i <= tax; i++) {
		cout << arr[i];
		if (i != tax) {
			cout << " ";
		}
	}
	cout << endl;
}

int main() {
	int n; cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	find_max_list(n);
}
```

![[67520f03d607a467da9ce18eef6c00b4.jpg]]
我现在的未完成代码是O(n2)

休息一下，明天看看O(nlogn)的

```
#include<iostream>
#include<algorithm>
using namespace std;

struct cp{
	int a;
	int b;
};

cp couple[50005];
int single[80005] = { 0 };
int list[80005];

int search(int id,int t,int n) {
	int a = -1;
	for (int i = 0; i < t; i++) {
		if (id == couple[i].a) {
			a = 1;
			break;
		}
		else if (id == couple[i].b) {
			a = 2;
			break;
		}
	}
	int b = -1;
	if (a == 1) {
		for (int i = 0; i < n; i++) {
			if(couple[i].b==id)
		}
	}
}

void single_dog(int t,int n) {
	
}

int main() {
	int t;
	for (int i = 0; i < t; i++) {
		cin >> couple[i].a;
		cin >> couple[i].b;
	}
	int n;
	for (int i = 0; i < n; i++) {
		cin >> list[i];
	}
	single_dog(t,n);
	return 0;
}
```