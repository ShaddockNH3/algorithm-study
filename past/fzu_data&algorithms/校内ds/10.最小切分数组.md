# 算法与数据结构实验题 5.21数学家皮卡丘

### ★问题描述

现有数组元素个数为N的有序数组a和一个正整数k，保证对于任意N-1>=i>=1,ai>=ai-1。  
爱动脑的数学家皮卡丘想把这个数组分成k个非空的连续子数组，使得数组中的每个元素都包含且仅包含在一个子数组中。设max(i)为第i个子数组中的最大元素，min(i)为第i个子数组中的最小元素。皮卡丘希望对于这k个非空的连续子数组 $$\sum_{i=0}^{k}(max(i)-min(i))$$能取得最小值。  
例如对于数组[2,4,5,5,8,11,19]，当给定k=3时应将其划分成3个子数组[2,4,5,5],[8,11],[19]，此时皮卡丘可以得到最小值为(5-2)+(11-8)+(19-19)=6 。

### ★数据输入

输入第一行包括两个正整数 n和k，分别表示a数组的元素个数和应划分出的子数组个数k(1≤k≤n≤3e5)。

第二行输入 N 个正整数，分别表示数组元素ai。 (0<= i<= N，0< ai<= 109)

### ★数据输出

输出一个整数，为所求公式的最小值。

### ★输入示例

```
6 3
4 8 15 16 23 42
```

### ★输出示例

```
12
```

### 代码如下：

```
#include<iostream>
#include<algorithm>
using namespace std;

int arr[300005];
int arr_k[300005];

void solve(){
    int n,k;cin>>n>>k;
    for(int i=0;i<n;i++){
        cin>>arr[i];
        if(i!=0){
            arr_k[i-1]=arr[i]-arr[i-1];
        }
    }
    
    sort(arr_k,arr_k+n-1);

    int sum=0;
    for(int i=0;i<n-k;i++){
        sum+=arr_k[i];
    }
    
    cout<<sum<<endl;
}

int main(){
    solve();
    return 0;
}
```

需要注意的是，这里实际上就是利用了之前的那个思想。

比如一个数组为arr，我现在想快速求i到j的和，只需要维护另一个数组，arr_sum，arr_sum[i]是从0到i的和，然后sum_sum[j]是从0到j的和，要用的时候减一减就行了。

这里是维护一个差值数组，为了获取最小的拆分，我们知道一个长度为n的数组最多会被分成n-1刀，也就是自己和自己。

我们可以利用和上面那个类似的思想，把所有可能的n-1个的切分全都算出来，然后取最小的前n-k-1个即可。