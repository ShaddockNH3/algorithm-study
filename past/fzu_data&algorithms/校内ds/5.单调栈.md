[DS X 班级实验作业](http://ds.fzu.edu.cn/std/exp/bf5279a1-1205-4fac-86cd-dc2b5a821f48/cd083306-92aa-4473-ba00-e117d49d4b40/78328dd0-d6c3-41e9-a68b-be9834109393/)

算法与数据结构实验题 3.11 happiness

★实验任务

这一天是小V 的生日，他收到了朋友们送给他的礼物。

现在，小V 有n 件礼物，他将这n 件礼物排成一排，依次编号为1 到n，每件礼物都有一个满意值w[i]。

现在小V 要从中选取连续编号的礼物（即选取[l, r]内的礼物），使得获得的 happiness 最大。

[l, r]内的 happiness 定义为：

```
（[l, r]内所有礼物满意值的最小值）*（[l, r]内所有礼物满意值的和） 
```

小V 想知道他能获得的 happiness 最大是多少，你能帮帮他吗？

★数据输入

第一行为一个正整数 n。

第二行为n 个整数 w[1], w[2], …, w[n]

其中：

对于 50%的数据：1<=n<=100, 0<=w[i]<=100

对于 80%的数据：1<=n<=1,000, 0<=w[i]<=1,000

对于 100%的数据：1<=n<=100,000, 0<=w[i]<=10,000

★数据输出

小 V能获得的最大 happiness值。

|输入示例1|
|---|
|3|
|1 2 3|

|输出示例1|
|---|
|10|

|输入示例2|
|---|
|3|
|2 1 3|

|输出示例2|
|---|
|9|

### 单调栈

维护单调栈的逻辑如下：

- 维护一个最小左边界
1. 当栈不为空且栈顶元素大于等于当前数组内的元素时，弹出
2. 直到栈为空，将left数组标识符定位-1
3. 或者当栈顶元素终于小于数组内的元素时，left数组标识符等于栈顶
4. 当前元素i入栈

- 维护一个最小右边界
1. 只需要将上述最小左边界改为从右往左，并且当栈为空时，只需要将标识符定为数组长度n

除了单调栈之外这里还有一个很重要的地方，如何快速计算任意长度的数组和？

只需要算一个数组，这个数组是a0到ai的和，在使用比如说从下标m到n的长度时，相减即可。

下面那个代码实际上还是有点小麻烦的，可以去掉一个栈。

```
#include<iostream>
#include<stack>
using namespace std;

int arr[100005];
int sum_arr[100005] = {0};
int left_arr[100005];
int right_arr[100005];
stack<int> sl, sr;

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
        if (i == 0) {
            sum_arr[i] = arr[i];
        } else {
            sum_arr[i] = arr[i] + sum_arr[i - 1];
        }
    }

    // 计算左边界
    for (int i = 0; i < n; i++) {
        while (!sl.empty() && arr[sl.top()] >= arr[i]) {
            sl.pop();
        }
        if (sl.empty()) {
            left_arr[i] = -1;
        } else {
            left_arr[i] = sl.top();
        }
        sl.push(i);
    }

    // 计算右边界
    for (int i = n - 1; i >= 0; i--) {
        while (!sr.empty() && arr[sr.top()] >= arr[i]) {
            sr.pop();
        }
        if (sr.empty()) {
            right_arr[i] = n;
        } else {
            right_arr[i] = sr.top();
        }
        sr.push(i);
    }

    // 计算最大 happiness
    long long max_happiness = 0;
    for (int i = 0; i < n; i++) {
        long long sum = sum_arr[right_arr[i] - 1] - (left_arr[i] == -1 ? 0 : sum_arr[left_arr[i]]);
        max_happiness = max(max_happiness, sum * arr[i]);
    }

    cout << max_happiness << endl;

    return 0;
}
```
