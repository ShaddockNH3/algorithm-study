算法与数据结构实验题 4.7 不知道取什么好

★实验任务

有一个长度为 n 的序列，第 i 个数的大小为 a[i]。现在从第 1 个数开始从左往右进行以下操作：

1. 如果当前数是剩下的数中最大的，则输出并删去这个数。
    
2. 若不是，将它放到序列的末尾。
    

现在，bg 想知道一开始的第 m(从 1 开始计数)个数第几次被输出。

★数据输入

第一行输入两个正整数 n(0<n<=1000)、m(1=<m<=n)。

接下去一行有 n 个正整数，第 i 个数表示 a[i]的值。

★数据输出

输出一个数，表示第 m 个数第几次被输出。

|输入示例1|
|---|
|5 2|

一样有两种解法，第一种是暴力解法，第二种则是维护一个堆，可以找出一个一组数中的最大值，以此向下：

```
#define LL long long
#define EPS 1e-8
#define INF 0x7fffffff
#define lyh(i,a,b) for(int i=a;i<=b;i++)
#define hyl(i,a,b) for(int i=a;i>=b;i--)
#define debug(a) cout<<#a<<"="<<a<<endl;

#include<bits/stdc++.h>

using namespace std;

void solve() {
	int n, m;
	deque<pair<int, int>> dq;
	priority_queue<int> max_heap;

	int current_num;

	cin >> n >> m;

	lyh(i, 1, n) {
		cin >> current_num;
		dq.push_back({ current_num, i });
		max_heap.push(current_num);
	}

	int time = 0;

	while (!dq.empty()) {
		if (max_heap.top() == dq.front().first) {
			time += 1;
			max_heap.pop();
			if (m == dq.front().second) {
				cout << time << endl;
				return;
			}
		}
		else {
			dq.push_back(dq.front());
		}
		dq.pop_front();
	}
}

int main() {
	solve();
	return 0;
}
```