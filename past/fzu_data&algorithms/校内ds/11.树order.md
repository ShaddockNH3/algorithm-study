算法与数据结构实验题 6.4 order

★ 实验任务

给出一棵二叉树的中序遍历和每个节点的父节点，求这棵二叉树的先序和后序遍历。

★数据输入

输入第一行为一个正整数 n 表示二叉树的节点数目，节点编号从 1 到 n，其中 1 为根节点。  
第 2 行有 n 个数字，第 i 个数字表示 i 的父亲节点。（1 的父亲节点为 0，表示无）  
第 3 行为中序遍历。  
30%的数据：n<=20；  
60%的数据：n<=1000；  
100%的数据：n<=10000；

★数据输出

输出 2 行，第一行为先序遍历，第二行为后序遍历。

| 输入示例                 |
| -------------------- |
| 10                   |
| 0 7 2 2 9 1 8 1 6 8  |
| 9 5 6 1 10 8 7 3 2 4 |
|                      |

|输出示例|
|---|
|1 6 9 5 8 10 7 2 3 4|
|5 9 6 10 3 4 2 7 8 1|

采用umap进行优化，更好一些。

其实不难，就是自己吓自己。

```
#define _CRT_SECURE_NO_WARNINGS

#define LL long long
#define EPS 1e-8
#define INF 0x7fffffff
#define lyh(i,a,b) for(int i=a;i<=b;i++)
#define hyl(i,a,b) for(int i=a;i>=b;i--)
#define debug(a) cout<<#a<<"="<<a<<endl;

#include<bits/stdc++.h>
#include<unordered_map>

using namespace std;

struct TreeNode {
	int val;
	TreeNode * left, * right;

	TreeNode(int x) :val(x), left(nullptr), right(nullptr) {};
};


void preorder(TreeNode* root) {
	if (!root)return;
	cout << root->val<<" ";
	preorder(root->left);
	preorder(root->right);
}

void postorder(TreeNode* root) {
	if (!root)return;
	postorder(root->left);
	postorder(root->right);
	cout << root->val << " ";
}


void solve() {
	int n; cin >> n;
	int parent[10005];
	unordered_map<int, int> umap;

	lyh(i, 1, n) {
		cin >> parent[i];
	}
	lyh(i, 1, n) {
		int val; cin >> val;
		umap[val] = i;
	}

	vector<TreeNode*> nodes(n + 1, nullptr);

	lyh(i, 1, n) {
		nodes[i] = new TreeNode(i);
	}

	TreeNode* root = nullptr;

	lyh(i, 1, n) {
		if (parent[i] == 0) {
			root = nodes[i];
		}
		else {
			int p = parent[i];
			if (umap[nodes[i]->val]<umap[nodes[p]->val]) {
				nodes[p]->left = nodes[i];
			}
			else {
				nodes[p]->right = nodes[i];
			}
		}
	}

	preorder(root);
	cout << endl;

	postorder(root);
	cout << endl;

}

int main() {
	solve();
	return 0;
}

/*

10
0 7 2 2 9 1 8 1 6 8
9 5 6 1 10 8 7 3 2 4

*/
```