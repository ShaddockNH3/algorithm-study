[438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)

思路并不难，用到了之前解题的很多方法

```cpp
class Solution {
public:
    string get_key(string str) {
        int v[26] = {0};
        string key;

        for (const char& c : str) {
            v[c - 'a'] += 1;
        }

        for (int i = 0; i < 26; i++) {
            key += ('a' + i);
            key += to_string(v[i]);
            key += '#';
        }

        return key;
    }

    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        if (s.length() < p.length()) return ans;

        string p_key = get_key(p);
        int left = 0, right = p.length();

        while (right <= s.length()) {
            string window_key = get_key(s.substr(left, right - left));
            if (window_key == p_key) {
                ans.push_back(left);
            }
            left++;
            right++;
        }

        return ans;
    }
};
```

能过，本来加了set优化，后来因为写不明白逻辑给删掉了

全部并入同一个也可以，前者反复调用函数，对字符串操作太多了，以下是deepseek帮我优化的。

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        if (s.length() < p.length()) return ans;

        // 初始化频率数组
        vector<int> p_count(26, 0);
        vector<int> window_count(26, 0);

        // 统计 p 的频率
        for (char c : p) {
            p_count[c - 'a']++;
        }

        // 滑动窗口
        int left = 0, right = 0;
        while (right < s.length()) {
            // 扩展窗口
            window_count[s[right] - 'a']++;
            right++;

            // 当窗口大小等于 p 的长度时，检查是否匹配
            if (right - left == p.length()) {
                if (window_count == p_count) {
                    ans.push_back(left);
                }

                // 收缩窗口
                window_count[s[left] - 'a']--;
                left++;
            }
        }

        return ans;
    }
};
```