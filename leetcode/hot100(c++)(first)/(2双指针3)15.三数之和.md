[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-100-liked)

### 暴力

最朴素的想法就是三重遍历，显然时间复杂度很高，最后只是简单写了一下，也没有解决一些列问题。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> answer;
        
        for(int i=0;i<nums.size();i++){
            for(int j=i+1;j<nums.size();j++){
                for(int k=j+1;k<nums.size();k++){
                    if(nums[i]+nums[j]+nums[k]==0){
                        answer.push_back({nums[i],nums[j],nums[k]});
                    }
                }
            }
        }

        return answer;

        //尚未解决重复问题
        //尚未优化
    }
};
```

### 结合两数之和，哈希表

这种方法也可以做，但是被误导了，结果最后因为调用函数的开支太大，被gank了

提交如下（时间复杂度不合理，应该也有逻辑错误）

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hasmap;
        vector<int> answer;

        for (int i = 0; i < nums.size(); i++) {
            if (hasmap.count(target - nums[i])) {
                answer.push_back(i);
                answer.push_back(hasmap[target - nums[i]]);
            } else {
                hasmap[nums[i]] = i;
            }
        }
        return answer;
    }

    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> answer;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < nums.size(); i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int target = -nums[i];
            vector<int> subarray(nums.begin() + i + 1, nums.end()); 
            vector<int> two_sum_result = twoSum(subarray, target);

            if (!two_sum_result.empty()) {
                for (int j = 0; j < two_sum_result.size(); j += 2) {
                    vector<int> triplet = {nums[i], subarray[two_sum_result[j]], subarray[two_sum_result[j + 1]]};

                    sort(triplet.begin(), triplet.end());
                    
                    if (find(answer.begin(), answer.end(), triplet) == answer.end()) {
                        answer.push_back(triplet);
                    }
                }
            }
        }

        return answer;
    }
};
```
### 双指针

双指针的做法理解起来其实不难，因为这里并不能保证一次遍历的解唯一，所以需要先排序，跳过重复的数字。

然后先固定一个i，令left=i+1，right=nums.size()-1，在这个范围内进行检索即可。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> answer;
        sort(nums.begin(),nums.end());

        for(int i=0;i<nums.size();i++){
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            int target=-nums[i];
            int left=i+1,right=nums.size()-1;

            while(left<right){
                int sum=nums[left]+nums[right];
                if(sum==target){
                    answer.push_back({nums[i],nums[left],nums[right]});
                    while(left<right && nums[left]==nums[left+1]){
                        left++;
                    }
                    while(left<right && nums[right]==nums[right-1]){
                        right--;
                    }
                    left++;
                    right--;
                }
                else if(sum<target){
                    left++;
                }
                else{
                    right--;
                }
            }
        }

        return answer;
    }
};
```