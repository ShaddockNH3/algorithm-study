[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

### 暴力

这题的暴力很简单，直接遍历插入即可，我这里也没有写。

### 双指针优化

这里的双指针优化有两种思路，但是这两种思路殊途同归，其移动的方式都是一样的。一种是采用累计零的方式，一种是采用定位零的方式。

代码实现分别如下：

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int snowBall = 0; // 记录遇到的0的数量
        
        for(int i=0; i<nums.size(); i++){
            if(nums[i] == 0){
                snowBall++; // 滚雪球式积累0的数量
            }
            else if(snowBall > 0){
                // 将非零元素交换到前面的位置
                nums[i-snowBall] = nums[i]; 
                nums[i] = 0;
            }
        }
    }
};
```

上面的代码需要注意不能直接else，否则如果出现了[0，0，0，0]的情况，会永远前进不了。

实际上只需要更改成交换就能解决这个问题：

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int zeronum=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==0){
                zeronum+=1;
            }
            else{
                swap(nums[i],nums[i-zeronum]);
            }
        }
    }
};
```

### 二刷（2025.5.2）

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int zero_nums=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==0){
                zero_nums+=1;
            }
            else{
                swap(nums[i],nums[i-zero_nums]);
            }
        }
    }
};
```

二刷还卡了一小会儿，有点难绷。

不过最后还是跟上面的那个几乎一模一样就是了。