[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)

有点激动，第一次自己解出来，虽然不是最好的解法，但是复杂度是一样的。

然后就是，其实我现在压力很大，但是压力很大又有什么用呢？我之前看的一个视频很对，人最渴望的是什么，想不做什么就不做什么。不过我目前还有个想法，就是掌控力，能力越大掌控力越大。我渴望掌控力，因此我需要更强大的力量。

### 我的解答

我的解答是采用了双指针的想法，因为正好刚学的双指针，所以用上了。

代码如下：

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> hasmap;
        int left=0,right=0;
        int maxlength=0;
        while(right<s.length()){
            hasmap[s[right]]+=1;
            if(hasmap[s[right]]==2){
                while(hasmap[s[left]]!=2){
                    hasmap[s[left]]=0;
                    left++;
                }
                hasmap[s[left]]=1;
                left++;
            }
            maxlength=max(right-left+1,maxlength);
            right++;
        }
        return maxlength;
    }
};
```

思路有点类似于滚雪球，但是检索前面的，滚一下检测一下要不要抖掉一部分。

### 标准答案：

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 哈希集合，记录每个字符是否出现过
        unordered_set<char> occ;
        int n = s.size();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        // 枚举左指针的位置，初始值隐性地表示为 -1
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除一个字符
                occ.erase(s[i - 1]);
            }
            while (rk + 1 < n && !occ.count(s[rk + 1])) {
                // 不断地移动右指针
                occ.insert(s[rk + 1]);
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1);
        }
        return ans;
    }
};
```

答案其实跟我的想法差不多，但是区别是其利用的是set，也就是集合。其采用的是连续向右移动，然后在插入的时候判断是否原本的那个和现在的这个一样，如果一样，那么左侧向右移动一次，此时继续判断。

跟我的想法一样，不过我的是利用哈希表，他的是利用集合，本质思路都是一样的