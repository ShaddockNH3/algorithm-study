https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked

### 思路历程

这题最开始先上暴力，但是暴力肯定是不符合时间复杂度的，所以这里延伸出了三种思路。

第一，将每个字母都映射成一个独一无二的数字，其对应单词的计算是唯一的

第二，将单词排序，排序完后直接压入哈希表里，最后通过这个频次哈希表还原成一个向量

第三，统计每个单词的字母频次即可

第一种想法很快被抛弃了，如果是将a映射为1，b映射为2等，使用加法的话，形如bb，ac此类的将会无法分辨。

讨论区里说可以使用质数代表a到z，尝试后放弃。如果a代表2，那么z将代表103（应该是，反正大于100），题目里单词的长度最长可以达到100个字母，所以直接计算这个大数的100次方不现实（也可能是没找到更高效的想法）

然后后两种都是思路出来了不会写代码

### sort

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> hasmap;

        for(const string&str:strs){
            string sortedstr=str;
            sort(sortedstr.begin(),sortedstr.end());
            hasmap[sortedstr].push_back(str);
        }

        vector<vector<string>> answer;
        for(const auto&pair:hasmap){
            answer.push_back(pair.second);
        }

        return answer;
    }
};
```

这里需要注意的就是对容器的应用。

首先创建一个hasmap，hasmap的键是排序后的str，hasmap的值是一个用于存储原本str的数组，核心思路就是这句话。

最后就是遍历找答案了，不难理解。

### freq

leetcode官方使用cpp的解法得重写容器，使用deepseek出来的反而并不需要。其构建了一种特殊的方式，即频次字符`str=a1#b1#c1......z1`，使用频次字符，既可以完美的解决一切问题。

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> map;
        for(const string&s:strs){
            int count[26]={0};

            for(char c:s){
                count[c-'a']++;
            }

            string key;
            for(int i=0;i<26;i++){
                key+=('a'+i);
                key+=to_string(count[i]);
                key+='#';
            }

            map[key].push_back(s);
        }
        
        vector<vector<string>> res;
        for (auto& p : map) {
            res.push_back(move(p.second));
        }
        return res;
    }
};
```

move其实可有可无，move是一种快速复制的方法。

### 质数法

```cpp
// 前26个质数数组
const int primes[26] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};

class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<unsigned long long, vector<string>> map;
        
        for(const auto& s : strs){
            unsigned long long key = 1;
            for(char c : s){
                key *= primes[c-'a']; // 可能溢出！
            }
            map[key].push_back(s);
        }
        
        vector<vector<string>> res;
        for(auto& p : map) res.emplace_back(move(p.second));
        return res;
    }
};
```

正如此前所说的，质数法可能会溢出