[56. 合并区间 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)

### 答案

有大概想到，但是不知道怎么解。

总之来说，首先就是先按照区间的左端点排序，那么排完序之后，可以合并的区间肯定是连续的。

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.size()==0){
            return {};
        }

        sort(intervals.begin(),intervals.end());

        vector<vector<int>> ans;
        int ans_a=intervals[0][0];
        int ans_b=intervals[0][1];

        for(int i=1;i<intervals.size();i++){
            if(intervals[i][0]<=ans_b){
                ans_b=max(ans_b, intervals[i][1]);
            }
            else{
                ans.push_back({ans_a,ans_b});
                ans_a=intervals[i][0];
                ans_b=intervals[i][1];
            }
        }

        ans.push_back({ans_a, ans_b});

        return ans;
    }
};
```

### 解释：

1. ​**排序**：首先对区间按起始位置进行排序，这样我们可以按顺序处理区间。
2. ​**合并区间**：在遍历时，如果当前区间的起始位置小于或等于 `ans_b`，说明这两个区间可以合并。我们取 `ans_b` 和当前区间的结束位置的最大值来更新 `ans_b`。
3. ​**无法合并**：如果当前区间的起始位置大于 `ans_b`，说明这两个区间不能合并，将 `{ans_a, ans_b}` 加入 `ans`，并更新 `ans_a` 和 `ans_b` 为当前区间的起始和结束位置。
4. ​**最后一个区间**：在循环结束后，最后一个合并的区间 `{ans_a, ans_b}` 需要加入 `ans`。

这样，代码就能正确合并所有重叠的区间了。