https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked
### 朴素的想法

最朴素的想法就是利用两层的循环进行遍历求解，这里需要注意的是，由于是第一次刷leetcode，所以并不知道要所有情况都要有返回（即使题目的数据保证了必然有返回，但是为了防止用户输入非法的数据）

时间复杂度$O(n^2)$

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> answer(2,-1);

        int length=std::size(nums);
        for(int i=0;i<length;i++){
            for(int j=i+1;j<length;j++){
                if(nums[i]+nums[j]==target){
                    answer[0]=i;
                    answer[1]=j;
                }
            }
        }
        return answer;
    }
};
```

### 快排+二分

本来另一种想法是想先进行快排，然后再二分查找，代码实现如下，但是这种的思路甚至不如上面最朴素的想法。

```cpp
class Solution {
public:

    struct Num {
        int id;
        int val;
    };

    int partition(Num a[], int p, int r) {
        int i = p - 1, j = r;
        Num v = a[r];
        for (;;) {
            while (a[++i].val < v.val);
            while (v.val < a[--j].val) {
                if (j == p) break;
            }
            if (i >= j) break;
            swap(a[i], a[j]);
        }
        swap(a[i], a[r]);
        return i;
    }

    void quicksort(Num a[], int p, int r) {
        if (r <= p) return;
        int q = partition(a, p, r);
        quicksort(a, p, q - 1);
        quicksort(a, q + 1, r);
    }

    int binary_search(Num a[], int p, int r, int num, int excludeIndex) {
        while (p <= r) {
            int mid = (p + r) >> 1;
            if (num == a[mid].val && mid != excludeIndex) {
                return mid;
            } else if (num < a[mid].val || (num == a[mid].val && mid == excludeIndex)) {
                r = mid - 1;
            } else {
                p = mid + 1;
            }
        }
        return -1;
    }

    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> answer(2, -1);

        int length = nums.size();
        Num tt[length];
        for (int i = 0; i < length; i++) {
            tt[i].id = i;
            tt[i].val = nums[i];
        }

        quicksort(tt, 0, length - 1);

        for (int i = 0; i < length; i++) {
            int current_num = tt[i].val;
            int want_num = target - current_num;

            int j = binary_search(tt, 0, length - 1, want_num, i);

            if (j != -1) {
                answer[0] = tt[i].id;
                answer[1] = tt[j].id;
                return answer;
            }
        }
        return answer;
    }
};
```
### 利用哈希表的存储方式

stl库里`unordered_map`的底层实现原理是红黑树，访问以及**查询**都可以在$O(1)$的时间内实现。

这里需要注意的由于散列函数的存在，哈希表的查询的平均时间复杂度是$O(1)$，但是对于数组而言，沙逊的平均时间复杂度是$O(n)$。所以可以在这里进行优化。

首先遍历数组，并且在哈希表里**查询**这个数有没有所对应的可以是的构成target的数。如果查询到了，那么直接返回即可，如果没查询到，将这个数压入哈希表里。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hasmap;

        for(int i=0;i<nums.size();i++){
            int comp=target-nums[i];

            if(hasmap.count(comp)){
                return {hasmap[comp],i};
            }
            hasmap[nums[i]]=i; 
            //注意是把原来的数给压入哈希表
        }
        return {};
    }
};
```


### Arranging with deepseek

（抖抖耳朵翻开笔记本）主人这次的笔记好认真喵！让本猫娘帮您梳理思路吧～（掏出粉色小梳子开始整理）

---

### **解法逻辑树梳理**
**🌳 方法一：暴力双循环**
```markdown
优点：
- 直观易懂，适合小规模数据
- 空间复杂度O(1)

缺点：
- 存在冗余计算，时间复杂度O(n²)
- 未及时中断循环（发现解后应立刻return）

优化建议：
在if条件成立后立即返回，避免无效遍历：
```cpp
if(nums[i]+nums[j]==target){
    return {i, j}; // 直接返回
}
```

**🌳 方法二：快排+二分**
```markdown
优点：
- 时间复杂度O(nlogn)优于暴力法

隐藏问题：
1. 结构体排序需要额外O(n)空间
2. 处理重复元素时需排除自身（代码已处理）
3. 实际工程中排序+二分的时间常数可能比哈希法大

核心矛盾点：
虽然理论复杂度优于暴力法，但因以下原因表现可能不佳：
- 排序破坏原始索引需要额外存储
- 二分查找的条件分支较多
```

**🌳 方法三：哈希表法（最优解）**
```markdown
优点：
- 平均时间复杂度O(n)
- 单次遍历即可完成

关键修正：
❌ "unordered_map底层是红黑树" → ✅ **哈希表**
（map才是红黑树实现，unordered_map是哈希桶）

精妙之处：
```cpp
hasmap[nums[i]] = i; // 先检查后插入，避免自重复
```
处理案例[3,3]时：
- 第一个3存入前检查哈希表为空
- 第二个3检查时发现已有3（此时存入的是第一个3的索引）

时间复杂度细分：
- 平均情况：n次哈希操作 × O(1) = O(n)
- 最坏情况：所有元素碰撞 → O(n²)

---

### **对比表格**
| 方法         | 时间复杂度 | 空间复杂度 | 适用场景         |
|--------------|------------|------------|------------------|
| 暴力双循环   | O(n²)      | O(1)       | 数据量极小       |
| 排序+二分    | O(nlogn)   | O(n)       | 不允许修改原数组 |
| 哈希表法     | O(n)       | O(n)       | 通用最优解       |

---

### **高频考点总结**
1. **重复元素处理**  
   - 哈希表法天然规避相同元素重复使用
   - 排序法需在二分时排除当前索引

2. **哈希函数选择**  
   - C++对int的哈希是完美哈希（无碰撞）
   - 自定义类型需特化std::hash

3. **边界测试用例**  
   ```cpp
   // Case 1: 存在负数
   nums = [-3,4,9], target = 6 → [-3,9]
   // Case 2: 答案元素相同
   nums = [3,3], target = 6 → [0,1]
   // Case 3: 答案非相邻
   nums = [2,5,5,11], target=10 → [1,2]

---

### **工程优化技巧**
1. **预分配空间**  
   ```cpp
   hasmap.reserve(nums.size()); // 避免扩容开销
   ```
2. **一次遍历完成**  
   边遍历边检查，无需二次扫描

3. **异常处理**  
   题目保证有解，但实际工程应处理无解情况：
   ```cpp
   throw std::runtime_error("No solution");
   ```

（突然从屏幕里递出小鱼干）主人的笔记已经很完整啦！只要补上这些闪闪发亮的小细节，就是满分攻略了喵～(≧∇≦)ﾉ