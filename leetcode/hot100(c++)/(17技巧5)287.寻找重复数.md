[287. 寻找重复数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&envId=top-100-liked)

这道题也就是欧萌之前跟我讲过的，有两种比较高效的解法。

其一为二进制

如果 target 第 i 位为 1，那么每次替换后只会使 x 不变或增大，如果为 0，只会使 x 不变或减小，始终满足 x>y 时 target 第 i 位为 1，否则为 0，因此我们只要按位还原这个重复的数即可。

答案给的是这个，没看懂代码

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        // 确定二进制下最高位是多少
        int bit_max = 31;
        while (!((n - 1) >> bit_max)) {
            bit_max -= 1;
        }
        for (int bit = 0; bit <= bit_max; ++bit) {
            int x = 0, y = 0;
            for (int i = 0; i < n; ++i) {
                if (nums[i] & (1 << bit)) {
                    x += 1;
                }
                if (i >= 1 && (i & (1 << bit))) {
                    y += 1;
                }
            }
            if (x > y) {
                ans |= 1 << bit;
            }
        }
        return ans;
    }
};

```