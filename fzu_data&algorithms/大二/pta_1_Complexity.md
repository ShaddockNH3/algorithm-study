上课：

主要是介绍一下时间复杂度之类的概念，没什么特别的东西

无限循环程序实例(程序而非算法) (操作系统的轮询)

编程题：

--------------------------------------------------------------------------

7-1-1 最大子列和问题

分数 30

全屏浏览

切换布局

作者 DS课程组

单位 浙江大学

给定K个整数组成的序列{ N1​, N2​, ..., NK​ }，“连续子列”被定义为{ Ni​, Ni+1​, ..., Nj​ }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。

本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：

- 数据1：与样例等价，测试基本正确性；
- 数据2：102个随机整数；
- 数据3：103个随机整数；
- 数据4：104个随机整数；
- 数据5：105个随机整数；

### 输入格式:

输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。

### 输出格式:

在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。

### 输入样例:

```in
6
-2 11 -4 13 -5 -2
```

### 输出样例:

```out
20
```

代码长度限制

16 KB

时间限制

10000 ms

内存限制

64 MB

栈限制

8192 KB

-------------

思路是采用current_max和global_max来记录跟踪，线性扫描一遍既可以得出答案。使用global_max记录此前的子列和的最大值，而使用current_max记录当前的子列和。curretn_max其实就是自己和下个数的和，和下个数的大值。

上面其实解释地不是很清楚，gpt了一下，这里的思想在于：局部最优解。

Kadane算法利用动态规划的核心原则：**一个问题的最优解可以通过子问题的最优解得到**。

只需关心：

- **要不要继续扩展当前子列**，即将当前元素加到之前的子列中。
- **或者重新从当前元素开始**一个新的子列，因为之前的子列和为负数，继续扩展只会让和变小。

代码：

```
#include<iostream>

using namespace std;

  

int arr[100005];

  

int max(int a,int b){

    return a>b?a:b;

}

  

int solve(int k){

    int current_max=arr[0];

    int global_max=arr[0];

    for(int i=0;i<k;i++){

        current_max=max(current_max+arr[i],arr[i]);

        if (global_max<current_max){

            global_max=current_max;

        }

    }

    return global_max;

}

  

int main(){

    int k;cin>>k;

    int cnt=0;

    for(int i=0;i<k;i++){

        cin>>arr[i];

        if(arr[i]<0){

            cnt+=1;

        }

    }

    if (cnt==k){

        cout<<0<<endl;

    }

    else{

        cout<<solve(k)<<endl;

    }

    return 0;

}
```