[DS X 班级实验作业](http://ds.fzu.edu.cn/std/exp/bf5279a1-1205-4fac-86cd-dc2b5a821f48/9a49e3f2-33a4-40b4-97af-1a945008c746/cd63dcc4-2c1b-469b-978f-701d8bd5a8fa/)

算法与数据结构实验题 2.11 排队

★实验任务

某天，nk 正在和基友 5 排，马上就要晋级了，突然，卡住了，他才发现断网了，他很难过，于是他决定去营业厅问问为什么这几天锐捷一直断网，他到了营业厅才发现，营业厅门口已经排起了长队，由于人数实在太多，营业厅无法解决所有人的问题，他们决定先给所有人编号，第一个人是 2 号，第二个人是 3 号，以此类推；然后帮第一个人（2 号）解决问题，而他后面每隔两个人（4 号，6号，8 号…）都不能接受服务了，再然后帮 3 号服务，其后每隔三个人（9 号，15 号,21 号…）就都无法接受服务，然后帮 5 号服务，其后的每隔 5 个人都无法接受服务，然后帮 7 号服务，其后每隔7 个人都无法接受服务，营业厅最多只愿意服务n 个人，求第 n 个人的编号(ps.无法接受服务的人将伤心地离开队伍，不再进行排队)。

★数据输入

每个测试数据是一个正整数 n。(1<=n<=1000，答案最大编号不超过 10000)

★数据输出

输出第 n 个接受服务的人的编号。

详见样例。

|输入示例|
|---|
|20|

|输出示例|
|---|
|83|
### 埃氏筛变种

byx思路。

其实和上一道题目很像，我的意思是说，那种分而治之的思想。

就是说，我们不必一次性的就把这个问题完整地给解决，而是分成两步解决。

第一步，我们只关心谁离队了，谁被服务了。

第二步，我们才关心谁是第几个被服务的。

其实思路很简单，开一个10000的数组，从2（i）开始，被服务的仍然是0，没被服务的更改为1，而步长就是当前i本身。

经过了上述筛选，已经获得了一个被服务为0，没被服务为1的数组，判断然后push即可

```
#include<iostream>
#include<vector>
using namespace std;

int arr[10001];
vector<int> v;

void solve() {
	int n; cin >> n;
	for (int i = 2; i <= 10000; i++) {
		if (arr[i] == 0) {
			int p = i + 1;
			int cnt = 0;
			while (p <= 10000) {
				if (arr[p] == 0) {
					cnt++;
				}
				if (cnt == i) {
					arr[p] = 1;
					cnt = 0;
				}
				p++;
			}
		}
	}
	for (int i = 2; i <= 10000; i++) {
		if (arr[i] == 0) {
			v.push_back(i);
		}
		if (v.size() == n) {
			break;
		}
	}

	cout << v[n - 1] << endl;
}


int main() {
	solve();
	return 0;

}
```