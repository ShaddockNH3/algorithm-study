# 文件管理器

## 背景

操作系统具有对计算机硬件资源管理和调度的功能。文件是对占用了硬盘一定空间的对象的描述和抽象。考虑一般的文件具有文件名、大小和创建时间。文件管理在任何操作系统中都是必不可少的。文件管理器是用户用来观察和操作文件的一个软件。考虑一个简易的文件管理器，用户可以通过这个简易的文件管理器对某个目录下文件最大/小、文件名(字符串)字典序最大/最小的一些文件，即按XX排序功能，此外文件管理器具有删除和添加文件的功能。输入保证目录只有一级，操作随机。

## 输入及输出格式

第1行输入一个Q(1<=Q<=100000)，表示操作的次数。

第2-Q+1行输入一行操作序列

操作序列的格式为 op args

当op=1,即第一种操作时，args的格式为 folder name size 表示将要在某个folder目录(1<=folder<=5的整数)下添加文件名为name(1<=name<=100000的整数)的文件，文件大小为size(1<=size<=100000的整数)，如果文件名重复，就先删除原来的文件再进行1操作；

当op=2,即第二种操作时，args的格式为 folder name表示将要在某个folder目录(1<=folder<=5的整数)下删除文件名为name(1<=name<=100000的整数)的文件，如果文件名不存在，操作不执行；

当op=3,即第三种操作时，args的格式为 folder k 表示输出某个目录下文件大小最大至第k大的文件名，如果大小相同按文件名数字从小到大输出，如果不满k个文件只需要输出已有的文件名，如果文件夹为空或不存在则输出一个空行；

当op=4,即第四种操作时，args的格式为 folder k 表示输出某个目录下文件名数字大小最小至第k小的文件名，如果不满k个文件只需要输出已有的文件名，如果文件夹为空或不存在则输出一个空行；

保证1<= k <=10

## 备注

输出文件名以空格隔开，不输出多余的换行和空格

|**输入示例**|
|---|
|10|
|2 3 74071|
|3 1 2|
|3 2 8|
|2 3 71337|
|3 3 7|
|3 2 7|
|4 2 10|
|4 3 6|
|4 3 4|
|3 1 4|

| **输出示例** |
| -------- |
|          |
|          |
|          |
|          |
|          |
|          |
|          |
|          |

上方输出为8个空行


```
#define _CRT_SECURE_NO_WARNINGS

#define LL long long
#define EPS 1e-8
#define INF 0x7fffffff
#define lyh(i,a,b) for(int i=a;i<=b;i++)
#define hyl(i,a,b) for(int i=a;i>=b;i--)
#define debug(a) cout<<#a<<"="<<a<<endl;

#include<bits/stdc++.h>
#include<unordered_map>

using namespace std;

struct file_size {
	int name, size;
	bool operator<(const file_size& other) const{
		if (size == other.size) {
			return name < other.name;
		}
		return size > other.size;
	}
};

struct file_name {
	int name, size;
	bool operator<(const file_name& other) const {
		return name < other.name;
	}
};

map<int, set<file_size>> filesize;
map<int, set<file_name>> filename;
map<int, map<int, int>> filefolder;

void op1(int folder,int name,int size) {
	if (filefolder[folder].count(name)) {
		int oldSize = filefolder[folder][name];
		filesize[folder].erase({ name, oldSize });
		filename[folder].erase({ name, oldSize });
	}
	filefolder[folder][name] = size;
	filesize[folder].insert({name,size});
	filename[folder].insert({name,size});
}

void op2(int folder, int name) {
	if (filefolder[folder].count(name)) {
		int oldSize = filefolder[folder][name];
		filesize[folder].erase({ name, oldSize });
		filename[folder].erase({ name, oldSize });

		filefolder[folder].erase(name);
	}
}

void op3(int folder, int k) {
	if (filesize[folder].empty()) {
		cout << endl;
		return;
	}

	int cnt = 0;

	auto it = filesize[folder].begin();

	while(it!=filesize[folder].end()) {
		if (cnt++ > 0) cout <<" ";
		cout << it->name;
		if (cnt == k)break;
		it++;
	}

	cout << endl;
}

void op4(int folder,int k) {
	if (filename[folder].empty()) {
		cout << endl;
		return;
	}

	int cnt = 0;

	auto it = filename[folder].begin();

	while (it != filename[folder].end()) {
		if (cnt++ > 0)cout << " ";
		cout << it->name;
		if (cnt == k)break;
		it++;
	}

	cout << endl;
}

void solve() {
	int Q; cin >> Q;
	int op, folders, name, size, k;
	lyh(i, 1, Q) {
		cin >> op;

		switch (op){
		case 1: cin >> folders >> name >> size; op1(folders,name,size); break;
		case 2: cin >> folders >> name; op2(folders,name); break;
		case 3: cin >> folders >> k; op3(folders,k); break;
		case 4: cin >> folders >> k; op4(folders,k); break;
		}

	}
}

int main() {
	solve();
	return 0;
}

```


纯模拟，感觉还得再看看。