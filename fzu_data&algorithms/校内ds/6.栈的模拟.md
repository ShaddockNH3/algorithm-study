[DS X 班级实验作业](https://ds-fzu-edu-cn.fzu.edu.cn/std/exp/bf5279a1-1205-4fac-86cd-dc2b5a821f48/cd083306-92aa-4473-ba00-e117d49d4b40/063726f1-820a-4735-b181-4be06ab783f9)

算法与数据结构实验题 3.9 文档

★实验任务

TonyY 是一个word 小白，今天他对 word 中撤销和恢复功能特别感兴趣，玩耍了一个上午（mdzz~），现在他知道了它们的功能和快捷键：

撤销：ctrl+z，可以撤销最近 1 次之前的恢复和 input 操作。

恢复：ctrl+y，可以恢复最近1 次之前的撤销操作，但是 input 操作之前的撤销操作不能被恢复。

当然，TonyY 还要往里写东西，操作格式为 input str（str中不含空格，str长度为m，1=<m<=30）。

现在他对 word 玩耍了起来，想知道玩耍完的结果，你可以帮助他吗？

★数据输入

输入第一行为一个正整数 n（0<=n<=10000），表示 TonyY 的操作次数。

接下来 n 行，为上述的操作之一。

其中可能有不合法操作，直接跳过即可。

★数据输出

输出 word 中的内容，字符串间用空格隔开，如果 word 为空，输出”No output”

|输入示例1|
|---|
|4|
|input a|
|ctrl+z|
|ctrl+y|
|input b|

|输出示例1|
|---|
|a b|

|输入示例2|
|---|
|5|
|input a|
|input b|
|ctrl+z|
|input d|
|ctrl+y|

|输出示例2|
|---|
|a d|

### 解答

其实不会难就是了，主要是进行以下三个操作：

1. 当输入时，输入str栈，并且将temp栈清空
2. 当撤回时，只需要将str栈的东西放回temp
3. 当恢复时，只需要将temp栈里的东西放回str栈

最后输出即可，可以使用双端队列进行优化最后一段输出的代码

```
#define LL long long
#define EPS 1e-8
#define INF 0x7fffffff
#define lyh(i,a,b) for(int i=a;i<=b;i++)
#define hyl(i,a,b) for(int i=a;i>=b;i--)
#define debug(a) cout<<#a<<"="<<a<<endl;

#include<bits/stdc++.h>

using namespace std;

void solve() {
	int n; cin >> n;
	deque<string> str;
	stack<string> temp;
	string input_sth, words;

	lyh(i, 1, n) {
		cin >> input_sth;
		if (input_sth == "input") {
			cin >> words;
			str.push_back(words);

			while (!temp.empty()) {
				temp.pop();
			}
		}

		else if (input_sth == "ctrl+z") {
			if (!str.empty()) {
				temp.push(str.back());
				str.pop_back();
			}
		}

		else if (input_sth=="ctrl+y") {
			if (!temp.empty()) {
				str.push_back(temp.top());
				temp.pop();
			}
		}
	}

	if (str.empty()) {
		cout << "No output" << endl;
	}
	else {
		int length = str.size();
		lyh(i, 1, length) {
			cout << str.front();
			str.pop_front();
			if (i != length) {
				cout << " ";
			}
		}
		cout << endl;
	}
}

int main() {
	solve();
	return 0;
}
```