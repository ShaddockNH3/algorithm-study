
**数据结构与算法实验题** 索隆的难题

**★实验任务**

索隆是有名的路痴，为了不让索隆走丢，娜美给了索隆一本地图。该地图有N个城市，编号从1到N。每个城市有个代号，索隆每到一个城市只能知道该城市的代号而不知道该城市的编号，现有一份编号与代号对应的清单，你能帮索隆尽快地找到所在城市的编号吗？

**★数据输入**

输入第一行为两个正整数N (1< =N < =1000000)，M（1<=M<=10000） 表示有N个城市，M个询问

接下来N行，每行一个整数ai（0<=ai<=100000000），第i行表示编号i的城市的代号为ai。这N个整数各不相同。

接下来M行，每行一个整数b（0<=b<=100000000），表示当前所在城市的代号。

**★数据输出**

对于每个询问，输出一行一个整数，当前所在城市的编号，数据保证有解。

|**输入示例**|
|---|
|6 3|
|4|
|5|
|7|
|10|
|8|
|2|
|4|
|5|
|8|

|**输出示例**|
|---|
|1|
|2|
|5|

```
#define _CRT_SECURE_NO_WARNINGS

#define LL long long
#define EPS 1e-8
#define INF 0x7fffffff
#define lyh(i,a,b) for(int i=a;i<=b;i++)
#define hyl(i,a,b) for(int i=a;i>=b;i--)
#define debug(a) cout<<#a<<"="<<a<<endl;

#include<bits/stdc++.h>
#include<unordered_map>

using namespace std;

struct citys {
	int code;
	int id;
};

bool Compare(const citys& a, const citys& b) {
	return a.code < b.code;
}

void solve() {
	citys map[1000005];
	int n, m; scanf("%d %d", &n, &m);
	lyh(i, 1, n) {
		scanf("%d", &map[i].code);
		map[i].id = i;
	}

	sort(map + 1, map + n + 1, Compare);
	int name;

	lyh(i, 1, m) {
		scanf("%d", &name);
		auto it = lower_bound(map + 1, map + 1 + n, citys{ name, 0 }, Compare);
		if (it != map + 1 + n && it->code == name) {
			cout << it->id << endl;
		}
	}
}

int main() {
	solve();
	return 0;
}

```