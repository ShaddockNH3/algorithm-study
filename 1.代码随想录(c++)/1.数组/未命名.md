

```cpp
#include <bits/stdc++.h> 

using namespace std;

// getsmall 函数：找到将原始序列（其前缀和在 P_sums 中）“一刀切”成两部分后的最小差值
// 参数 P_sums: 这是一个前缀和数组，P_sums[k] = 原始值[0] + ... + 原始值[k]
//             这里的“原始值”指的是 行和数组 sum_of_each_row 或者 列和数组 sum_of_each_col 中的元素
int getsmall(const vector<int>& P_sums) {
    int n_elements = P_sums.size(); // 这是原始序列的元素个数 (比如总行数或总列数)

    // 如果原始序列的元素少于2个，就无法进行“一刀切”分成两个【都非空】的部分
    if (n_elements < 2) {
        return INT_MAX; // 返回一个非常大的数，表示无法进行有效划分
    }

    int total_sum_of_elements = P_sums[n_elements - 1]; // 前缀和数组的最后一个元素就是总和
    int min_diff = INT_MAX;

    // 遍历所有可能的“切割点”
    // 假设我们切割在第 k 个原始元素之后 (0-indexed)
    // 那么第一部分包含原始元素 0 到 k (共 k+1 个元素)
    // 第二部分包含原始元素 k+1 到 n_elements-1
    // k 可以从 0 到 n_elements-2 (确保第二部分至少有一个元素)
    for (int k = 0; k < n_elements - 1; ++k) {
        int sum_part1 = P_sums[k]; // 因为P_sums[k]直接就是原始值[0]到原始值[k]的和
        int sum_part2 = total_sum_of_elements - sum_part1; // 剩下的就是第二部分的和
        min_diff = min(min_diff, abs(sum_part1 - sum_part2));
    }

    return min_diff;
}

void test() {
    int n_rows, m_cols;
    scanf("%d %d", &n_rows, &m_cols);
    
    // 声明二维vector并正确初始化大小
    vector<vector<int>> vec(n_rows, vector<int>(m_cols));

    vector<int> sum_of_each_row(n_rows); 
    vector<int> prefix_sum_of_row_sums(n_rows); 

    for (int i = 0; i < n_rows; i++) {
        int current_row_sum = 0;
        for (int j = 0; j < m_cols; j++) {
            // int num; // 不再需要临时的num
            scanf("%d", &vec[i][j]); // 直接读取到 vec[i][j]
            current_row_sum += vec[i][j];
        }
        sum_of_each_row[i] = current_row_sum;
        if (i == 0) {
            prefix_sum_of_row_sums[i] = sum_of_each_row[i];
        } else {
            prefix_sum_of_row_sums[i] = sum_of_each_row[i] + prefix_sum_of_row_sums[i - 1];
        }
    }

    vector<int> sum_of_each_col(m_cols);
    vector<int> prefix_sum_of_col_sums(m_cols);
    for (int j = 0; j < m_cols; j++) { 
        int current_col_sum = 0;
        for (int i = 0; i < n_rows; i++) { 
            current_col_sum += vec[i][j]; 
        }
        sum_of_each_col[j] = current_col_sum;
        if (j == 0) {
            prefix_sum_of_col_sums[j] = sum_of_each_col[j];
        } else {
            prefix_sum_of_col_sums[j] = sum_of_each_col[j] + prefix_sum_of_col_sums[j - 1];
        }
    }
    
    int min_diff_if_horizontal_cut = INT_MAX;
    // 只有当行数大于等于2时，才能进行有效的横向切割
    if (n_rows >= 2) {
        min_diff_if_horizontal_cut = getsmall(prefix_sum_of_row_sums);
    }
    
    int min_diff_if_vertical_cut = INT_MAX;
    // 只有当列数大于等于2时，才能进行有效的纵向切割
    if (m_cols >= 2) {
        min_diff_if_vertical_cut = getsmall(prefix_sum_of_col_sums);
    }
    
    // 最终的最小差值是这两种切割方式中较小的一个
    // 如果某种切割方式不可能（比如只有一行时无法横向切），其差值会是 INT_MAX，不会影响min的结果
    int realsmall = min(min_diff_if_horizontal_cut, min_diff_if_vertical_cut);

    // 如果两种切割都不可行（比如1x1矩阵），realsmall会是INT_MAX。
    // 题目应该会保证至少有一种切割是可行的，或者对这种情况有特殊说明。
    // 通常，如果N*M的矩阵，只要N>=2或M>=2，就至少有一种切割可行。
    // 如果realsmall还是INT_MAX，说明无法按题目要求划分，但题目通常会避免这种情况。
    // 对于1x2的例子：
    // n_rows=1, m_cols=2
    // min_diff_if_horizontal_cut = INT_MAX (因为 n_rows < 2)
    // min_diff_if_vertical_cut = getsmall(prefix_sum_of_col_sums) -> getsmall([20, 29]) -> 11
    // realsmall = min(INT_MAX, 11) = 11.

    printf("%d", realsmall);
}

int main() {
    // 如果使用 cin/cout，可以取消下面两行的注释来加速
    // std::ios_base::sync_with_stdio(false);
    // std::cin.tie(NULL);
    test();
    return 0;
}
```