[844. 比较含退格的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/backspace-string-compare/description/)

先用了一个比较愚蠢的栈方法用来模拟，现在想想移除元素的方法

```cpp
class Solution {
public:
    string get_id(string s){
        stack<char> st;
        string new_s="";
        for(char ch:s){
            if(st.empty()&&ch=='#'){
                ;
            }
            else if(ch=='#'){
                st.pop();
            }
            else{
                st.push(ch);
            }
        }
        while(!st.empty()){
            new_s+=st.top();
            st.pop();
        }
        return new_s;
    }
    bool backspaceCompare(string s, string t) {
        return get_id(s)==get_id(t);
    }
};
```

如何用常数空间？应该会归于双指针法

```cpp
class Solution {
public:
    string get_id(string s){
        for(int fast=0;fast<s.size();fast++){
            if(s[fast]=='#'){
                int slow=fast-1;
                while(slow>=0){
                    if(s[slow]!='#'){
                        s[slow]='#';
                        break;
                    }
                    slow--;
                }
            }
        }
        string ans="";
        for(int i=0;i<s.size();i++){
            if(s[i]=='#'){
                ;
            }
            else{
                ans+=s[i];
            }
        }
        return ans;
    }

    bool backspaceCompare(string s, string t) {
        return get_id(s)==get_id(t);
    }
};
```

自己稍微改了一下，只能说一次ak的能力还是很差

这道题其实是引用了之前写过的构造唯一标识符的想法，然而这种做法和使用栈模拟的思路其实是一样的，空间复杂度相对较高

看看答案是怎么搞得：

```cpp
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int skips=0,skipt=0;
        int slength=s.size()-1,tlength=t.size()-1;
        
        while(slength>=0||tlength>=0){
            while(slength>=0){
                if(s[slength]=='#'){
                    skips++;
                    slength--;
                }
                else if(skips>0){
                    skips--;
                    slength--;
                }
                else{
                    break;
                }
            }
            while(tlength>=0){
                if(t[tlength]=='#'){
                    skipt++;
                    tlength--;
                }
                else if(skipt>0){
                    skipt--;
                    tlength--;
                }
                else{
                    break;
                }
            }
            if(slength>=0&&tlength>=0){
                if(s[slength]!=t[tlength]){
                    return false;
                }
            }
            else{
                if(slength>=0||tlength>=0){
                    return false;
                }
                //因为已经排除了标签共同大于零的情况
                //所以如果这两个只有一个大于等于0的话
                //那么这两个肯定不等长
                //所以直接返回false
            }
            slength--;
            tlength--;
        }
        return true;
    }
};
```

其实就是倒着利用双指针，不断向前覆盖！

思路很巧妙啊

