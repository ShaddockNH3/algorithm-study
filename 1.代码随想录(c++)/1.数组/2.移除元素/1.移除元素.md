[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left=0,right=nums.size()-1;
        int num=0;
        while(left<=right){
            while(left<=right && nums[right]==val){
                num+=1;
                right-=1;
            }
            if(left>right){
                break;
            }
            if(nums[left]==val){
                swap(nums[left],nums[right]);
            }
            left+=1;
        }
        return nums.size()-num;
    }
};
```

本来昨天写的时候一头乱麻，但是今天在纸上捋清楚思路之后就写的很清楚了，但是我的第一个版本忽略了边界条件，也就是[1]的情况

加之补足如上，顺便附上原本失败的代码：

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left=0,right=nums.size()-1;
        int num=0;
        while(left<right){
            while(nums[right]==val){
                num+=1;
                right-=1;
            }
            if(nums[left]==val){
                swap(nums[left],nums[right]);
            }
            left+=1;
        }
        return nums.size()-num;
    }
};
```

事实上答案采取覆盖法，因为多余的数根本不重要

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]!=val){
                nums[slow++]=nums[i];
            }
        }
        return slow;
    }
};
```


注意，这个直接覆盖的算法是不改变顺序的。