
[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)


```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int val=nums[0]-1;
        for(int i=0;i<nums.size()-2;i++){
            if(nums[i]==nums[i+1]){
                nums[i+1]=val;
            }
        }
        return removeElement(nums,val);
    }

    int removeElement(vector<int>& nums, int val) {
        int left=0,right=nums.size()-1;
        int num=0;
        while(left<right){
            while(nums[right]==val){
                num+=1;
                right-=1;
            }
            if(nums[left]==val){
                swap(nums[left],nums[right]);
            }
            left+=1;
        }
        return nums.size()-num;
    }
};





```


借助于ai改了很多个版本：

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.empty()){
            return 0;
        }
        int val=nums[0]-1;
        for(int slow=0;slow<nums.size();){
            int fast=slow;
            while(fast<nums.size()&&nums[slow]==nums[fast]){
                fast++;
            }
            for(int i=slow+1;i<fast;i++){
                nums[i]=val;
            }
            slow=fast;
        }
        return removeElement(nums,val);
    }

    int removeElement(vector<int>& nums, int val) {
        int slow=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]!=val){
                nums[slow++]=nums[i];
            }
        }
        return slow;
    }
};

```

我的想法是对的，因为前面的那个算法是不改变顺序的，所以我们只需要保留唯一并且将不唯一的东西赋值为同一个值即可。

我这里就是卡在了如何做到这点上，我这边其实没有很明确的更新slow和fast，也就是对快慢指针并没有很准确地了解。

我操了，我做的是对的，我原本的代码如下：

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int val=nums[0]-1;
        int fast=0;
        for(int slow=0;slow<nums.size();slow++){
            int current_num=nums[slow];
            if(fast<nums.size()&&nums[slow]==nums[fast]){
                fast++;
            }
            //只需要将if改成while即可，尼玛的，属于是自己眼瞎
            for(int i=slow+1;i<fast;i++){
                nums[i]=val;
            }
            slow=fast-1;
        }
        return removeElement(nums,val);
    }

    int removeElement(vector<int>& nums, int val) {
        int slow=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]!=val){
                nums[slow++]=nums[i];
            }
        }
        return slow;
    }
};
```

然后的话，答案是直接采用这样的方式，对双指针理解深刻

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n=nums.size();
        if(n==0){
            return 0;
        }
        int slow=1;
        for(int fast=1;fast<n;fast++){
            if(nums[fast-1]!=nums[fast]){
                nums[slow++]=nums[fast];
            }
        }
        return slow;
    }
};
```

喵~ 主人 SAMA，你真是太爱学习啦！一下子就有了两种解决“移除排序数组中的重复项”这个问题的思路呢！(ﾉ´ヮ`)ﾉ*: ･ﾟ 两种方法都能成功解决问题，但它们走路的方式有点不一样哦~ 咱来一起看看它们各自的特点吧！♪

咱这里有两个 `Solution` 类，为了方便区分，我们叫它们 **思路1 (经典的快慢指针法)** 和 **思路2 (主人SAMA的“标记再移除”法)** 吧！

**思路1 (经典的快慢指针法):**

C++

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) { // 空数组直接返回0喵
            return 0;
        }
        // slow 指针指向下一个不重复元素应该存放的位置
        // fast 指针负责向前探索新元素
        int fast = 1, slow = 1; // nums[0] 默认是第一个不重复元素，所以从1开始
        while (fast < n) {
            // 如果 fast 指向的元素和它前一个元素不同
            // (在排序数组中，这意味着 fast 指向的是一个新的不重复值)
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast]; // 就把它放到 slow 指针的位置
                ++slow; // slow 指针前进，准备放下一个不重复元素
            }
            ++fast; // fast 指针继续前进探索
        }
        return slow; // slow 的值就是不重复元素的个数
    }
};
```

**思路2 (主人SAMA的“标记再移除”法):**

C++

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) { // 同样处理空数组的情况喵
            return 0;
        }
        // 使用一个特殊值来标记那些要被“移除”的重复元素
        int placeholder_val = nums[0] - 1; 

        // 外层循环由 slow_idx (主人SAMA代码中的 slow) 控制，但它的步进在循环体内部处理
        for (int slow_idx = 0; slow_idx < nums.size(); /* slow_idx will be updated inside */) {
            int current_num = nums[slow_idx]; // 当前考察的数字

            // fast_scanner (主人SAMA代码中的 fast) 负责找到当前 current_num 连续出现的末尾
            int fast_scanner = slow_idx;
            while (fast_scanner < nums.size() && nums[fast_scanner] == current_num) {
                fast_scanner++;
            }
            // 此时，[slow_idx, fast_scanner - 1] 范围内的都是 current_num

            // 将 slow_idx 之后的重复元素标记为 placeholder_val
            for (int i = slow_idx + 1; i < fast_scanner; i++) {
                nums[i] = placeholder_val;
            }

            // slow_idx 跳到 fast_scanner 的位置，开始下一轮不同数字的处理
            slow_idx = fast_scanner;
        }

        // 调用 removeElement 函数，把所有标记过的 placeholder_val 元素“真正”移除
        return removeElement(nums, placeholder_val);
    }

    // removeElement 函数：将所有不等于 val 的元素移到数组前面
    int removeElement(vector<int>& nums, int val) {
        int k = 0; // 慢指针，记录下一个非 val 元素应存放的位置
        for (int i = 0; i < nums.size(); i++) { // 快指针遍历
            if (nums[i] != val) {
                nums[k++] = nums[i];
            }
        }
        return k; // 返回非 val 元素的数量
    }
};
```

好啦，现在我们来对比一下这两种思路的不同之处喵 (´▽｀)：

1. **核心策略 (Core Strategy)：**
    
    - **思路1：** 采用**一次遍历，直接构建**的策略。它用 `slow` 指针维护一个“有效”的不重复子数组的末尾，`fast` 指针去探索。一旦 `fast` 找到新的不重复元素，就直接把它追加到 `slow` 指针管理的地盘。重复的元素自然就被“跳过”了。
    - **思路2：** 采用**两阶段处理：“先标记，后移除”**的策略。第一阶段，它遍历数组，把除了第一个出现的数字之外的其他重复数字都用一个特殊的 `placeholder_val` 标记起来。第二阶段，调用一个通用的 `removeElement` 函数，把所有被标记的 `placeholder_val` 清理掉，将未标记的元素压缩到数组前面。
2. **“移除”操作的实现 (How "Removal" is Done)：**
    
    - **思路1：** “移除”是隐式的。通过只把不重复的元素复制到 `slow` 指针指定的位置，重复的元素就被留在了后面（最终会被新长度截断，或者说被覆盖）。
    - **思路2：** “移除”是显式的两步操作。先用特殊值替换掉重复元素，然后通过 `removeElement` 函数将非特殊值的元素迁移到数组头部。
3. **遍历次数 (Number of Passes over Data)：**
    
    - **思路1：** 只需要对数组进行一次完整的遍历 (`fast` 指针从头到尾走一遍)。
    - **思路2：** 实际上有两次主要的遍历过程。第一次是在 `removeDuplicates` 函数中为了找到并标记重复元素。第二次是在 `removeElement` 函数中为了将非标记元素移到前面。
4. **辅助函数与特殊值 (Helper Functions & Special Values)：**
    
    - **思路1：** 完全自给自足，不需要额外的辅助函数，也不需要定义特殊的标记值。
    - **思路2：** 依赖于一个辅助函数 `removeElement`。并且，它的核心机制依赖于一个 `placeholder_val`，这个值的选取需要保证它不会与数组中可能出现的正常元素冲突。
5. **代码复杂度与直观性 (Code Complexity & Intuitiveness)：**
    
    - **思路1：** 对于“排序数组去重”这个问题，这种快慢指针法是业界公认的标准解法，代码非常简洁，逻辑也相对直接，一旦理解了快慢指针的配合，就会觉得非常优雅。
    - **思路2：** 由于是分阶段处理，并且涉及到辅助函数和特殊值的管理，代码行数会多一些，逻辑步骤也更分散。但它体现了“分解问题”和“模块复用”的思想（`removeElement` 本身是个通用功能）。
6. **效率 (Efficiency)：**
    
    - **时间复杂度：** 两种思路的时间复杂度都是 $O(N)$，因为它们都需要至少遍历一遍数组中的所有元素。
    - **空间复杂度：** 两种思路的空间复杂度都是 $O(1)$，因为它们都是在原地修改数组，没有使用额外的、随输入规模增长的存储空间。
    - **常数因子：** 尽管时间复杂度级别相同，但思路1通常会因为单次遍历和更少的条件判断/赋值操作，在实际运行中可能比思路2（两次遍历）稍微快一点点，常数因子可能更小。

**总结一下喵：**

- **思路1 (经典快慢指针)** 更像是为“排序数组去重”量身定制的、高度优化的“专才”，追求极致的简洁和单遍处理效率。
- **思路2 (标记再移除)** 更像是一个“组合技”，它把问题分解成“识别重复”和“移除特定值”两个子问题，然后用通用的部件（`removeElement`）来解决其中一部分。这种方法虽然步骤多一点，但展示了另一种解决问题的角度。

主人 SAMA 能够思考并实现这两种不同的路径，真的非常了不起喵！每种思路都有它独特的闪光点和适用场景。通过对比，我们可以更深刻地理解不同算法策略的优劣和权衡，这对提升编程内功非常有帮助的！ (⑅•ᴗ•⑅)◜..°♡ 为主人 SAMA 的探索精神鼓掌！♪