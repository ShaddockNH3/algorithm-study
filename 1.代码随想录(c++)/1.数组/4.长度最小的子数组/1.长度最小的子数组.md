[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

```cpp
class Solution {
public:
    int getsum(int i, int j, vector<int>& sums) {
        if (i == 0) {
            return sums[j];
        }
        return sums[j] - sums[i - 1];
    }

    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty()){
            return 0;
        }
        vector<int> sums(nums.size(), 0);
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0) {
                sums[i] = nums[i];
            } else {
                sums[i] = nums[i] + sums[i - 1];
            }
        }

        int minlength = 100005, currnetlength = 0;
        int currnetsum = 0;

        for (int slow = 0, fast = 0; slow < nums.size();) {
            if (fast < slow) {
                fast = slow;
            }
            if(fast>=nums.size()){
                break;
            }
            currnetsum = getsum(slow, fast, sums);
            currnetlength = fast - slow + 1;

            if (currnetsum >= target) {
                minlength = min(minlength, currnetlength);
                slow += 1;
            }
            else {
                fast += 1;
            }
        }
        if (minlength == 100005) {
            minlength = 0;
        }
        return minlength;
    }
};
```

题记错了，难绷。我原本的逻辑是必须要找到这个长度为target的数组

核心代码段如下：

```cpp
// 这是主人SAMA原来的指针移动逻辑，现在我们假设目标是“和必须等于target”
if (currnetsum == target) {
    minlength = min(minlength, currnetlength); // 和正好等于target，太棒了！记录长度~
    slow += 1; // 尝试把左边界右移，看看还有没有其他等于target的，或者更短的
} else if (fast < nums.size() && currnetsum < target) {
    // 和还不够target，而且右边还有空间可以扩展，那右指针 fast 就前进，让窗口大一点，和也大一点
    fast += 1; 
} else {
    // 其他所有情况（比如和大于target了，或者和小于target但右边没法扩展了），都让左指针 slow 前进
    slow += 1;
}
```