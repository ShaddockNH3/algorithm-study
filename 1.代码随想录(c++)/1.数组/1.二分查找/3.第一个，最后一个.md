
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target, int left, int right) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int first_target = search(nums, target, 0, nums.size() - 1);
        if (first_target == -1) {
            return {-1, -1};
        }
        int left = first_target;
        int right = first_target;
        while (1) {
            int current_left = search(nums, target, 0, left - 1);
            if (current_left != -1) {
                left = current_left;
            } else {
                break;
            }
        }

        while (1) {
            int current_right =
                search(nums, target, right + 1, nums.size() - 1);
            if (current_right != -1) {
                right = current_right;
            } else {
                break;
            }
        }

        return {left, right};
    }
};
```

一遍过

但是我感觉我的代码效率有点低，因为重复调用了search。

事实上就是二分的变种，就是说并非三个分支，而是合并为两个分支，这样可以找到最边界的地方